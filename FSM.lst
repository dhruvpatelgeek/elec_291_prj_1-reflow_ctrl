0000              1   ; ISR_example.asm: a) Increments/decrements a BCD variable every half second using
0000              2   ; an ISR for timer 2; b) Generates a 2kHz square wave at pin P3.7 using
0000              3   ; an ISR for timer 0; and c) in the 'main' loop it displays the variable
0000              4   ; incremented/decremented using the ISR for timer 2 on the LCD.  Also resets it to 
0000              5   ; zero if the 'CLEAR' pushbutton connected to P1.7 is pressed.
0000              6   ; Start/Constants
                  8       $LIST
0000             10   
0000             11       CLK           EQU 7373000  ; Microcontroller system crystal frequency in Hz
0000             12       TIMER0_RATE   EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0000             13       TIMER0_RELOAD EQU ((65536-(CLK/(2*TIMER0_RATE))))
0000             14       TIMER1_RATE   EQU 100     ; 100Hz, for a timer tick of 10ms
0000             15       TIMER1_RELOAD EQU ((65536-(CLK/(2*TIMER1_RATE))))
0000             16   
0000             17   
0000             18   
0000             19       CCU_RATE    EQU 11025     ; 22050Hz is the sampling rate of the wav file we are playing
0000             20       CCU_RELOAD  EQU ((65536-((CLK/(2*CCU_RATE)))))
0000             21       BAUD        EQU 115200
0000             22       BRVAL       EQU ((CLK/BAUD)-16)
0000             23   
0000             24   
0000             25   
0000             26       ; Commands supported by the SPI flash memory according to the datasheet
0000             27       WRITE_ENABLE     EQU 0x06  ; Address:0 Dummy:0 Num:0
0000             28       WRITE_DISABLE    EQU 0x04  ; Address:0 Dummy:0 Num:0
0000             29       READ_STATUS      EQU 0x05  ; Address:0 Dummy:0 Num:1 to infinite
0000             30       READ_BYTES       EQU 0x03  ; Address:3 Dummy:0 Num:1 to infinite
0000             31       READ_SILICON_ID  EQU 0xab  ; Address:0 Dummy:3 Num:1 to infinite
0000             32       FAST_READ        EQU 0x0b  ; Address:3 Dummy:1 Num:1 to infinite
0000             33       WRITE_STATUS     EQU 0x01  ; Address:0 Dummy:0 Num:1
0000             34       WRITE_BYTES      EQU 0x02  ; Address:3 Dummy:0 Num:1 to 256
0000             35       ERASE_ALL        EQU 0xc7  ; Address:0 Dummy:0 Num:0
0000             36       ERASE_BLOCK      EQU 0xd8  ; Address:3 Dummy:0 Num:0
0000             37       READ_DEVICE_ID   EQU 0x9f  ; Address:0 Dummy:2 Num:1 to infinite
0000             38   ;Vectors
0000             39       ; Reset vector
0000             40       org 0x0000
0000 020CF3      41           ljmp main
0003             42   
0003             43       ; External interrupt 0 vector (not used in this code)
0003             44       org 0x0003
0003 32          45           reti
0004             46   
0004             47       ; Timer/Counter 0 overflow interrupt vector
000B             48       org 0x000B
000B 020460      49           ljmp Timer0_ISR
000E             50   
000E             51       ; External interrupt 1 vector (not used in this code)
0013             52       org 0x0013
0013 32          53           reti
0014             54   
0014             55       ; Timer/Counter 1 overflow interrupt vector
001B             56       org 0x001B
001B 02047A      57           ljmp Timer1_ISR
001E             58   
001E             59       ; Serial port receive/transmit interrupt vector (not used in this code)
0023             60       org 0x0023 
0023 32          61           reti
0024             62   
005B             63       org 0x005b ; CCU interrupt vector.  Used in this code to replay the wave file.
005B 0204E9      64           ljmp CCU_ISR
005E             65   
005E             66   
005E             67       ;                                                        -                     
005E             68       ;                                                       -  -                    
005E             69       ;                                                      -    -                   
005E             70       ;                              leave it at this temp>>-      -                  
005E             71       ;                                                    -        -                 
005E             72       ;                                                   -          -                 
005E             73       ;                                                  -            -               
005E             74       ;                                                 -              -              
005E             75       ;                                                -                -             
005E             76       ;                                               -                  -            
005E             77       ;                                              -                    -           
005E             78       ;                                             -    reflow>>cool     -          
005E             79       ;               -----------------------------    (temperature only)  -         
005E             80       ;              -     soak (time+temp)                                 -        
005E             81       ;             -                                                        -       
005E             82       ;            -                                                          -       
005E             83       ;          -                                                             -      
005E             84       ;         -                                                               -     
005E             85       ;        -                                                                 -    
005E             86       ;      -                                                                    -    
005E             87       ;     - ramp to soak (temperature)                                           -   
005E             88       ;   -                                                                         -   
005E             89       ;   state 1 ((temp==soak)? ssr_off: ssr_on)
005E             90       ;          state 2 ((time=soak_time)?(pwm_off):(pwn_on)
005E             91       ;                                           state 3 ((temp==soak)? ssr_off: ssr_on)
005E             92       ;                                                        state 4 (cooling ssr_off)
005E             93       ;                                                                             state 5 (done)
005E             94   
005E             95       ; In the 8051 we can define direct access variables starting at location 0x30 up to location 0x7F
005E             96   ;Variables(dseg) 
0030             97       dseg at 0x30
0030             98   
0030             99       Result:    ds 4
0034            100       x:         ds 4
0038            101       y:         ds 4
003C            102       bcd:       ds 5
0041            103       ;FSM varialbles
0041            104       temp_soak: ds 1 ; temp to soak
0042            105       time_soak: ds 1 ; time to soak
0043            106       temp_refl: ds 1 ; temp of relfow
0044            107       time_refl: ds 1 ; time to reflow 
0045            108       state: ds 1 ; current state 
0046            109       state_lcd: ds 1
0047            110       temp: ds 1 ; current temp in degree C
0048            111       sec: ds 1 ; current time in seconds 
0049            112       product: ds 1; pwm-currsec
004A            113       pwm: ds 1 ; 
004B            114   
004B            115       ;Timer variables
004B            116       Count1ms:     ds 2 ; Used to determine when half second has passed
004D            117       reflow_temp:  ds 2
004F            118       soak_temp:    ds 2
0051            119       reflow_temp_var: ds 1
0052            120       BCD_counter:  ds 1 ; The BCD counter incrememted in the ISR and displayed in the main loop
0053            121       hour:         ds 1
0054            122       reflow_sec:   ds 1
0055            123       reflow_min:   ds 1
0056            124       soak_sec:     ds 1
0057            125       soak_min:     ds 1
0058            126       Count10ms:    ds 1 ; Used to determine when half second has passed
0059            127       w:             ds 3 ; 24-bit play counter.  Decremented in CCU ISR.
005C            128       minutes:       ds 1
005D            129       seconds:       ds 1
005E            130       T2S_FSM_state: ds 1
005F            131       Count5ms:      ds 1
0060            132       five_sec_flag:  ds 1
0061            133   
0061            134   ;flags(bseg)
0000            135       BSEG
0000            136       T2S_FSM_start:     dbit 1
0001            137       seconds_flag:      dbit 1
0002            138       mf:                dbit 1
0003            139       half_seconds_flag: dbit 1 ; Set to one in the ISR every time 500 ms had passed
0004            140       AMPM_flag:         dbit 1
0005            141       alarm_AMPM_flag:   dbit 1
0006            142       on_off_flag:       dbit 1 ; 1 is on
0007            143       alarm_buzzer_flag: dbit 1
0008            144       TR1_flag:          dbit 1
0009            145       tt_reflow_flag:    dbit 1
000A            146       tt_flag_soak:      dbit 1
000B            147   
000B            148       ;_ _ _ _ | _ _ _ _ _ _
000B            149       ;
000B            150       ;pwm = 40 (say)
000B            151       ;then output will be 100 
000B            152       ;_________
000B            153       ;         |
000B            154       ;         |_____________
000B            155       ; where period is 1 second 
000B            156       ; In the 8051 we have variables that are 1-bit in size.  We can use the setb, clr, jb, and jnb
000B            157       ; instructions with these variables.  This is how you define a 1-bit variable:
000B            158   
000B            159   ;Pin config(cseg)
000B            160   
005E            161       cseg
005E            162       ; These 'equ' must match the wiring between the microcontroller and the LCD!
005E            163       LCD_RS equ P0.5
005E            164       LCD_RW equ P0.6
005E            165       LCD_E  equ P0.7
005E            166       LCD_D4 equ P1.2
005E            167       LCD_D5 equ P1.3
005E            168       LCD_D6 equ P1.4
005E            169       LCD_D7 equ P1.6
005E            170   
005E            171       CLEAR         equ P3.0
005E            172    ;   SOUND_OUT     equ P2.7
005E            173    ;   UPDOWN        equ P2.4
005E            174   
005E            175       FLASH_CE    EQU P2.4
005E            176       SOUND       EQU P2.7
005E            177       
005E            178       SETUP_SOAK_Button equ  P2.1
005E            179       set_BUTTON        equ  P2.0
005E            180       Button_min    equ  P2.6
005E            181       HOME_BUTTON   equ  P2.7
005E            182   
005E            183   
005E            184    ;start         equ P0.7
005E            185   
005E            186   ;include files
                546   $LIST
                189   	    $LIST
0399            191   ;Strings
0399            192     ;                       1234567890123456
0399            193      ;General
0399 0D0A00     194       Newline:          db   '\r', '\n', 0
039C 20202020   195       Space:            db   '      ','\r', '\n', 0
     20200D0A
     00
03A5 20202020   196       nothing:          db '                ',0      
     20202020
     20202020
     20202020
     00
03B6 20202020   197       test2:            db '      Test2     ',0
     20205465
     73743220
     20202020
     00
03C7 20202020   198       hot:                           db '      HOT       ', 0
     2020484F
     54202020
     20202020
     00
03D8 3A00       199       dots:             db ':',0
03DA 4243445F   200       Initial_Message:  db 'BCD_counter: xx ', 0
     636F756E
     7465723A
     20787820
     00
03EB            201      ;Home page
03EB 54656D70   202       Temp0:            db 'Temp:xxxC       ', 0
     3A787878
     43202020
     20202020
     00
03FC 54696D65   203       Time:             db 'Time xx:xx SET  ', 0
     2078783A
     78782053
     45542020
     00
040D            204      ;Second Page
040D 2020534F   205       soak_reflw:       db '  SOAK  REFLOW  ', 0
     414B2020
     5245464C
     4F572020
     00
041E            206      ;Reflow Setup
041E 54656D70   207       reflow_setup:     db 'Temp',0
     00
0423 2A524546   208       reflow_setup4:    db '*REFLOW*',0
     4C4F572A
     00
042C 54696D65   209       reflow_setup2:    db 'Time',0
     00
0431 484F4D45   210       reflow_setup3:    db 'HOME',0
     00
0436            211      ;Soak Setup
0436 54656D70   212       soak_setup0:      db 'Temp',0
     00
043B 202A534F   213       soak_setup1:      db ' *SOAK*',0
     414B2A00
0443 54696D65   214       soak_setup2:      db 'Time',0
     00
0448 484F4D45   215       soak_setup3:      db 'HOME',0
     00
044D            216   
044D            217   ;------ISR-------;
044D            218       ;---------------------------------;
044D            219       ; Routine to initialize the ISR   ;
044D            220       ; for timer 0                     ;
044D            221       ;---------------------------------;
044D            222       Timer0_Init:
044D E589       223           mov a, TMOD
044F 54F0       224           anl a, #0xf0 ; Clear the bits for timer 0
0451 4401       225           orl a, #0x01 ; Configure timer 0 as 16-timer
0453 F589       226           mov TMOD, a
0455 758CFC     227           mov TH0, #high(TIMER0_RELOAD)
0458 758A7C     228           mov TL0, #low(TIMER0_RELOAD)
045B            229           ; Enable the timer and interrupts
045B D2A9       230           setb ET0  ; Enable timer 0 interrupt
045D D28C       231           setb TR0  ; Start timer 0
045F 22         232           ret
0460            233   
0460            234       ;---------------------------------;
0460            235       ; ISR for timer 0.  Set to execute;
0460            236       ; every 1/4096Hz to generate a    ;
0460            237       ; 2048 Hz square wave at pin P3.7 ;
0460            238       ;---------------------------------;
0460            239       Timer0_ISR:
0460 758CFC     240           mov TH0, #high(TIMER0_RELOAD)
0463 758A7C     241           mov TL0, #low(TIMER0_RELOAD)
0466            242       ;    cpl SOUND_OUT ; Connect speaker to this pin
0466 32         243           reti
0467            244   
0467            245       ;---------------------------------;
0467            246       ; Routine to initialize the ISR   ;
0467            247       ; for timer 1                     ;
0467            248       ;---------------------------------;
0467            249       Timer1_Init:
0467 E589       250           mov a, TMOD
0469 540F       251           anl a, #0x0f ; Clear the bits for timer 1
046B 4410       252           orl a, #0x10 ; Configure timer 1 as 16-timer
046D F589       253           mov TMOD, a
046F 758D6F     254           mov TH1, #high(TIMER1_RELOAD)
0472 758BFF     255           mov TL1, #low(TIMER1_RELOAD)
0475            256           ; Enable the timer and interrupts
0475 D2AB       257           setb ET1  ; Enable timer 1 interrupt
0477 D28E       258           setb TR1  ; Start timer 1
0479 22         259           ret
047A            260   
047A            261       ;---------------------------------;
047A            262       ; ISR for timer 1                 ;
047A            263       ;---------------------------------;
047A            264       Timer1_ISR:
047A 758D6F     265           mov TH1, #high(TIMER1_RELOAD)
047D 758BFF     266           mov TL1, #low(TIMER1_RELOAD)
0480 B2A6       267           cpl P2.6 ; To check the interrupt rate with oscilloscope. It must be precisely a 10 ms pulse.
0482            268           
0482            269           ; The two registers used in the ISR must be saved in the stack
0482 C0E0       270           push acc
0484 C0D0       271           push psw
0486            272           
0486            273           
0486            274           ; Increment the 8-bit 10-mili-second counter
0486 0558       275           inc Count10ms
0488            276           ; Increment the 16-bit one mili second counter
0488            277   
0488            278   
0488            279       Inc_Done:
0488 E558       280           mov a, Count10ms
048A 954A       281           subb a, pwm ; if pwm greater than a pwm is on else off
048C D4         282           da a
048D            283          ; mov a, product
048D 5005       284           jnc off_segment
048F D281       285           setb p0.1
0491 C3         286           clr c
0492 8005       287           sjmp pass
0494            288           off_segment:
0494 C281       289           clr p0.1
0496 C3         290           clr c
0497 8000       291           sjmp pass
0499            292   
0499            293           ; Check if 1 second has passed
0499            294           pass:
0499            295   
0499            296           ; Check if half second has passed
0499 E558       297           mov a, Count10ms
049B B4C824     298           cjne a, #200, Timer1_ISR_done ; Warning: this instruction changes the carry flag!
049E            299           ;----------------------------
049E 0548       300           inc sec ; one second has passed
04A0 E548       301           mov a,sec
04A2 D4         302           da a
04A3 F548       303           mov sec,a
04A5            304   
04A5 0560       305           inc five_sec_flag ; one second has passed
04A7 E560       306           mov a,five_sec_flag
04A9 D4         307           da a
04AA F560       308           mov five_sec_flag,a
04AC            309   
04AC E548       310           mov a,sec
04AE 755C00     311           mov minutes, #0
04B1 85E05D     312           mov seconds, acc
04B4            313   
04B4            314           
04B4            315           ;----------------------------
04B4            316           ; 500 milliseconds have passed.  Set a flag so the main program knows
04B4 D203       317           setb half_seconds_flag ; Let the main program know half second had passed
04B6 B28C       318           cpl TR0 ; Enable/disable timer/counter 0. This line creates a beep-silence-beep-silence sound.
04B8            319           ; Reset to zero the 10-milli-seconds counter, it is a 8-bit variable
04B8 755800     320           mov Count10ms, #0x0
04BB            321      ;     mov Count1ms, #0x00
04BB            322           ; Increment the BCD counter
04BB E552       323           mov a, BCD_counter
04BD            324       ;    jnb UPDOWN, Timer1_ISR_decrement
04BD 2401       325           add a, #0x01
04BF            326       ;    sjmp Timer1_ISR_da
04BF            327       ;Timer1_ISR_decrement:
04BF            328           ;add a, #0x99 ; Adding the 10-complement of -1 is like subtracting 1.
04BF            329       Timer1_ISR_da:
04BF D4         330           da a ; Decimal adjust instruction.  Check datasheet for more details!
04C0 F552       331           mov BCD_counter, a
04C2            332           
04C2            333       Timer1_ISR_done:
04C2 D0D0       334           pop psw
04C4 D0E0       335           pop acc
04C6 32         336           reti
04C7            337   
04C7            338   
04C7            339   
04C7 74696D65   340       timee:  db 'time', 0
     00
04CC 73746174   341       statee:  db 'state', 0
     6500
04D2            342   
04D2            343   
04D2            344       ;------------------------------
04D2            345       ;---------------------------------;
04D2            346       ; Routine to initialize the CCU.  ;
04D2            347       ; We are using the CCU timer in a ;
04D2            348       ; manner similar to the timer 2   ;
04D2            349       ; available in other 8051s        ;
04D2            350       ;---------------------------------;
04D2            351       CCU_Init:
04D2 75CDFE     352           mov TH2, #high(CCU_RELOAD)
04D5 75CCB2     353           mov TL2, #low(CCU_RELOAD)
04D8 75CFFE     354           mov TOR2H, #high(CCU_RELOAD)
04DB 75CEB2     355           mov TOR2L, #low(CCU_RELOAD)
04DE 75F980     356           mov TCR21, #10000000b ; Latch the reload value
04E1 75C980     357           mov TICR2, #10000000b ; Enable CCU Timer Overflow Interrupt
04E4 D2EC       358           setb ECCU ; Enable CCU interrupt
04E6 D2C8       359           setb TMOD20 ; Start CCU timer
04E8 22         360           ret
04E9            361   
04E9            362       ;---------------------------------;
04E9            363       ; ISR for CCU.  Used to playback  ;
04E9            364       ; the WAV file stored in the SPI  ;
04E9            365       ; flash memory.                   ;
04E9            366       ;---------------------------------;
04E9            367       CCU_ISR:
04E9 75E900     368           mov TIFR2, #0 ; Clear CCU Timer Overflow Interrupt Flag bit. Actually, it clears all the bits!
04EC            369           
04EC            370           ; The registers used in the ISR must be saved in the stack
04EC C0E0       371           push acc
04EE C0D0       372           push psw
04F0            373           
04F0            374           ; Check if the play counter is zero.  If so, stop playing sound.
04F0 E559       375           mov a, w+0
04F2 455A       376           orl a, w+1
04F4 455B       377           orl a, w+2
04F6 601D       378           jz stop_playing
04F8            379           
04F8            380           ;;yolo this is gonna fuck with the speaker
04F8            381           ; Increment the 16-bit one mili second counter
04F8 054B       382           inc Count1ms+0    ; Increment the low 8-bits first
04FA E54B       383           mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
04FC 708A       384           jnz Inc_Done
04FE 054C       385           inc Count1ms+1
0500            386           ; Decrement play counter 'w'.  In this implementation 'w' is a 24-bit counter.
0500 74FF       387           mov a, #0xff
0502 1559       388           dec w+0
0504 B55907     389           cjne a, w+0, keep_playing
0507 155A       390           dec w+1
0509 B55A02     391           cjne a, w+1, keep_playing
050C 155B       392           dec w+2
050E            393           
050E            394       keep_playing:
050E            395   
050E 120561     396           lcall Send_SPI ; Read the next byte from the SPI Flash...
0511 F5F5       397           mov AD1DAT3, a ; and send it to the DAC
0513            398           
0513 8006       399           sjmp CCU_ISR_Done
0515            400   
0515            401       stop_playing:
0515 C2C8       402           clr TMOD20 ; Stop CCU timer
0517 D2A4       403           setb FLASH_CE  ; Disable SPI Flash
0519 C2A7       404           clr SOUND ; Turn speaker off
051B            405   
051B            406       CCU_ISR_Done:        
051B D0D0       407           pop psw
051D D0E0       408           pop acc
051F 32         409           reti
0520            410   ;----------------;
0520            411   
0520            412   ;---------------------------------;
0520            413   ; Initial configuration of ports. ;
0520            414   ; After reset the default for the ;
0520            415   ; pins is 'Open Drain'.  This     ;
0520            416   ; routine changes them pins to    ;
0520            417   ; Quasi-bidirectional like in the ;
0520            418   ; original 8051.                  ;
0520            419   ; Notice that P1.2 and P1.3 are   ;
0520            420   ; always 'Open Drain'. If those   ;
0520            421   ; pins are to be used as output   ;
0520            422   ; they need a pull-up resistor.   ;
0520            423   ;---------------------------------;
0520            424   Ports_Init:
0520            425       ; Configure all the ports in bidirectional mode:
0520 758400     426       mov P0M1, #00H
0523 758500     427       mov P0M2, #00H
0526 759100     428       mov P1M1, #00H
0529 759200     429       mov P1M2, #00H ; WARNING: P1.2 and P1.3 need 1 kohm pull-up resistors if used as outputs!
052C 75A400     430       mov P2M1, #00H
052F 75A500     431       mov P2M2, #00H
0532 75B100     432       mov P3M1, #00H
0535 75B200     433       mov P3M2, #00H
0538 22         434            ret
0539            435   
0539            436   ;---------------------------------;
0539            437   ; Initialize ADC1/DAC1 as DAC1.   ;
0539            438   ; Warning, the ADC1/DAC1 can work ;
0539            439   ; only as ADC or DAC, not both.   ;
0539            440   ; The P89LPC9351 has two ADC/DAC  ;
0539            441   ; interfaces.  One can be used as ;
0539            442   ; ADC and the other can be used   ;
0539            443   ; as DAC.  Also configures the    ;
0539            444   ; pin associated with the DAC, in ;
0539            445   ; this case P0.4 as 'Open Drain'. ;
0539            446   ;---------------------------------;
0539            447   InitDAC1:
0539            448       ; Configure pin P0.4 (DAC1 output pin) as open drain
0539 438410     449            orl     P0M1,   #00010000B
053C 438510     450            orl     P0M2,   #00010000B
053F 75A128     451       mov ADMODB, #00101000B ; Select main clock/2 for ADC/DAC.  Also enable DAC1 output (Table 25 of reference manual)
0542 759704     452            mov     ADCON1, #00000100B ; Enable the converter
0545 75F580     453            mov AD1DAT3, #0x80     ; Start value is 3.3V/2 (zero reference for AC WAV file)
0548 22         454            ret
0549            455   
0549            456   ;---------------------------------;
0549            457   ; Change the internal RC osc. clk ;
0549            458   ; from 7.373MHz to 14.746MHz.     ;
0549            459   ;---------------------------------;
0549            460   Double_Clk:
0549 90FFDE     461       mov dptr, #CLKCON
054C E0         462       movx a, @dptr
054D 4408       463       orl a, #00001000B ; double the clock speed to 14.746MHz
054F F0         464       movx @dptr,a
0550 22         465            ret
0551            466   
0551            467   ;---------------------------------;
0551            468   ; Initialize the SPI interface    ;
0551            469   ; and the pins associated to SPI. ;
0551            470   ;---------------------------------;
0551            471   Init_SPI:
0551            472            ; Configure MOSI (P2.2), CS* (P2.4), and SPICLK (P2.5) as push-pull outputs (see table 42, page 51)
0551 53A4CB     473            anl P2M1, #low(not(00110100B))
0554 43A534     474            orl P2M2, #00110100B
0557            475            ; Configure MISO (P2.3) as input (see table 42, page 51)
0557 43A408     476            orl P2M1, #00001000B
055A 53A5F7     477            anl P2M2, #low(not(00001000B)) 
055D            478            ; Configure SPI
055D 75E2D0     479            mov SPCTL, #11010000B ; Ignore /SS, Enable SPI, DORD=0, Master=1, CPOL=0, CPHA=0, clk/4
0560 22         480            ret
0561            481   
0561            482   ;---------------------------------;
0561            483   ; Sends AND receives a byte via   ;
0561            484   ; SPI.                            ;
0561            485   ;---------------------------------;
0561            486   Send_SPI:
0561 F5E3       487            mov SPDAT, a
0563            488   Send_SPI_1:
0563 E5E1       489            mov a, SPSTAT 
0565 30E7FB     490            jnb acc.7, Send_SPI_1 ; Check SPI Transfer Completion Flag
0568 F5E1       491            mov SPSTAT, a ; Clear SPI Transfer Completion Flag
056A E5E3       492            mov a, SPDAT ; return received byte via accumulator
056C 22         493            ret
056D            494   
056D            495   ;---------------------------------;
056D            496   ; SPI flash 'write enable'        ;
056D            497   ; instruction.                    ;
056D            498   ;---------------------------------;
056D            499   Enable_Write:
056D C2A4       500            clr FLASH_CE
056F 7406       501            mov a, #WRITE_ENABLE
0571 120561     502            lcall Send_SPI
0574 D2A4       503            setb FLASH_CE
0576 22         504            ret
0577            505   
0577            506   ;---------------------------------;
0577            507   ; This function checks the 'write ;
0577            508   ; in progress' bit of the SPI     ;
0577            509   ; flash memory.                   ;
0577            510   ;---------------------------------;
0577            511   Check_WIP:
0577 C2A4       512            clr FLASH_CE
0579 7405       513            mov a, #READ_STATUS
057B 120561     514            lcall Send_SPI
057E 7455       515            mov a, #0x55
0580 120561     516            lcall Send_SPI
0583 D2A4       517            setb FLASH_CE
0585 20E0EF     518            jb acc.0, Check_WIP ;  Check the Write in Progress bit
0588 22         519            ret
0589            520            
0589            521   ; Display a binary number in the LCD (must be less than 99).  Number to display passed in accumulator.
0589            522   LCD_number:
0589 C0E0       523            push acc
058B 75F00A     524            mov b, #10
058E 84         525            div ab
058F 4430       526            orl a, #'0'
0591 12031C     527            lcall ?WriteData
0594 E5F0       528            mov a, b
0596 4430       529            orl a, #'0'
0598 12031C     530            lcall ?WriteData
059B D0E0       531            pop acc
059D 22         532            ret
059E            533   
059E            534   ; Sounds we need in the SPI flash: 0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 30; 40; 50; minutes; seconds;
059E            535   ; Approximate index of sounds in file 'stop_watch.wav'
059E            536   ; This was generated using: computer_sender -Asw_index.asm -S2000 stop_watch.wav
059E            537   sound_index:
059E 00002D     538       db 0x00, 0x00, 0x2d ; 0 
05A1 003107     539       db 0x00, 0x31, 0x07 ; 1 
05A4 007007     540       db 0x00, 0x70, 0x07 ; 2 
05A7 00ADB9     541       db 0x00, 0xad, 0xb9 ; 3 
05AA 00F266     542       db 0x00, 0xf2, 0x66 ; 4 
05AD 0135D5     543       db 0x01, 0x35, 0xd5 ; 5 
05B0 017D33     544       db 0x01, 0x7d, 0x33 ; 6 
05B3 01C761     545       db 0x01, 0xc7, 0x61 ; 7 
05B6 021279     546       db 0x02, 0x12, 0x79 ; 8 
05B9 0249C1     547       db 0x02, 0x49, 0xc1 ; 9 
05BC 028F7A     548       db 0x02, 0x8f, 0x7a ; 10 
05BF 02D063     549       db 0x02, 0xd0, 0x63 ; 11 
05C2 031B87     550       db 0x03, 0x1b, 0x87 ; 12 
05C5 03630E     551       db 0x03, 0x63, 0x0e ; 13 
05C8 03B95F     552       db 0x03, 0xb9, 0x5f ; 14 
05CB 04113A     553       db 0x04, 0x11, 0x3a ; 15 
05CE 0466C4     554       db 0x04, 0x66, 0xc4 ; 16 
05D1 04C012     555       db 0x04, 0xc0, 0x12 ; 17 
05D4 052698     556       db 0x05, 0x26, 0x98 ; 18 
05D7 0574E9     557       db 0x05, 0x74, 0xe9 ; 19 
05DA 05D28E     558       db 0x05, 0xd2, 0x8e ; 20 
05DD 061D83     559       db 0x06, 0x1d, 0x83 ; 21 -> 30 
05E0 066342     560       db 0x06, 0x63, 0x42 ; 22 -> 40 
05E3 06AAB9     561       db 0x06, 0xaa, 0xb9 ; 23 -> 50 
05E6 06F3D6     562       db 0x06, 0xf3, 0xd6 ; 24 -> Minutes 
05E9 073F02     563       db 0x07, 0x3f, 0x02 ; 25 -> Seconds 
05EC            564   
05EC            565   ; Size of each sound in 'sound_index'
05EC            566   ; Generated using: computer_sender -Asw_index.asm -S2000 stop_watch.wav
05EC            567   Size_Length:
05EC 0030DA     568       db 0x00, 0x30, 0xda ; 0 
05EF 003F00     569       db 0x00, 0x3f, 0x00 ; 1 
05F2 003DB2     570       db 0x00, 0x3d, 0xb2 ; 2 
05F5 0044AD     571       db 0x00, 0x44, 0xad ; 3 
05F8 00436F     572       db 0x00, 0x43, 0x6f ; 4 
05FB 00475E     573       db 0x00, 0x47, 0x5e ; 5 
05FE 004A2E     574       db 0x00, 0x4a, 0x2e ; 6 
0601 004B18     575       db 0x00, 0x4b, 0x18 ; 7 
0604 003748     576       db 0x00, 0x37, 0x48 ; 8 
0607 0045B9     577       db 0x00, 0x45, 0xb9 ; 9 
060A 0040E9     578       db 0x00, 0x40, 0xe9 ; 10 
060D 004B24     579       db 0x00, 0x4b, 0x24 ; 11 
0610 004787     580       db 0x00, 0x47, 0x87 ; 12 
0613 005651     581       db 0x00, 0x56, 0x51 ; 13 
0616 0057DB     582       db 0x00, 0x57, 0xdb ; 14 
0619 00558A     583       db 0x00, 0x55, 0x8a ; 15 
061C 00594E     584       db 0x00, 0x59, 0x4e ; 16 
061F 006686     585       db 0x00, 0x66, 0x86 ; 17 
0622 004E51     586       db 0x00, 0x4e, 0x51 ; 18 
0625 005DA5     587       db 0x00, 0x5d, 0xa5 ; 19 
0628 004AF5     588       db 0x00, 0x4a, 0xf5 ; 20 
062B 0045BF     589       db 0x00, 0x45, 0xbf ; 21 -> 30
062E 004777     590       db 0x00, 0x47, 0x77 ; 22 -> 40
0631 00491D     591       db 0x00, 0x49, 0x1d ; 23 -> 50
0634 004B2C     592       db 0x00, 0x4b, 0x2c ; 24 -> minutes
0637 005C87     593       db 0x00, 0x5c, 0x87 ; 25 -> seconds
063A            594   
063A            595   ; The sound and its length from the two tables above is passed in the accumulator.
063A            596   Play_Sound_Using_Index:
063A D2A7       597            setb SOUND ; Turn speaker on
063C C2C8       598            clr TMOD20 ; Stop the CCU from playing previous request
063E D2A4       599            setb FLASH_CE
0640            600            
0640            601            ; There are three bytes per row in our tables, so multiply index by three
0640 75F003     602            mov b, #3
0643 A4         603            mul ab
0644 F8         604            mov R0, a ; Make a copy of the index*3
0645            605            
0645 C2A4       606            clr FLASH_CE ; Enable SPI Flash
0647 7403       607            mov a, #READ_BYTES
0649 120561     608            lcall Send_SPI
064C            609            ; Set the initial position in memory of where to start playing
064C 90059E     610            mov dptr, #sound_index
064F E8         611            mov a, R0
0650 93         612            movc a, @a+dptr
0651 120561     613            lcall Send_SPI
0654 A3         614            inc dptr
0655 E8         615            mov a, R0
0656 93         616            movc a, @a+dptr
0657 120561     617            lcall Send_SPI
065A A3         618            inc dptr
065B E8         619            mov a, R0
065C 93         620            movc a, @a+dptr
065D 120561     621            lcall Send_SPI
0660            622            ; Now set how many bytes to play
0660 9005EC     623            mov dptr, #Size_Length
0663 E8         624            mov a, R0
0664 93         625            movc a, @a+dptr
0665 F55B       626            mov w+2, a
0667 A3         627            inc dptr
0668 E8         628            mov a, R0
0669 93         629            movc a, @a+dptr
066A F55A       630            mov w+1, a
066C A3         631            inc dptr
066D E8         632            mov a, R0
066E 93         633            movc a, @a+dptr
066F F559       634            mov w+0, a
0671            635            
0671 7400       636            mov a, #0x00 ; Request first byte to send to DAC
0673 120561     637            lcall Send_SPI
0676            638            
0676 D2C8       639            setb TMOD20 ; Start playback by enabling CCU timer
0678            640   
0678 22         641            ret
0679            642    ; Send a character using the serial port
0679            643   putchar:
0679 3099FD     644           jnb TI, putchar 
067C            645           ; TI serial interrupt flag is set and when last bit (stop bit) 
067C            646           ; of receiving data byte is received, RI flag get set. IE register
067C            647           ; is used to enable/disable interrupt sources.
067C C299       648           clr TI
067E F599       649           mov SBUF, a
0680 22         650           ret
0681            651   
0681            652   ;---------------------------------------------------------------------------------;
0681            653   ; This is the FSM that plays minutes and seconds after the STOP button is pressed ;
0681            654   ; The state diagram of this FSM is available as 'Stop_Watch_FSM.pdf'              ;
0681            655   ;---------------------------------------------------------------------------------;
0681            656   T2S_FSM:
0681 E55E       657            mov a, T2S_FSM_state
0683            658   
0683            659   T2S_FSM_State0: ; Checks for the start signal (T2S_FSM_Start==1)
0683 B40013     660            cjne a, #0, T2S_FSM_State1
0686 30000F     661            jnb T2S_FSM_Start, T2S_FSM_State0_Done
0689            662            ; Check if minutes is larger than 19
0689 C3         663            clr c
068A E55C       664            mov a, minutes
068C 9414       665            subb a, #20
068E 5005       666            jnc minutes_gt_19
0690 755E01     667            mov T2S_FSM_state, #1
0693 8003       668            sjmp T2S_FSM_State0_Done
0695            669   minutes_gt_19:
0695 755E03     670            mov T2S_FSM_state, #3
0698            671   T2S_FSM_State0_Done:
0698 22         672            ret
0699            673            
0699            674   T2S_FSM_State1: ; Plays minutes when minutes is less than 20
0699 B40109     675            cjne a, #1, T2S_FSM_State2
069C E55C       676            mov a, minutes
069E 12063A     677            lcall Play_Sound_Using_Index
06A1 755E02     678            mov T2S_FSM_State, #2
06A4 22         679            ret 
06A5            680   
06A5            681   T2S_FSM_State2: ; Stay in this state until sound finishes playing
06A5 B40207     682            cjne a, #2, T2S_FSM_State3
06A8 20C803     683            jb TMOD20, T2S_FSM_State2_Done 
06AB 755E06     684            mov T2S_FSM_State, #6
06AE            685   T2S_FSM_State2_Done:
06AE 22         686            ret
06AF            687   
06AF            688   T2S_FSM_State3: ; Plays the tens when minutes is larger than 19, for example for 42 minutes, it plays 'forty'
06AF B4030F     689            cjne a, #3, T2S_FSM_State4
06B2 E55C       690            mov a, minutes
06B4 75F00A     691            mov b, #10
06B7 84         692            div ab
06B8 2412       693            add a, #18
06BA 12063A     694            lcall Play_Sound_Using_Index
06BD 755E04     695            mov T2S_FSM_State, #4
06C0 22         696            ret
06C1            697   
06C1            698   T2S_FSM_State4: ; Stay in this state until sound finishes playing
06C1 B40407     699            cjne a, #4, T2S_FSM_State5
06C4 20C803     700            jb TMOD20, T2S_FSM_State4_Done 
06C7 755E05     701            mov T2S_FSM_State, #5
06CA            702   T2S_FSM_State4_Done:
06CA 22         703       ret
06CB            704   
06CB            705   T2S_FSM_State5: ; Plays the units when minutes is larger than 19, for example for 42 minutes, it plays 'two'
06CB B40511     706            cjne a, #5, T2S_FSM_State6
06CE E55C       707            mov a, minutes
06D0 75F00A     708            mov b, #10
06D3 84         709            div ab
06D4 E5F0       710            mov a, b
06D6 6003       711            jz T2S_FSM_State5_Done ; Prevents from playing something like 'forty zero'
06D8 12063A     712            lcall Play_Sound_Using_Index
06DB            713   T2S_FSM_State5_Done:
06DB 755E02     714            mov T2S_FSM_State, #2
06DE 22         715            ret
06DF            716   
06DF            717   T2S_FSM_State6: ; Plays the word 'minutes'
06DF B40609     718            cjne a, #6, T2S_FSM_State7
06E2 7418       719            mov a, #24 ; Index 24 has the word 'minutes'
06E4 12063A     720            lcall Play_Sound_Using_Index
06E7 755E07     721            mov T2S_FSM_State, #7
06EA 22         722            ret
06EB            723   
06EB            724   T2S_FSM_State7: ; Stay in this state until sound finishes playing
06EB B40713     725            cjne a, #7, T2S_FSM_State8
06EE 20C80F     726            jb TMOD20, T2S_FSM_State7_Done 
06F1            727            ; Done playing previous sound, check if seconds is larger than 19
06F1 C3         728            clr c
06F2 E55D       729            mov a, seconds
06F4 9414       730            subb a, #20
06F6 5005       731            jnc seconds_gt_19
06F8 755E08     732            mov T2S_FSM_state, #8
06FB 809B       733            sjmp T2S_FSM_State0_Done
06FD            734   seconds_gt_19:
06FD 755E0A     735            mov T2S_FSM_state, #10
0700            736   T2S_FSM_State7_Done:
0700 22         737       ret
0701            738   
0701            739   T2S_FSM_State8: ; Play the seconds when seconds is less than 20.
0701 B40809     740            cjne a, #8, T2S_FSM_State9
0704 E55D       741            mov a, seconds
0706 12063A     742            lcall Play_Sound_Using_Index
0709 755E09     743            mov T2S_FSM_state, #9
070C 22         744            ret
070D            745   
070D            746   T2S_FSM_State9: ; Stay in this state until sound finishes playing
070D B40907     747            cjne a, #9, T2S_FSM_State10
0710 20C803     748            jb TMOD20, T2S_FSM_State9_Done 
0713 755E0D     749            mov T2S_FSM_State, #13
0716            750   T2S_FSM_State9_Done:
0716 22         751            ret
0717            752   
0717            753   T2S_FSM_State10:  ; Plays the tens when seconds is larger than 19, for example for 35 seconds, it plays 'thirty'
0717 B40A0F     754            cjne a, #10, T2S_FSM_State11
071A E55D       755            mov a, seconds
071C 75F00A     756            mov b, #10
071F 84         757            div ab
0720 2412       758            add a, #18
0722 12063A     759            lcall Play_Sound_Using_Index
0725 755E0B     760            mov T2S_FSM_state, #11
0728 22         761            ret
0729            762   
0729            763   T2S_FSM_State11: ; Stay in this state until sound finishes playing
0729 B40B07     764            cjne a, #11, T2S_FSM_State12
072C 20C803     765            jb TMOD20, T2S_FSM_State11_Done 
072F 755E0C     766            mov T2S_FSM_State, #12
0732            767   T2S_FSM_State11_Done:
0732 22         768            ret
0733            769   
0733            770   T2S_FSM_State12: ; Plays the units when seconds is larger than 19, for example for 35 seconds, it plays 'five'
0733 B40C11     771            cjne a, #12, T2S_FSM_State13
0736 E55D       772            mov a, seconds
0738 75F00A     773            mov b, #10
073B 84         774            div ab
073C E5F0       775            mov a, b
073E 6003       776            jz T2S_FSM_State12_Done ; Prevents from saying something like 'thirty zero'
0740 12063A     777            lcall Play_Sound_Using_Index
0743            778   T2S_FSM_State12_Done:
0743 755E09     779            mov T2S_FSM_State, #9
0746 22         780            ret
0747            781   
0747            782   T2S_FSM_State13: ; Plays the word 'seconds'
0747 B40D09     783            cjne a, #13, T2S_FSM_State14
074A 7419       784            mov a, #25 ; Index 25 has the word 'seconds'
074C 12063A     785            lcall Play_Sound_Using_Index
074F 755E0E     786            mov T2S_FSM_State, #14
0752 22         787            ret
0753            788   
0753            789   T2S_FSM_State14: ; Stay in this state until sound finishes playing
0753 B40E09     790            cjne a, #14, T2S_FSM_Error
0756 20C805     791            jb TMOD20, T2S_FSM_State14_Done 
0759 C200       792            clr T2S_FSM_Start 
075B 755E00     793            mov T2S_FSM_State, #0
075E            794   T2S_FSM_State14_Done:
075E 22         795            ret
075F            796   
075F            797   T2S_FSM_Error: ; If we got to this point, there is an error in the finite state machine.  Restart it.
075F 755E00     798            mov T2S_FSM_state, #0
0762 C200       799            clr T2S_FSM_Start
0764 22         800            ret
0765            801       
0765            802   ;WaitHalfSec:
0765            803   ;        mov R2, #178
0765            804   ;        Lr3: mov R1, #250
0765            805   ;        Lr2: mov R0, #166
0765            806   ;        Lr1: djnz R0, Lr1 ; 3 cycles->3*45.21123ns*166=22.51519us
0765            807   ;        djnz R1, Lr2 ; 22.51519us*250=5.629ms
0765            808   ;        djnz R2, Lr3 ; 5.629ms*89=0.5s (approximately)
0765            809   ;        ret
0765            810   ;        
0765            811   ;blink:
0765            812   ;        mov SP, #7FH
0765            813   ;        mov P3M1, #0   ; Configure P3 in bidirectional mode
0765            814   ;    M0:
0765            815   ;        cpl P3.7
0765            816   ;        Set_Cursor(1, 1)
0765            817   ;        Send_Constant_String(#nothing)
0765            818   ;        Set_Cursor(2, 1)
0765            819   ;        Send_Constant_String(#nothing)
0765            820   ;        Set_Cursor(1, 1)
0765            821   ;        Send_Constant_String(#hot)
0765            822   ;        Set_Cursor(2, 1)
0765            823   ;        Send_Constant_String(#hot)
0765            824   ;
0765            825   ;        lcall WaitHalfSec
0765            826   ;
0765            827   ;        ret
0765            828   ;
0765            829   ;convert:
0765            830   ;    mov x+0, Result
0765            831   ;        mov x+1, Result+1 
0765            832   ;        mov x+2, #0
0765            833   ;        mov x+3, #0
0765            834   ;    ret
0765            835   ;    
0765            836   ;
0765            837   Display_temp:
0765            838   ;    Load_y(410)
0765            839   ;    lcall mul32
0765            840   ;    Load_y(1023)
0765            841   ;    lcall div32
0765            842   ;    Load_y(273)
0765            843   ;    lcall sub32
0765            844   ;    lcall hex2bcd
0765            845   ;    lcall InitSerialPort
0765 C0E0       846            push acc
0767 7401       846            mov a, #1
0769 14         846            dec a
076A 120368     846            lcall ?Set_Cursor_1 ; Select column and row
076D D0E0       846            pop acc
076F C083       847            push dph
0771 C082       847            push dpl
0773 C0E0       847            push acc
0775 9003EB     847            mov dptr, #Temp0
0778 12035B     847            lcall ?Send_Constant_String
077B D0E0       847            pop acc
077D D082       847            pop dpl
077F D083       847            pop dph
0781            848   ;    lcall SendString
0781            849   ;    Set_Cursor(1, 5)    
0781            850   ;    Send_BCD(bcd+1) ; send fisrt 2 digits to putty
0781            851   ;    Display_BCD(bcd+1); send fisrt 2 digits to lcd
0781            852   ;    Set_Cursor(1, 7) 
0781            853   ;    Send_BCD(bcd) ; send last 2 digits to putty
0781            854   ;    Display_BCD(bcd+0) ; send last 2 digits to lcd
0781            855   ;    Set_Cursor(1, 5)
0781            856   ;    Send_Constant_String(#dots)
0781            857   ;    lcall SendString
0781            858   ;    mov DPTR, #Newline
0781            859   ;    lcall SendString
0781 22         860       ret
0782            861   ;config_adc:
0782            862   ;        clr CE_ADC 
0782            863   ;        mov R0, #00000001B; Start bit:1 
0782            864   ;        lcall DO_SPI_G
0782            865   ;
0782            866   ;        mov R0, #10000000B; Single ended, read channel 0 
0782            867   ;        lcall DO_SPI_G 
0782            868   ;        mov a, R1          ; R1 contains bits 8 and 9 
0782            869   ;        anl a, #00000011B  ; We need only the two least significant bits 
0782            870   ;        mov Result+1, a    ; Save result high.
0782            871   ;
0782            872   ;        mov R0, #55H; It doesn't matter what we transmit... 
0782            873   ;        lcall DO_SPI_G 
0782            874   ;        mov Result, R1     ; R1 contains bits 0 to 7.  Save result low. 
0782            875   ;        setb CE_ADC 
0782            876   ;        lcall convert  
0782            877   ;        mov a, bcd ; move temp to accumulator 
0782            878   ;        ret
0782            879   Reset_timer:
0782            880   
0782 C28E       881       clr TR1                 ; Stop timer 2
0784 E4         882       clr a
0785 F54B       883            mov Count1ms+0, a
0787 F54C       884            mov Count1ms+1, a
0789            885            ; Now clear the BCD counter and minutes
0789 F552       886            mov BCD_counter, a
078B D28E       887            setb TR1                ; Start timer 2
078D            888   
078D 22         889       ret
078E            890   Display_time:
078E C0E0       891            push acc
0790 7401       891            mov a, #1
0792 14         891            dec a
0793 120366     891            lcall ?Set_Cursor_2 ; Select column and row
0796 D0E0       891            pop acc
0798 C083       892            push dph
079A C082       892            push dpl
079C C0E0       892            push acc
079E 9003FC     892            mov dptr, #Time
07A1 12035B     892            lcall ?Send_Constant_String
07A4 D0E0       892            pop acc
07A6 D082       892            pop dpl
07A8 D083       892            pop dph
07AA C203       893       clr half_seconds_flag ; We clear this flag in the main loop, but it is set in the ISR for timer 2
07AC C0E0       894            push acc
07AE 7409       894            mov a, #9
07B0 14         894            dec a
07B1 120366     894            lcall ?Set_Cursor_2 ; Select column and row
07B4 D0E0       894            pop acc     ; the place in the LCD where we want the BCD counter value
07B6 C000       895            push ar0
07B8 A852       895            mov r0, BCD_counter
07BA 12036D     895            lcall ?Display_BCD
07BD D000       895            pop ar0 ; This macro is also in 'LCD_4bit.inc'
07BF C0E0       896            push acc
07C1 7406       896            mov a, #6
07C3 14         896            dec a
07C4 120366     896            lcall ?Set_Cursor_2 ; Select column and row
07C7 D0E0       896            pop acc     ; the place in the LCD where we want the BCD counter value
07C9 C000       897            push ar0
07CB A85C       897            mov r0, minutes
07CD 12036D     897            lcall ?Display_BCD
07D0 D000       897            pop ar0 ; This macro is also in 'LCD_4bit.inc'
07D2            898   
07D2 22         899       ret
07D3            900   ;;Timer couter 
07D3            901       sec_counter: 
07D3 E552       902           mov a,BCD_counter
07D5 B4600A     903           cjne a, #0x60, Continue1 ; check if the couter reached 60s
07D8 E55C       904           mov a, minutes
07DA 2401       905           add a, #0x01 ; add one to the minutes
07DC D4         906           da a ; Decimal adjust instruction.  Check datasheet for more details!
07DD F55C       907           mov minutes, a
07DF 120782     908           lcall Reset_timer
07E2            909                Continue1:
07E2 22         910           ret
07E3            911       min_counter:
07E3 E55C       912                    mov a,minutes
07E5 B4600B     913                    cjne a, #0x60, Continue2
07E8 C28E       914                    clr TR1                 ; Stop timer 2
07EA E4         915                    clr a                   
07EB F54B       916                    mov Count1ms+0, a
07ED F54C       917                    mov Count1ms+1, a       ; Now clear the BCD counter
07EF F55C       918                    mov minutes, a              ; Reset minutes
07F1 D28E       919           setb TR1                ; Start timer 2
07F3            920   
07F3            921                    Continue2:
07F3 22         922           ret
07F4            923   home_page:
07F4            924       ;--------Timer----------;
07F4 300309     925       jnb half_seconds_flag, Temp_sensor
07F7 1207D3     926       lcall sec_counter
07FA 1207E3     927       lcall min_counter
07FD 12078E     928       lcall Display_time
0800            929       ;-----------------------;
0800            930               
0800            931       ;-----TEMP SENSOR-------;
0800            932       Temp_sensor:
0800            933   ;    lcall config_adc
0800 120765     934       lcall Display_temp
0803            935   ;    lcall  WaitHalfSec 
0803            936   ;    ;-----------------------;
0803 22         937       ret
0804            938   ;
0804            939   setup_reflow_page:
0804 20A011     940            jb set_BUTTON, continue9
0807 C002       940            push AR2
0809 7A0A       940            mov R2, #10
080B 1202D7     940            lcall ?Wait_Milli_Seconds
080E D002       940            pop AR2
0810 20A005     940            jb set_BUTTON, continue9
0813 30A0FD     940            jnb set_BUTTON, $
0816            940   
0816 B209       941       cpl tt_reflow_flag
0818            942       continue9:
0818            943   
0818 200906     944       jb tt_reflow_flag, jump1
081B            945       ;jnb tt_reflow_flag, jump1
081B 1208FD     946       lcall INC_DEC_Reflow_time
081E 020824     947       ljmp display_reflow_page
0821            948       jump1:
0821 120945     949       lcall INC_DEC_Reflow_temp
0824            950   
0824            951   
0824            952       display_reflow_page:
0824 C0E0       953            push acc
0826 7405       953            mov a, #5
0828 14         953            dec a
0829 120368     953            lcall ?Set_Cursor_1 ; Select column and row
082C D0E0       953            pop acc
082E C000       954            push ar0
0830 A84D       954            mov r0, reflow_temp+0
0832 12036D     954            lcall ?Display_BCD
0835 D000       954            pop ar0
0837 C0E0       955            push acc
0839 7407       955            mov a, #7
083B 14         955            dec a
083C 120368     955            lcall ?Set_Cursor_1 ; Select column and row
083F D0E0       955            pop acc
0841 C000       956            push ar0
0843 A84E       956            mov r0, reflow_temp+1
0845 12036D     956            lcall ?Display_BCD
0848 D000       956            pop ar0
084A            957          
084A            958       
084A C0E0       959            push acc
084C 7401       959            mov a, #1
084E 14         959            dec a
084F 120368     959            lcall ?Set_Cursor_1 ; Select column and row
0852 D0E0       959            pop acc
0854 C083       960            push dph
0856 C082       960            push dpl
0858 C0E0       960            push acc
085A 90041E     960            mov dptr, #reflow_setup
085D 12035B     960            lcall ?Send_Constant_String
0860 D0E0       960            pop acc
0862 D082       960            pop dpl
0864 D083       960            pop dph
0866 C0E0       961            push acc
0868 7409       961            mov a, #9
086A 14         961            dec a
086B 120368     961            lcall ?Set_Cursor_1 ; Select column and row
086E D0E0       961            pop acc
0870 C083       962            push dph
0872 C082       962            push dpl
0874 C0E0       962            push acc
0876 900423     962            mov dptr, #reflow_setup4
0879 12035B     962            lcall ?Send_Constant_String
087C D0E0       962            pop acc
087E D082       962            pop dpl
0880 D083       962            pop dph
0882            963   
0882 C0E0       964            push acc
0884 7401       964            mov a, #1
0886 14         964            dec a
0887 120366     964            lcall ?Set_Cursor_2 ; Select column and row
088A D0E0       964            pop acc
088C C083       965            push dph
088E C082       965            push dpl
0890 C0E0       965            push acc
0892 90042C     965            mov dptr, #reflow_setup2
0895 12035B     965            lcall ?Send_Constant_String
0898 D0E0       965            pop acc
089A D082       965            pop dpl
089C D083       965            pop dph
089E C0E0       966            push acc
08A0 7408       966            mov a, #8
08A2 14         966            dec a
08A3 120366     966            lcall ?Set_Cursor_2 ; Select column and row
08A6 D0E0       966            pop acc
08A8 C083       967            push dph
08AA C082       967            push dpl
08AC C0E0       967            push acc
08AE 9003D8     967            mov dptr, #dots
08B1 12035B     967            lcall ?Send_Constant_String
08B4 D0E0       967            pop acc
08B6 D082       967            pop dpl
08B8 D083       967            pop dph
08BA C0E0       968            push acc
08BC 740C       968            mov a, #12
08BE 14         968            dec a
08BF 120366     968            lcall ?Set_Cursor_2 ; Select column and row
08C2 D0E0       968            pop acc
08C4 C083       969            push dph
08C6 C082       969            push dpl
08C8 C0E0       969            push acc
08CA 900431     969            mov dptr, #reflow_setup3
08CD 12035B     969            lcall ?Send_Constant_String
08D0 D0E0       969            pop acc
08D2 D082       969            pop dpl
08D4 D083       969            pop dph
08D6 C0E0       970            push acc
08D8 7409       970            mov a, #9
08DA 14         970            dec a
08DB 120366     970            lcall ?Set_Cursor_2 ; Select column and row
08DE D0E0       970            pop acc
08E0 C000       971            push ar0
08E2 A854       971            mov r0, reflow_sec
08E4 12036D     971            lcall ?Display_BCD
08E7 D000       971            pop ar0
08E9 C0E0       972            push acc
08EB 7406       972            mov a, #6
08ED 14         972            dec a
08EE 120366     972            lcall ?Set_Cursor_2 ; Select column and row
08F1 D0E0       972            pop acc
08F3 C000       973            push ar0
08F5 A855       973            mov r0, reflow_min
08F7 12036D     973            lcall ?Display_BCD
08FA D000       973            pop ar0
08FC            974   
08FC 22         975       ret
08FD            976       INC_DEC_Reflow_time:
08FD            977   
08FD 20A124     978            jb SETUP_SOAK_Button, check_decrement
0900 C002       978            push AR2
0902 7A0A       978            mov R2, #10
0904 1202D7     978            lcall ?Wait_Milli_Seconds
0907 D002       978            pop AR2
0909 20A118     978            jb SETUP_SOAK_Button, check_decrement
090C 30A1FD     978            jnb SETUP_SOAK_Button, $
090F            978    ; setup soak is also used to increment 
090F            979   
090F E554       980           mov a, reflow_sec
0911 B4590B     981           cjne a, #0x59, add_reflow_sec
0914 E555       982           mov a, reflow_min
0916 2401       983           add a, #0x01
0918 D4         984           da a
0919 F555       985           mov reflow_min, a
091B E4         986           clr a 
091C 020922     987           ljmp Continue5
091F            988           add_reflow_sec:
091F 2401       989           add a, #0x01
0921 D4         990           da a ; Decimal adjust instruction.  Check datasheet for more details!
0922            991           Continue5:
0922 F554       992           mov reflow_sec, a
0924            993   
0924            994           check_decrement:
0924 20A61D     995            jb Button_min, continue8
0927 C002       995            push AR2
0929 7A0A       995            mov R2, #10
092B 1202D7     995            lcall ?Wait_Milli_Seconds
092E D002       995            pop AR2
0930 20A611     995            jb Button_min, continue8
0933 30A6FD     995            jnb Button_min, $
0936            995   
0936 E554       996           mov a, reflow_sec
0938 B40004     997           cjne a, #0x00, sub_reflow_sec
093B E4         998           clr a 
093C 020942     999           ljmp Continue6
093F           1000           sub_reflow_sec:
093F 2499      1001           add a, #0x99 ; add 99 reduces 1
0941 D4        1002           da a ; Decimal adjust instruction.  Check datasheet for more details!
0942           1003           Continue6:
0942 F554      1004           mov reflow_sec, a
0944           1005           continue8:
0944 22        1006           ret
0945           1007       INC_DEC_Reflow_temp:
0945           1008           ;PushButton(SETUP_SOAK_Button,check_decrement2) ; setup soak is also used to increment 
0945           1009   
0945 20A164    1010               jb SETUP_SOAK_Button, check_decrement2  
0948 C002      1011            push AR2
094A 7A32      1011            mov R2, #50
094C 1202D7    1011            lcall ?Wait_Milli_Seconds
094F D002      1011            pop AR2         
0951 20A158    1012               jb SETUP_SOAK_Button, check_decrement2  
0954           1013               loop_hold_inc:
0954           1014   
0954 30A10F    1015               jnb SETUP_SOAK_Button, jump2
0957 C002      1016            push AR2
0959 7A64      1016            mov R2, #100
095B 1202D7    1016            lcall ?Wait_Milli_Seconds
095E D002      1016            pop AR2
0960 30A103    1017               jnb SETUP_SOAK_Button, jump2
0963 0209AC    1018               ljmp hold_done
0966           1019               jump2:
0966 C0E0      1020            push acc
0968 7405      1020            mov a, #5
096A 14        1020            dec a
096B 120368    1020            lcall ?Set_Cursor_1 ; Select column and row
096E D0E0      1020            pop acc
0970 C000      1021            push ar0
0972 A84D      1021            mov r0, reflow_temp+0
0974 12036D    1021            lcall ?Display_BCD
0977 D000      1021            pop ar0
0979 C0E0      1022            push acc
097B 7407      1022            mov a, #7
097D 14        1022            dec a
097E 120368    1022            lcall ?Set_Cursor_1 ; Select column and row
0981 D0E0      1022            pop acc
0983 C000      1023            push ar0
0985 A84E      1023            mov r0, reflow_temp+1
0987 12036D    1023            lcall ?Display_BCD
098A D000      1023            pop ar0
098C C002      1024            push AR2
098E 7A64      1024            mov R2, #100
0990 1202D7    1024            lcall ?Wait_Milli_Seconds
0993 D002      1024            pop AR2         
0995 E54E      1025               mov a, reflow_temp+1
0997 2401      1026               add a, #0x01
0999 D4        1027               da a ; Decimal adjust instruction.  Check datasheet for more details!
099A F54E      1028               mov reflow_temp+1, a
099C E54E      1029               mov a, reflow_temp+1
099E 7009      1030               jnz INC_reflow_temp_done2
09A0 E54D      1031               mov a, reflow_temp+0
09A2 2401      1032               add a, #0x01
09A4 D4        1033               da a ; Decimal adjust instruction.  Check datasheet for more details!
09A5 F54D      1034               mov reflow_temp+0, a
09A7 E54E      1035               mov a, reflow_temp+1
09A9           1036               INC_reflow_temp_done2:
09A9           1037               
09A9 020954    1038               ljmp loop_hold_inc
09AC           1039           hold_done:
09AC           1040           
09AC           1041   
09AC           1042   
09AC           1043           check_decrement2:
09AC 20A664    1044               jb Button_min, DEC_reflow_temp_done2  
09AF C002      1045            push AR2
09B1 7A32      1045            mov R2, #50
09B3 1202D7    1045            lcall ?Wait_Milli_Seconds
09B6 D002      1045            pop AR2         
09B8 20A658    1046               jb Button_min, DEC_reflow_temp_done2  
09BB           1047               loop_hold_dec:
09BB           1048   
09BB 30A60F    1049               jnb Button_min, jump3
09BE C002      1050            push AR2
09C0 7A64      1050            mov R2, #100
09C2 1202D7    1050            lcall ?Wait_Milli_Seconds
09C5 D002      1050            pop AR2
09C7 30A603    1051               jnb Button_min, jump3
09CA 020A13    1052               ljmp DEC_reflow_temp_done2
09CD           1053               jump3:
09CD C0E0      1054            push acc
09CF 7405      1054            mov a, #5
09D1 14        1054            dec a
09D2 120368    1054            lcall ?Set_Cursor_1 ; Select column and row
09D5 D0E0      1054            pop acc
09D7 C000      1055            push ar0
09D9 A84D      1055            mov r0, reflow_temp+0
09DB 12036D    1055            lcall ?Display_BCD
09DE D000      1055            pop ar0
09E0 C0E0      1056            push acc
09E2 7407      1056            mov a, #7
09E4 14        1056            dec a
09E5 120368    1056            lcall ?Set_Cursor_1 ; Select column and row
09E8 D0E0      1056            pop acc
09EA C000      1057            push ar0
09EC A84E      1057            mov r0, reflow_temp+1
09EE 12036D    1057            lcall ?Display_BCD
09F1 D000      1057            pop ar0
09F3 C002      1058            push AR2
09F5 7A64      1058            mov R2, #100
09F7 1202D7    1058            lcall ?Wait_Milli_Seconds
09FA D002      1058            pop AR2         
09FC E54E      1059               mov a, reflow_temp+1
09FE 2499      1060               add a, #0x99
0A00 D4        1061               da a ; Decimal adjust instruction.  Check datasheet for more details!
0A01 F54E      1062               mov reflow_temp+1, a
0A03 E54E      1063               mov a, reflow_temp+1
0A05 7009      1064               jnz INC_reflow_temp_done
0A07 E54D      1065               mov a, reflow_temp+0
0A09 2499      1066               add a, #0x99
0A0B D4        1067               da a ; Decimal adjust instruction.  Check datasheet for more details!
0A0C F54D      1068               mov reflow_temp+0, a
0A0E E54E      1069               mov a, reflow_temp+1
0A10           1070               INC_reflow_temp_done:
0A10           1071               
0A10 0209BB    1072               ljmp loop_hold_dec
0A13           1073   
0A13           1074           DEC_reflow_temp_done2:
0A13           1075       
0A13           1076   
0A13 22        1077       ret
0A14           1078   setup_soak_page:
0A14 20A011    1079            jb set_BUTTON, continue11
0A17 C002      1079            push AR2
0A19 7A0A      1079            mov R2, #10
0A1B 1202D7    1079            lcall ?Wait_Milli_Seconds
0A1E D002      1079            pop AR2
0A20 20A005    1079            jb set_BUTTON, continue11
0A23 30A0FD    1079            jnb set_BUTTON, $
0A26           1079   
0A26 B20A      1080       cpl tt_flag_soak
0A28           1081       continue11:
0A28           1082   
0A28 200A06    1083       jb tt_flag_soak, jump4
0A2B 120B0D    1084       lcall INC_DEC_soak_time
0A2E 020A34    1085       ljmp display_soak_page
0A31           1086       jump4:
0A31 120B55    1087       lcall INC_DEC_soak_temp
0A34           1088   
0A34           1089   
0A34           1090       display_soak_page:
0A34 C0E0      1091            push acc
0A36 7405      1091            mov a, #5
0A38 14        1091            dec a
0A39 120368    1091            lcall ?Set_Cursor_1 ; Select column and row
0A3C D0E0      1091            pop acc
0A3E C000      1092            push ar0
0A40 A84F      1092            mov r0, soak_temp+0
0A42 12036D    1092            lcall ?Display_BCD
0A45 D000      1092            pop ar0
0A47 C0E0      1093            push acc
0A49 7407      1093            mov a, #7
0A4B 14        1093            dec a
0A4C 120368    1093            lcall ?Set_Cursor_1 ; Select column and row
0A4F D0E0      1093            pop acc
0A51 C000      1094            push ar0
0A53 A850      1094            mov r0, soak_temp+1
0A55 12036D    1094            lcall ?Display_BCD
0A58 D000      1094            pop ar0
0A5A           1095          
0A5A           1096       
0A5A C0E0      1097            push acc
0A5C 7401      1097            mov a, #1
0A5E 14        1097            dec a
0A5F 120368    1097            lcall ?Set_Cursor_1 ; Select column and row
0A62 D0E0      1097            pop acc
0A64 C083      1098            push dph
0A66 C082      1098            push dpl
0A68 C0E0      1098            push acc
0A6A 900436    1098            mov dptr, #soak_setup0
0A6D 12035B    1098            lcall ?Send_Constant_String
0A70 D0E0      1098            pop acc
0A72 D082      1098            pop dpl
0A74 D083      1098            pop dph
0A76 C0E0      1099            push acc
0A78 7409      1099            mov a, #9
0A7A 14        1099            dec a
0A7B 120368    1099            lcall ?Set_Cursor_1 ; Select column and row
0A7E D0E0      1099            pop acc
0A80           1099   
0A80 C083      1100            push dph
0A82 C082      1100            push dpl
0A84 C0E0      1100            push acc
0A86 90043B    1100            mov dptr, #soak_setup1
0A89 12035B    1100            lcall ?Send_Constant_String
0A8C D0E0      1100            pop acc
0A8E D082      1100            pop dpl
0A90 D083      1100            pop dph
0A92           1101   
0A92 C0E0      1102            push acc
0A94 7401      1102            mov a, #1
0A96 14        1102            dec a
0A97 120366    1102            lcall ?Set_Cursor_2 ; Select column and row
0A9A D0E0      1102            pop acc
0A9C           1102   
0A9C C083      1103            push dph
0A9E C082      1103            push dpl
0AA0 C0E0      1103            push acc
0AA2 900443    1103            mov dptr, #soak_setup2
0AA5 12035B    1103            lcall ?Send_Constant_String
0AA8 D0E0      1103            pop acc
0AAA D082      1103            pop dpl
0AAC D083      1103            pop dph
0AAE C0E0      1104            push acc
0AB0 7408      1104            mov a, #8
0AB2 14        1104            dec a
0AB3 120366    1104            lcall ?Set_Cursor_2 ; Select column and row
0AB6 D0E0      1104            pop acc
0AB8           1104   
0AB8 C083      1105            push dph
0ABA C082      1105            push dpl
0ABC C0E0      1105            push acc
0ABE 9003D8    1105            mov dptr, #dots
0AC1 12035B    1105            lcall ?Send_Constant_String
0AC4 D0E0      1105            pop acc
0AC6 D082      1105            pop dpl
0AC8 D083      1105            pop dph
0ACA C0E0      1106            push acc
0ACC 740C      1106            mov a, #12
0ACE 14        1106            dec a
0ACF 120366    1106            lcall ?Set_Cursor_2 ; Select column and row
0AD2 D0E0      1106            pop acc
0AD4 C083      1107            push dph
0AD6 C082      1107            push dpl
0AD8 C0E0      1107            push acc
0ADA 900448    1107            mov dptr, #soak_setup3
0ADD 12035B    1107            lcall ?Send_Constant_String
0AE0 D0E0      1107            pop acc
0AE2 D082      1107            pop dpl
0AE4 D083      1107            pop dph
0AE6 C0E0      1108            push acc
0AE8 7409      1108            mov a, #9
0AEA 14        1108            dec a
0AEB 120366    1108            lcall ?Set_Cursor_2 ; Select column and row
0AEE D0E0      1108            pop acc
0AF0           1108   
0AF0 C000      1109            push ar0
0AF2 A856      1109            mov r0, soak_sec
0AF4 12036D    1109            lcall ?Display_BCD
0AF7 D000      1109            pop ar0
0AF9 C0E0      1110            push acc
0AFB 7406      1110            mov a, #6
0AFD 14        1110            dec a
0AFE 120366    1110            lcall ?Set_Cursor_2 ; Select column and row
0B01 D0E0      1110            pop acc
0B03 C000      1111            push ar0
0B05 A857      1111            mov r0, soak_min
0B07 12036D    1111            lcall ?Display_BCD
0B0A D000      1111            pop ar0
0B0C 22        1112   ret
0B0D           1113       INC_DEC_soak_time:
0B0D           1114       
0B0D 20A124    1115            jb SETUP_SOAK_Button, check_decrement_soak
0B10 C002      1115            push AR2
0B12 7A0A      1115            mov R2, #10
0B14 1202D7    1115            lcall ?Wait_Milli_Seconds
0B17 D002      1115            pop AR2
0B19 20A118    1115            jb SETUP_SOAK_Button, check_decrement_soak
0B1C 30A1FD    1115            jnb SETUP_SOAK_Button, $
0B1F           1115    ; setup soak is also used to increment 
0B1F           1116   
0B1F E556      1117           mov a, soak_sec
0B21 B4590B    1118           cjne a, #0x59, add_soak_sec
0B24 E557      1119           mov a, soak_min
0B26 2401      1120           add a, #0x01
0B28 D4        1121           da a
0B29 F557      1122           mov soak_min, a
0B2B E4        1123           clr a 
0B2C 020B32    1124           ljmp Continue12
0B2F           1125           add_soak_sec:
0B2F 2401      1126           add a, #0x01
0B31 D4        1127           da a ; Decimal adjust instruction.  Check datasheet for more details!
0B32           1128           Continue12:
0B32 F556      1129           mov soak_sec, a
0B34           1130   
0B34           1131           check_decrement_soak:
0B34 20A61D    1132            jb Button_min, continue13
0B37 C002      1132            push AR2
0B39 7A0A      1132            mov R2, #10
0B3B 1202D7    1132            lcall ?Wait_Milli_Seconds
0B3E D002      1132            pop AR2
0B40 20A611    1132            jb Button_min, continue13
0B43 30A6FD    1132            jnb Button_min, $
0B46           1132   
0B46 E556      1133           mov a, soak_sec
0B48 B40004    1134           cjne a, #0x00, sub_soak_sec
0B4B E4        1135           clr a 
0B4C 020B52    1136           ljmp Continue14
0B4F           1137           sub_soak_sec:
0B4F 2499      1138           add a, #0x99 ; add 99 reduces 1
0B51 D4        1139           da a ; Decimal adjust instruction.  Check datasheet for more details!
0B52           1140           Continue14:
0B52 F556      1141           mov soak_sec, a
0B54           1142           continue13:
0B54           1143           
0B54 22        1144           ret
0B55           1145       INC_DEC_soak_temp:
0B55           1146           
0B55 20A164    1147               jb SETUP_SOAK_Button, check_decrement2_soak  
0B58 C002      1148            push AR2
0B5A 7A32      1148            mov R2, #50
0B5C 1202D7    1148            lcall ?Wait_Milli_Seconds
0B5F D002      1148            pop AR2         
0B61 20A158    1149               jb SETUP_SOAK_Button, check_decrement2_soak  
0B64           1150               loop_hold_inc_soak:
0B64           1151   
0B64 30A10F    1152               jnb SETUP_SOAK_Button, jump6
0B67 C002      1153            push AR2
0B69 7A64      1153            mov R2, #100
0B6B 1202D7    1153            lcall ?Wait_Milli_Seconds
0B6E D002      1153            pop AR2
0B70 30A103    1154               jnb SETUP_SOAK_Button, jump6
0B73 020BBC    1155               ljmp hold_done_soak
0B76           1156               jump6:
0B76 C0E0      1157            push acc
0B78 7405      1157            mov a, #5
0B7A 14        1157            dec a
0B7B 120368    1157            lcall ?Set_Cursor_1 ; Select column and row
0B7E D0E0      1157            pop acc
0B80 C000      1158            push ar0
0B82 A84F      1158            mov r0, soak_temp+0
0B84 12036D    1158            lcall ?Display_BCD
0B87 D000      1158            pop ar0
0B89 C0E0      1159            push acc
0B8B 7407      1159            mov a, #7
0B8D 14        1159            dec a
0B8E 120368    1159            lcall ?Set_Cursor_1 ; Select column and row
0B91 D0E0      1159            pop acc
0B93 C000      1160            push ar0
0B95 A850      1160            mov r0, soak_temp+1
0B97 12036D    1160            lcall ?Display_BCD
0B9A D000      1160            pop ar0
0B9C C002      1161            push AR2
0B9E 7AC8      1161            mov R2, #200
0BA0 1202D7    1161            lcall ?Wait_Milli_Seconds
0BA3 D002      1161            pop AR2         
0BA5 E550      1162               mov a, soak_temp+1
0BA7 2401      1163               add a, #0x01
0BA9 D4        1164               da a ; Decimal adjust instruction.  Check datasheet for more details!
0BAA F550      1165               mov soak_temp+1, a
0BAC E550      1166               mov a, soak_temp+1
0BAE 7009      1167               jnz INC_soak_temp_done2
0BB0 E54F      1168               mov a, soak_temp+0
0BB2 2401      1169               add a, #0x01
0BB4 D4        1170               da a ; Decimal adjust instruction.  Check datasheet for more details!
0BB5 F54F      1171               mov soak_temp+0, a
0BB7 E550      1172               mov a, soak_temp+1
0BB9           1173               INC_soak_temp_done2:
0BB9           1174               
0BB9 020B64    1175               ljmp loop_hold_inc_soak
0BBC           1176           hold_done_soak:
0BBC           1177           
0BBC           1178   
0BBC           1179   
0BBC           1180           check_decrement2_soak:
0BBC 20A664    1181               jb Button_min, DEC_soak_temp_done2  
0BBF C002      1182            push AR2
0BC1 7A32      1182            mov R2, #50
0BC3 1202D7    1182            lcall ?Wait_Milli_Seconds
0BC6 D002      1182            pop AR2         
0BC8 20A658    1183               jb Button_min, DEC_soak_temp_done2  
0BCB           1184               loop_hold_dec_soak:
0BCB           1185   
0BCB 30A60F    1186               jnb Button_min, jump7
0BCE C002      1187            push AR2
0BD0 7A64      1187            mov R2, #100
0BD2 1202D7    1187            lcall ?Wait_Milli_Seconds
0BD5 D002      1187            pop AR2
0BD7 30A603    1188               jnb Button_min, jump7
0BDA 020C23    1189               ljmp DEC_soak_temp_done2
0BDD           1190               jump7:
0BDD C0E0      1191            push acc
0BDF 7405      1191            mov a, #5
0BE1 14        1191            dec a
0BE2 120368    1191            lcall ?Set_Cursor_1 ; Select column and row
0BE5 D0E0      1191            pop acc
0BE7 C000      1192            push ar0
0BE9 A84F      1192            mov r0, soak_temp+0
0BEB 12036D    1192            lcall ?Display_BCD
0BEE D000      1192            pop ar0
0BF0 C0E0      1193            push acc
0BF2 7407      1193            mov a, #7
0BF4 14        1193            dec a
0BF5 120368    1193            lcall ?Set_Cursor_1 ; Select column and row
0BF8 D0E0      1193            pop acc
0BFA C000      1194            push ar0
0BFC A850      1194            mov r0, soak_temp+1
0BFE 12036D    1194            lcall ?Display_BCD
0C01 D000      1194            pop ar0
0C03 C002      1195            push AR2
0C05 7A64      1195            mov R2, #100
0C07 1202D7    1195            lcall ?Wait_Milli_Seconds
0C0A D002      1195            pop AR2         
0C0C E550      1196               mov a, soak_temp+1
0C0E 2499      1197               add a, #0x99
0C10 D4        1198               da a ; Decimal adjust instruction.  Check datasheet for more details!
0C11 F550      1199               mov soak_temp+1, a
0C13 E550      1200               mov a, soak_temp+1
0C15 7009      1201               jnz INC_soak_temp_done
0C17 E54F      1202               mov a, soak_temp+0
0C19 2499      1203               add a, #0x99
0C1B D4        1204               da a ; Decimal adjust instruction.  Check datasheet for more details!
0C1C F54F      1205               mov soak_temp+0, a
0C1E E550      1206               mov a, soak_temp+1
0C20           1207               INC_soak_temp_done:
0C20           1208               
0C20 020BCB    1209               ljmp loop_hold_dec_soak
0C23           1210   
0C23           1211           DEC_soak_temp_done2:
0C23 22        1212           ret
0C24           1213   second_page:
0C24 C0E0      1214            push acc
0C26 7401      1214            mov a, #1
0C28 14        1214            dec a
0C29 120368    1214            lcall ?Set_Cursor_1 ; Select column and row
0C2C D0E0      1214            pop acc
0C2E C083      1215            push dph
0C30 C082      1215            push dpl
0C32 C0E0      1215            push acc
0C34 90040D    1215            mov dptr, #soak_reflw
0C37 12035B    1215            lcall ?Send_Constant_String
0C3A D0E0      1215            pop acc
0C3C D082      1215            pop dpl
0C3E D083      1215            pop dph
0C40 C0E0      1216            push acc
0C42 7401      1216            mov a, #1
0C44 14        1216            dec a
0C45 120366    1216            lcall ?Set_Cursor_2 ; Select column and row
0C48 D0E0      1216            pop acc
0C4A C083      1217            push dph
0C4C C082      1217            push dpl
0C4E C0E0      1217            push acc
0C50 9003A5    1217            mov dptr, #nothing
0C53 12035B    1217            lcall ?Send_Constant_String
0C56 D0E0      1217            pop acc
0C58 D082      1217            pop dpl
0C5A D083      1217            pop dph
0C5C 22        1218       ret
0C5D           1219   
0C5D           1220   FSM_LCD:
0C5D E546      1221           mov a, state_lcd
0C5F           1222   
0C5F           1223   
0C5F           1224           ;----------------STATE 0------------------;
0C5F           1225            home_state:
0C5F B4001E    1226               cjne a, #0, soak_reflow_state
0C62 20A015    1227            jb set_BUTTON, done_home2
0C65 C002      1227            push AR2
0C67 7A0A      1227            mov R2, #10
0C69 1202D7    1227            lcall ?Wait_Milli_Seconds
0C6C D002      1227            pop AR2
0C6E 20A009    1227            jb set_BUTTON, done_home2
0C71 30A0FD    1227            jnb set_BUTTON, $
0C74           1227    
0C74           1228               ;setb set_flag  
0C74 754601    1229               mov state_lcd, #1
0C77 020C7D    1230               ljmp done_home
0C7A           1231               done_home2:
0C7A           1232               ;clr set_flag
0C7A 1207F4    1233               lcall home_page
0C7D           1234               done_home:
0C7D 020CF2    1235               ljmp Forever_done           
0C80           1236           ;------------------------------------------;
0C80           1237           
0C80           1238        ;   ;----------------STATE 1-------------------;
0C80           1239           soak_reflow_state:
0C80 B4014B    1240               cjne a, #1, setup_soak
0C83 120C24    1241               lcall second_page
0C86           1242             ;  Wait_Milli_Seconds(#50)
0C86 1207D3    1243               lcall sec_counter ; prevent the timer to go over 60
0C89 1207E3    1244               lcall min_counter
0C8C 20A712    1245            jb HOME_BUTTON, next_pushb
0C8F C002      1245            push AR2
0C91 7A0A      1245            mov R2, #10
0C93 1202D7    1245            lcall ?Wait_Milli_Seconds
0C96 D002      1245            pop AR2
0C98 20A706    1245            jb HOME_BUTTON, next_pushb
0C9B 30A7FD    1245            jnb HOME_BUTTON, $
0C9E           1245    ; check if home button is pressed 
0C9E 754600    1246               mov state_lcd, #0
0CA1           1247               next_pushb:
0CA1 20A112    1248            jb SETUP_SOAK_Button, next_pushb2
0CA4 C002      1248            push AR2
0CA6 7A0A      1248            mov R2, #10
0CA8 1202D7    1248            lcall ?Wait_Milli_Seconds
0CAB D002      1248            pop AR2
0CAD 20A106    1248            jb SETUP_SOAK_Button, next_pushb2
0CB0 30A1FD    1248            jnb SETUP_SOAK_Button, $
0CB3           1248    ; check if the the button to setup soak is pressed
0CB3 754602    1249               mov state_lcd, #2
0CB6           1250               next_pushb2:
0CB6 20A612    1251            jb Button_min, done_soak
0CB9 C002      1251            push AR2
0CBB 7A0A      1251            mov R2, #10
0CBD 1202D7    1251            lcall ?Wait_Milli_Seconds
0CC0 D002      1251            pop AR2
0CC2 20A606    1251            jb Button_min, done_soak
0CC5 30A6FD    1251            jnb Button_min, $
0CC8           1251    ; check if the buttion to setup the reflow was pressed 
0CC8 754603    1252               mov state_lcd, #3
0CCB           1253               done_soak:
0CCB 020CF2    1254              ljmp Forever_done 
0CCE           1255           ;------------------------------------------;
0CCE           1256   ;
0CCE           1257        ;   ;-----------------STATE 2------------------;
0CCE           1258           setup_soak: ; its actually set up reflow Im dumb
0CCE B40221    1259               cjne a, #2, setup_reflow
0CD1 120804    1260               lcall setup_reflow_page
0CD4           1261             ;  Wait_Milli_Seconds(#50)
0CD4 1207D3    1262               lcall sec_counter ; prevent the timer to go over 60
0CD7 1207E3    1263               lcall min_counter
0CDA 20A712    1264            jb HOME_BUTTON, done_setup_soak
0CDD C002      1264            push AR2
0CDF 7A0A      1264            mov R2, #10
0CE1 1202D7    1264            lcall ?Wait_Milli_Seconds
0CE4 D002      1264            pop AR2
0CE6 20A706    1264            jb HOME_BUTTON, done_setup_soak
0CE9 30A7FD    1264            jnb HOME_BUTTON, $
0CEC           1264    ; check if home button is pressed 
0CEC 754600    1265               mov state_lcd, #0
0CEF           1266               done_setup_soak:
0CEF 020CF2    1267               ljmp Forever_done 
0CF2           1268           ;------------------------------------------;
0CF2           1269   ;
0CF2           1270        ;   ;----------------STATE 3-------------------;
0CF2           1271           setup_reflow: ; its actually set up soak Im dumb
0CF2           1272        ;       cjne a, #3, FDP
0CF2           1273        ;       ljmp FDP2
0CF2           1274        ;       FDP:
0CF2           1275        ;       ljmp home_state
0CF2           1276        ;       FDP2:
0CF2           1277        ;       lcall setup_soak_page
0CF2           1278        ;       lcall sec_counter ; prevent the timer to go over 60
0CF2           1279        ;       lcall min_counter
0CF2           1280        ;       PushButton(HOME_BUTTON,done_setup_reflow) ; check if home button is pressed 
0CF2           1281        ;       mov state_lcd, #0
0CF2           1282        ;       done_setup_reflow:
0CF2           1283        ;       ljmp Forever_done 
0CF2           1284        ;   ;------------------------------------------;
0CF2           1285           Forever_done:
0CF2 22        1286   ret
0CF3           1287   
0CF3           1288   ;------------------------------
0CF3           1289   ;---------------------------------;
0CF3           1290   ; Main program. Includes hardware ;
0CF3           1291   ; initialization and 'forever'    ;
0CF3           1292   ; loop.                           ;
0CF3           1293   ;---------------------------------;
0CF3           1294   main:
0CF3           1295            ; Initialization
0CF3 75817F    1296       mov SP, #0x7F
0CF6 12044D    1297       lcall Timer0_Init
0CF9 120467    1298       lcall Timer1_Init
0CFC           1299   
0CFC 120520    1300       lcall Ports_Init ; Default all pins as bidirectional I/O. See Table 42.
0CFF 120326    1301       lcall LCD_4BIT
0D02 120549    1302       lcall Double_Clk
0D05 120539    1303            lcall InitDAC1 ; Call after 'Ports_Init'
0D08 1204D2    1304            lcall CCU_Init
0D0B 120551    1305            lcall Init_SPI
0D0E           1306            
0D0E           1307            
0D0E D2AF      1308            setb EA ; Enable global interrupts.
0D10           1309   
0D10           1310            ; Initialize variables
0D10 C200      1311            clr T2S_FSM_Start
0D12 755E00    1312            mov T2S_FSM_state, #0
0D15           1313       ; Configure all the ports in bidirectional mode:
0D15           1314   
0D15 758400    1315       mov P0M1, #00H
0D18 758500    1316       mov P0M2, #00H
0D1B 759100    1317       mov P1M1, #00H
0D1E 759200    1318       mov P1M2, #00H ; WARNING: P1.2 and P1.3 need 1kohm pull-up resistors!
0D21 75A400    1319       mov P2M1, #00H
0D24 75A500    1320       mov P2M2, #00H
0D27 75B100    1321       mov P3M1, #00H
0D2A 75B200    1322       mov P3M2, #00H
0D2D           1323       
0D2D 755C00    1324       mov minutes, #0
0D30 755D00    1325            mov seconds, #0
0D33           1326   
0D33           1327      ; lcall LCD_4BIT
0D33           1328       ; For convenience a few handy macros are included in 'LCD_4bit_LPC9351.inc':
0D33 C0E0      1329            push acc
0D35 7401      1329            mov a, #1
0D37 14        1329            dec a
0D38 120368    1329            lcall ?Set_Cursor_1 ; Select column and row
0D3B D0E0      1329            pop acc
0D3D C000      1330            push ar0
0D3F A852      1330            mov r0, BCD_counter
0D41 12036D    1330            lcall ?Display_BCD
0D44 D000      1330            pop ar0
0D46           1331   
0D46 D203      1332       setb half_seconds_flag
0D48 E4        1333       clr a
0D49 F54B      1334       mov Count1ms+0, a
0D4B F54C      1335       mov Count1ms+1, a    
0D4D           1336   
0D4D 755200    1337            mov BCD_counter, #0x00
0D50 754A00    1338            mov pwm , #0
0D53 754800    1339            mov sec , #0
0D56 754500    1340            mov state, #0
0D59 754796    1341            mov temp, #150
0D5C 754205    1342       mov time_soak, #5
0D5F 7543DC    1343       mov temp_refl, #220
0D62 754105    1344       mov temp_soak, #5
0D65 756000    1345       mov five_sec_flag,#0
0D68           1346            ; After initialization the program stays in this 'forever' loop
0D68           1347   
0D68 755400    1348       mov reflow_sec, #0x00
0D6B 755500    1349       mov reflow_min, #0x00
0D6E 755C00    1350       mov minutes, #0x00
0D71 754600    1351       mov state_lcd, #0
0D74 C208      1352       clr TR1_flag
0D76 754D01    1353       mov reflow_temp+0, #0x01
0D79 754E50    1354       mov reflow_temp+1, #0x50
0D7C C209      1355       clr tt_reflow_flag
0D7E 755600    1356       mov soak_sec, #0x00
0D81 755700    1357       mov soak_min, #0x00
0D84           1358   
0D84 754F01    1359       mov soak_temp+0, #0x01
0D87 755050    1360       mov soak_temp+1, #0x50
0D8A           1361   
0D8A           1362       
0D8A           1363   forever:         
0D8A 120C5D    1364       lcall FSM_LCD
0D8D           1365   
0D8D 120681    1366       lcall T2S_FSM
0D90           1367            ; One second has passed, refresh the LCD with new time
0D90           1368   ;        Set_Cursor(1, 1)
0D90           1369   ;    Send_Constant_String(#timee)
0D90           1370   ;    Set_Cursor(1, 5)
0D90           1371   ;    Display_BCD(sec)
0D90           1372   ;    Set_Cursor(2, 1)
0D90           1373   ;    Send_Constant_String(#statee)
0D90           1374   ;    Set_Cursor(2, 5)
0D90           1375   ;    Display_BCD(BCD_counter)
0D90           1376   
0D90           1377   
0D90 E560      1378       mov a, five_sec_flag
0D92 B4050A    1379       cjne a,#5, pass_quack
0D95           1380       quack_like_a_duck:
0D95 C28E      1381       clr TR1 ; Stop timer 1.
0D97 7400      1382       mov a,#0
0D99 F560      1383       mov five_sec_flag,a
0D9B C28E      1384       clr TR1 ; Stop timer 1.
0D9D D200      1385            setb T2S_FSM_Start ; This plays the current minutes:seconds by making the state machine get out of state zero.
0D9F           1386       pass_hash:
0D9F           1387       pass_quack:
0D9F D28E      1388       setb TR1 ; en timer 1.
0DA1           1389       
0DA1 E545      1390       mov a, state
0DA3           1391     state0: 
0DA3 B4000F    1392         cjne a, #0, state1
0DA6 754A00    1393         mov pwm, #0
0DA9 20B006    1394         jb p3.0, state0_done
0DAC 30B0FD    1395         jnb p3.0, $ ;wait for key release
0DAF 754501    1396         mov state, #1
0DB2           1397     state0_done:
0DB2 020D8A    1398         ljmp forever
0DB5           1399      
0DB5           1400      state1:
0DB5 B40113    1401         cjne a, #1 , state2
0DB8 754A64    1402         mov pwm, #100
0DBB 754800    1403         mov sec, #0
0DBE E541      1404         mov a, temp_soak
0DC0 C3        1405         clr c
0DC1 9547      1406         subb a, temp
0DC3           1407         ;add branches to compare temp with 150
0DC3 5003      1408         jnc state1_done
0DC5 754502    1409         mov state, #2
0DC8           1410     state1_done:
0DC8 020D8A    1411          ljmp forever
0DCB           1412          
0DCB           1413     state2: ;press p3.0 multiple time plz cos it is stuck
0DCB B40210    1414         cjne a, #2 , state3
0DCE 754A14    1415         mov pwm, #20
0DD1 E542      1416         mov a, time_soak
0DD3 C3        1417         clr c
0DD4 9548      1418         subb a, sec
0DD6           1419         ;add branches to compare sec with  60
0DD6 5003      1420         jnc state2_done
0DD8 754503    1421         mov state, #3
0DDB           1422     state2_done:
0DDB 020D8A    1423          ljmp forever          
0DDE           1424     
0DDE           1425     state3:
0DDE B40313    1426         cjne a, #3 , state4
0DE1 754A50    1427         mov pwm, #80
0DE4 754800    1428         mov sec, #0     
0DE7 E543      1429         mov a, temp_refl
0DE9 C3        1430         clr c
0DEA 9547      1431         subb a, temp
0DEC           1432         ;add branches to compare temp with 220
0DEC 5003      1433         jnc state3_done
0DEE 754504    1434         mov state, #4
0DF1           1435     state3_done:
0DF1 020D8A    1436          ljmp forever
0DF4           1437          
0DF4           1438      state4:
0DF4 B40410    1439         cjne a, #4 , state5
0DF7 754A14    1440         mov pwm, #20
0DFA E544      1441         mov a, time_refl
0DFC C3        1442         clr c
0DFD 9548      1443         subb a, sec
0DFF           1444         ;add branches to compare sec with 45
0DFF 5003      1445         jnc state4_done
0E01 754505    1446         mov state, #5
0E04           1447     state4_done:
0E04 020D8A    1448          ljmp forever    
0E07           1449          
0E07           1450      state5:
0E07 B40599    1451         cjne a, #5 , state0
0E0A 754A00    1452         mov pwm, #0
0E0D C3        1453         clr c
0E0E 9547      1454         subb a, temp
0E10           1455         ;add branches to compare temp with 60
0E10 5003      1456         jnc state5_done
0E12 754500    1457         mov state, #0
0E15           1458     state5_done:
0E15 020D8A    1459          ljmp forever 
0E18           1460          
0E18           1461   
0E18           1462   EN
