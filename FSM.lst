0000              1   ; ISR_example.asm: a) Increments/decrements a BCD variable every half second using
0000              2   ; an ISR for timer 2; b) Generates a 2kHz square wave at pin P3.7 using
0000              3   ; an ISR for timer 0; and c) in the 'main' loop it displays the variable
0000              4   ; incremented/decremented using the ISR for timer 2 on the LCD.  Also resets it to 
0000              5   ; zero if the 'CLEAR' pushbutton connected to P1.7 is pressed.
0000              6   ; Start/Constants
                  8       $LIST
0000             10   
0000             11       CLK           EQU 7373000  ; Microcontroller system crystal frequency in Hz
0000             12       TIMER0_RATE   EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0000             13       TIMER0_RELOAD EQU ((65536-(CLK/(2*TIMER0_RATE))))
0000             14       TIMER1_RATE   EQU 100     ; 100Hz, for a timer tick of 10ms
0000             15       TIMER1_RELOAD EQU ((65536-(CLK/(2*TIMER1_RATE))))
0000             16   
0000             17   
0000             18   
0000             19       CCU_RATE    EQU 11025     ; 22050Hz is the sampling rate of the wav file we are playing
0000             20       CCU_RELOAD  EQU ((65536-((CLK/(2*CCU_RATE)))))
0000             21       BAUD        EQU 115200
0000             22       BRVAL       EQU ((CLK/BAUD)-16)
0000             23   
0000             24   
0000             25   
0000             26       ; Commands supported by the SPI flash memory according to the datasheet
0000             27       WRITE_ENABLE     EQU 0x06  ; Address:0 Dummy:0 Num:0
0000             28       WRITE_DISABLE    EQU 0x04  ; Address:0 Dummy:0 Num:0
0000             29       READ_STATUS      EQU 0x05  ; Address:0 Dummy:0 Num:1 to infinite
0000             30       READ_BYTES       EQU 0x03  ; Address:3 Dummy:0 Num:1 to infinite
0000             31       READ_SILICON_ID  EQU 0xab  ; Address:0 Dummy:3 Num:1 to infinite
0000             32       FAST_READ        EQU 0x0b  ; Address:3 Dummy:1 Num:1 to infinite
0000             33       WRITE_STATUS     EQU 0x01  ; Address:0 Dummy:0 Num:1
0000             34       WRITE_BYTES      EQU 0x02  ; Address:3 Dummy:0 Num:1 to 256
0000             35       ERASE_ALL        EQU 0xc7  ; Address:0 Dummy:0 Num:0
0000             36       ERASE_BLOCK      EQU 0xd8  ; Address:3 Dummy:0 Num:0
0000             37       READ_DEVICE_ID   EQU 0x9f  ; Address:0 Dummy:2 Num:1 to infinite
0000             38   ;Vectors
0000             39       ; Reset vector
0000             40       org 0x0000
0000 020C0A      41           ljmp main
0003             42   
0003             43       ; External interrupt 0 vector (not used in this code)
0003             44       org 0x0003
0003 32          45           reti
0004             46   
0004             47       ; Timer/Counter 0 overflow interrupt vector
000B             48       org 0x000B
000B 020460      49           ljmp Timer0_ISR
000E             50   
000E             51       ; External interrupt 1 vector (not used in this code)
0013             52       org 0x0013
0013 32          53           reti
0014             54   
0014             55       ; Timer/Counter 1 overflow interrupt vector
001B             56       org 0x001B
001B 02047A      57           ljmp Timer1_ISR
001E             58   
001E             59       ; Serial port receive/transmit interrupt vector (not used in this code)
0023             60       org 0x0023 
0023 32          61           reti
0024             62   
005B             63       org 0x005b ; CCU interrupt vector.  Used in this code to replay the wave file.
005B 0204E2      64           ljmp CCU_ISR
005E             65   
005E             66   
005E             67       ;                                                        -                     
005E             68       ;                                                       -  -                    
005E             69       ;                                                      -    -                   
005E             70       ;                              leave it at this temp>>-      -                  
005E             71       ;                                                    -        -                 
005E             72       ;                                                   -          -                 
005E             73       ;                                                  -            -               
005E             74       ;                                                 -              -              
005E             75       ;                                                -                -             
005E             76       ;                                               -                  -            
005E             77       ;                                              -                    -           
005E             78       ;                                             -    reflow>>cool     -          
005E             79       ;               -----------------------------    (temperature only)  -         
005E             80       ;              -     soak (time+temp)                                 -        
005E             81       ;             -                                                        -       
005E             82       ;            -                                                          -       
005E             83       ;          -                                                             -      
005E             84       ;         -                                                               -     
005E             85       ;        -                                                                 -    
005E             86       ;      -                                                                    -    
005E             87       ;     - ramp to soak (temperature)                                           -   
005E             88       ;   -                                                                         -   
005E             89       ;   state 1 ((temp==soak)? ssr_off: ssr_on)
005E             90       ;          state 2 ((time=soak_time)?(pwm_off):(pwn_on)
005E             91       ;                                           state 3 ((temp==soak)? ssr_off: ssr_on)
005E             92       ;                                                        state 4 (cooling ssr_off)
005E             93       ;                                                                             state 5 (done)
005E             94   
005E             95       ; In the 8051 we can define direct access variables starting at location 0x30 up to location 0x7F
005E             96   ;Variables(dseg) 
0030             97       dseg at 0x30
0030             98   
0030             99       Result:    ds 4
0034            100       x:         ds 4
0038            101       y:         ds 4
003C            102       bcd:       ds 5
0041            103       ;FSM varialbles
0041            104       temp_soak: ds 1 ; temp to soak
0042            105       time_soak: ds 1 ; time to soak
0043            106       temp_refl: ds 1 ; temp of relfow
0044            107       time_refl: ds 1 ; time to reflow 
0045            108       state: ds 1 ; current state 
0046            109       state_lcd: ds 1
0047            110       temp: ds 1 ; current temp in degree C
0048            111       sec: ds 1 ; current time in seconds 
0049            112       product: ds 1; pwm-currsec
004A            113       pwm: ds 1 ; 
004B            114   
004B            115       ;Timer variables
004B            116       Count1ms:     ds 2 ; Used to determine when half second has passed
004D            117       reflow_temp:  ds 2
004F            118       soak_temp:    ds 2
0051            119       reflow_temp_var: ds 1
0052            120       BCD_counter:  ds 1 ; The BCD counter incrememted in the ISR and displayed in the main loop
0053            121       hour:         ds 1
0054            122       reflow_sec:   ds 1
0055            123       reflow_min:   ds 1
0056            124       soak_sec:     ds 1
0057            125       soak_min:     ds 1
0058            126       Count10ms:    ds 1 ; Used to determine when half second has passed
0059            127       w:             ds 3 ; 24-bit play counter.  Decremented in CCU ISR.
005C            128       minutes:       ds 1
005D            129       seconds:       ds 1
005E            130       T2S_FSM_state: ds 1
005F            131       Count5ms:      ds 1
0060            132       five_sec_flag:  ds 1
0061            133   
0061            134   ;flags(bseg)
0000            135       BSEG
0000            136       T2S_FSM_start:     dbit 1
0001            137       seconds_flag:      dbit 1
0002            138       mf:                dbit 1
0003            139       half_seconds_flag: dbit 1 ; Set to one in the ISR every time 500 ms had passed
0004            140       AMPM_flag:         dbit 1
0005            141       alarm_AMPM_flag:   dbit 1
0006            142       on_off_flag:       dbit 1 ; 1 is on
0007            143       alarm_buzzer_flag: dbit 1
0008            144       TR1_flag:          dbit 1
0009            145       tt_reflow_flag:    dbit 1
000A            146       tt_flag_soak:      dbit 1
000B            147       stop_flag:         dbit 1
000C            148   
000C            149       ;_ _ _ _ | _ _ _ _ _ _
000C            150       ;
000C            151       ;pwm = 40 (say)
000C            152       ;then output will be 100 
000C            153       ;_________
000C            154       ;         |
000C            155       ;         |_____________
000C            156       ; where period is 1 second 
000C            157       ; In the 8051 we have variables that are 1-bit in size.  We can use the setb, clr, jb, and jnb
000C            158       ; instructions with these variables.  This is how you define a 1-bit variable:
000C            159   
000C            160   ;Pin config(cseg)
000C            161   
005E            162       cseg
005E            163       ; These 'equ' must match the wiring between the microcontroller and the LCD!
005E            164       LCD_RS equ P0.5
005E            165       LCD_RW equ P0.6
005E            166       LCD_E  equ P0.7
005E            167       LCD_D4 equ P1.2
005E            168       LCD_D5 equ P1.3
005E            169       LCD_D6 equ P1.4
005E            170       LCD_D7 equ P1.6
005E            171   
005E            172       CLEAR         equ P3.0
005E            173    ;   SOUND_OUT     equ P2.7
005E            174    ;   UPDOWN        equ P2.4
005E            175   
005E            176       FLASH_CE    EQU P2.4
005E            177       SOUND       EQU P2.7
005E            178       
005E            179       SETUP_SOAK_Button equ  P2.1
005E            180       set_BUTTON        equ  P2.0
005E            181       Button_min    equ  P2.6
005E            182       HOME_BUTTON   equ  P2.7
005E            183   
005E            184   
005E            185    ;start         equ P0.7
005E            186   
005E            187   ;include files
                546   $LIST
                190   	    $LIST
0399            192   ;Strings
0399            193     ;                       1234567890123456
0399            194      ;General
0399 0D0A00     195       Newline:          db   '\r', '\n', 0
039C 20202020   196       Space:            db   '      ','\r', '\n', 0
     20200D0A
     00
03A5 20202020   197       nothing:          db '                ',0      
     20202020
     20202020
     20202020
     00
03B6 20202020   198       test2:            db '      Test2     ',0
     20205465
     73743220
     20202020
     00
03C7 20202020   199       hot:                           db '      HOT       ', 0
     2020484F
     54202020
     20202020
     00
03D8 3A00       200       dots:             db ':',0
03DA 4243445F   201       Initial_Message:  db 'BCD_counter: xx ', 0
     636F756E
     7465723A
     20787820
     00
03EB            202      ;Home page
03EB 54656D70   203       Temp0:            db 'Temp:xxxC       ', 0
     3A787878
     43202020
     20202020
     00
03FC 54696D65   204       Time:             db 'Time xx:xx SET  ', 0
     2078783A
     78782053
     45542020
     00
040D            205      ;Second Page
040D 2020534F   206       soak_reflw:       db '  SOAK  REFLOW  ', 0
     414B2020
     5245464C
     4F572020
     00
041E            207      ;Reflow Setup
041E 54656D70   208       reflow_setup:     db 'Temp',0
     00
0423 2A524546   209       reflow_setup4:    db '*REFLOW*',0
     4C4F572A
     00
042C 54696D65   210       reflow_setup2:    db 'Time',0
     00
0431 484F4D45   211       reflow_setup3:    db 'HOME',0
     00
0436            212      ;Soak Setup
0436 54656D70   213       soak_setup0:      db 'Temp',0
     00
043B 202A534F   214       soak_setup1:      db ' *SOAK*',0
     414B2A00
0443 54696D65   215       soak_setup2:      db 'Time',0
     00
0448 484F4D45   216       soak_setup3:      db 'HOME',0
     00
044D            217   
044D            218   ;------ISR-------;
044D            219       ;---------------------------------;
044D            220       ; Routine to initialize the ISR   ;
044D            221       ; for timer 0                     ;
044D            222       ;---------------------------------;
044D            223       Timer0_Init:
044D E589       224           mov a, TMOD
044F 54F0       225           anl a, #0xf0 ; Clear the bits for timer 0
0451 4401       226           orl a, #0x01 ; Configure timer 0 as 16-timer
0453 F589       227           mov TMOD, a
0455 758CFC     228           mov TH0, #high(TIMER0_RELOAD)
0458 758A7C     229           mov TL0, #low(TIMER0_RELOAD)
045B            230           ; Enable the timer and interrupts
045B D2A9       231           setb ET0  ; Enable timer 0 interrupt
045D D28C       232           setb TR0  ; Start timer 0
045F 22         233           ret
0460            234   
0460            235       ;---------------------------------;
0460            236       ; ISR for timer 0.  Set to execute;
0460            237       ; every 1/4096Hz to generate a    ;
0460            238       ; 2048 Hz square wave at pin P3.7 ;
0460            239       ;---------------------------------;
0460            240       Timer0_ISR:
0460 758CFC     241           mov TH0, #high(TIMER0_RELOAD)
0463 758A7C     242           mov TL0, #low(TIMER0_RELOAD)
0466            243       ;    cpl SOUND_OUT ; Connect speaker to this pin
0466 32         244           reti
0467            245   
0467            246       ;---------------------------------;
0467            247       ; Routine to initialize the ISR   ;
0467            248       ; for timer 1                     ;
0467            249       ;---------------------------------;
0467            250       Timer1_Init:
0467 E589       251           mov a, TMOD
0469 540F       252           anl a, #0x0f ; Clear the bits for timer 1
046B 4410       253           orl a, #0x10 ; Configure timer 1 as 16-timer
046D F589       254           mov TMOD, a
046F 758D6F     255           mov TH1, #high(TIMER1_RELOAD)
0472 758BFF     256           mov TL1, #low(TIMER1_RELOAD)
0475            257           ; Enable the timer and interrupts
0475 D2AB       258           setb ET1  ; Enable timer 1 interrupt
0477 D28E       259           setb TR1  ; Start timer 1
0479 22         260           ret
047A            261   
047A            262       ;---------------------------------;
047A            263       ; ISR for timer 1                 ;
047A            264       ;---------------------------------;
047A            265       Timer1_ISR:
047A 758D6F     266           mov TH1, #high(TIMER1_RELOAD)
047D 758BFF     267           mov TL1, #low(TIMER1_RELOAD)
0480 B2A6       268           cpl P2.6 ; To check the interrupt rate with oscilloscope. It must be precisely a 10 ms pulse.
0482            269           
0482            270           ; The two registers used in the ISR must be saved in the stack
0482 C0E0       271           push acc
0484 C0D0       272           push psw
0486            273           
0486            274           
0486            275           ; Increment the 8-bit 10-mili-second counter
0486 0558       276           inc Count10ms
0488            277           ; Increment the 16-bit one mili second counter
0488            278   
0488            279   
0488            280       Inc_Done:
0488 E558       281           mov a, Count10ms
048A 954A       282           subb a, pwm ; if pwm greater than a pwm is on else off
048C D4         283           da a
048D            284          ; mov a, product
048D 5005       285           jnc off_segment
048F D281       286           setb p0.1
0491 C3         287           clr c
0492 8005       288           sjmp pass
0494            289           off_segment:
0494 C281       290           clr p0.1
0496 C3         291           clr c
0497 8000       292           sjmp pass
0499            293   
0499            294           ; Check if 1 second has passed
0499            295           pass:
0499            296   
0499            297           ; Check if half second has passed
0499 E558       298           mov a, Count10ms
049B B4C821     299           cjne a, #200, Timer1_ISR_done ; Warning: this instruction changes the carry flag!
049E            300           ;----------------------------
049E 0548       301           inc sec ; one second has passed
04A0 E548       302           mov a,sec
04A2 D4         303           da a
04A3 F548       304           mov sec,a
04A5            305   
04A5 0560       306           inc five_sec_flag ; one second has passed
04A7 E560       307           mov a,five_sec_flag
04A9 D4         308           da a
04AA F560       309           mov five_sec_flag,a
04AC            310   
04AC E548       311           mov a,sec
04AE            312          ; mov minutes, #0
04AE            313   
04AE 85E05D     314           mov seconds, acc
04B1            315   
04B1            316           
04B1            317           ;----------------------------
04B1            318           ; 500 milliseconds have passed.  Set a flag so the main program knows
04B1 D203       319           setb half_seconds_flag ; Let the main program know half second had passed
04B3 B28C       320           cpl TR0 ; Enable/disable timer/counter 0. This line creates a beep-silence-beep-silence sound.
04B5            321           ; Reset to zero the 10-milli-seconds counter, it is a 8-bit variable
04B5 755800     322           mov Count10ms, #0x0
04B8            323      ;     mov Count1ms, #0x00
04B8            324           ; Increment the BCD counter
04B8 E552       325           mov a, BCD_counter
04BA            326       ;    jnb UPDOWN, Timer1_ISR_decrement
04BA 2401       327           add a, #0x01
04BC            328       ;    sjmp Timer1_ISR_da
04BC            329       ;Timer1_ISR_decrement:
04BC            330           ;add a, #0x99 ; Adding the 10-complement of -1 is like subtracting 1.
04BC            331       Timer1_ISR_da:
04BC D4         332           da a ; Decimal adjust instruction.  Check datasheet for more details!
04BD F552       333           mov BCD_counter, a
04BF            334           
04BF            335       Timer1_ISR_done:
04BF D0D0       336           pop psw
04C1 D0E0       337           pop acc
04C3 32         338           reti
04C4            339   
04C4            340   
04C4            341   
04C4 74696D65   342       timee:  db 'time', 0
     00
04C9 3100       343       statee:  db '1', 0
04CB            344   
04CB            345   
04CB            346       ;------------------------------
04CB            347       ;---------------------------------;
04CB            348       ; Routine to initialize the CCU.  ;
04CB            349       ; We are using the CCU timer in a ;
04CB            350       ; manner similar to the timer 2   ;
04CB            351       ; available in other 8051s        ;
04CB            352       ;---------------------------------;
04CB            353       CCU_Init:
04CB 75CDFE     354           mov TH2, #high(CCU_RELOAD)
04CE 75CCB2     355           mov TL2, #low(CCU_RELOAD)
04D1 75CFFE     356           mov TOR2H, #high(CCU_RELOAD)
04D4 75CEB2     357           mov TOR2L, #low(CCU_RELOAD)
04D7 75F980     358           mov TCR21, #10000000b ; Latch the reload value
04DA 75C980     359           mov TICR2, #10000000b ; Enable CCU Timer Overflow Interrupt
04DD D2EC       360           setb ECCU ; Enable CCU interrupt
04DF D2C8       361           setb TMOD20 ; Start CCU timer
04E1 22         362           ret
04E2            363   
04E2            364       ;---------------------------------;
04E2            365       ; ISR for CCU.  Used to playback  ;
04E2            366       ; the WAV file stored in the SPI  ;
04E2            367       ; flash memory.                   ;
04E2            368       ;---------------------------------;
04E2            369       CCU_ISR:
04E2 75E900     370           mov TIFR2, #0 ; Clear CCU Timer Overflow Interrupt Flag bit. Actually, it clears all the bits!
04E5            371           
04E5            372           ; The registers used in the ISR must be saved in the stack
04E5 C0E0       373           push acc
04E7 C0D0       374           push psw
04E9            375           
04E9            376           ; Check if the play counter is zero.  If so, stop playing sound.
04E9 E559       377           mov a, w+0
04EB 455A       378           orl a, w+1
04ED 455B       379           orl a, w+2
04EF 601D       380           jz stop_playing
04F1            381           
04F1            382           ;;yolo this is gonna fuck with the speaker
04F1            383           ; Increment the 16-bit one mili second counter
04F1 054B       384           inc Count1ms+0    ; Increment the low 8-bits first
04F3 E54B       385           mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
04F5 7091       386           jnz Inc_Done
04F7 054C       387           inc Count1ms+1
04F9            388           ; Decrement play counter 'w'.  In this implementation 'w' is a 24-bit counter.
04F9 74FF       389           mov a, #0xff
04FB 1559       390           dec w+0
04FD B55907     391           cjne a, w+0, keep_playing
0500 155A       392           dec w+1
0502 B55A02     393           cjne a, w+1, keep_playing
0505 155B       394           dec w+2
0507            395           
0507            396       keep_playing:
0507            397   
0507 12055A     398           lcall Send_SPI ; Read the next byte from the SPI Flash...
050A F5F5       399           mov AD1DAT3, a ; and send it to the DAC
050C            400           
050C 8006       401           sjmp CCU_ISR_Done
050E            402   
050E            403       stop_playing:
050E C2C8       404           clr TMOD20 ; Stop CCU timer
0510 D2A4       405           setb FLASH_CE  ; Disable SPI Flash
0512 C2A7       406           clr SOUND ; Turn speaker off
0514            407   
0514            408       CCU_ISR_Done:        
0514 D0D0       409           pop psw
0516 D0E0       410           pop acc
0518 32         411           reti
0519            412   ;----------------;
0519            413   
0519            414   ;---------------------------------;
0519            415   ; Initial configuration of ports. ;
0519            416   ; After reset the default for the ;
0519            417   ; pins is 'Open Drain'.  This     ;
0519            418   ; routine changes them pins to    ;
0519            419   ; Quasi-bidirectional like in the ;
0519            420   ; original 8051.                  ;
0519            421   ; Notice that P1.2 and P1.3 are   ;
0519            422   ; always 'Open Drain'. If those   ;
0519            423   ; pins are to be used as output   ;
0519            424   ; they need a pull-up resistor.   ;
0519            425   ;---------------------------------;
0519            426   Ports_Init:
0519            427       ; Configure all the ports in bidirectional mode:
0519 758400     428       mov P0M1, #00H
051C 758500     429       mov P0M2, #00H
051F 759100     430       mov P1M1, #00H
0522 759200     431       mov P1M2, #00H ; WARNING: P1.2 and P1.3 need 1 kohm pull-up resistors if used as outputs!
0525 75A400     432       mov P2M1, #00H
0528 75A500     433       mov P2M2, #00H
052B 75B100     434       mov P3M1, #00H
052E 75B200     435       mov P3M2, #00H
0531 22         436            ret
0532            437   
0532            438   ;---------------------------------;
0532            439   ; Initialize ADC1/DAC1 as DAC1.   ;
0532            440   ; Warning, the ADC1/DAC1 can work ;
0532            441   ; only as ADC or DAC, not both.   ;
0532            442   ; The P89LPC9351 has two ADC/DAC  ;
0532            443   ; interfaces.  One can be used as ;
0532            444   ; ADC and the other can be used   ;
0532            445   ; as DAC.  Also configures the    ;
0532            446   ; pin associated with the DAC, in ;
0532            447   ; this case P0.4 as 'Open Drain'. ;
0532            448   ;---------------------------------;
0532            449   InitDAC1:
0532            450       ; Configure pin P0.4 (DAC1 output pin) as open drain
0532 438410     451            orl     P0M1,   #00010000B
0535 438510     452            orl     P0M2,   #00010000B
0538 75A128     453       mov ADMODB, #00101000B ; Select main clock/2 for ADC/DAC.  Also enable DAC1 output (Table 25 of reference manual)
053B 759704     454            mov     ADCON1, #00000100B ; Enable the converter
053E 75F580     455            mov AD1DAT3, #0x80     ; Start value is 3.3V/2 (zero reference for AC WAV file)
0541 22         456            ret
0542            457   
0542            458   ;---------------------------------;
0542            459   ; Change the internal RC osc. clk ;
0542            460   ; from 7.373MHz to 14.746MHz.     ;
0542            461   ;---------------------------------;
0542            462   Double_Clk:
0542 90FFDE     463       mov dptr, #CLKCON
0545 E0         464       movx a, @dptr
0546 4408       465       orl a, #00001000B ; double the clock speed to 14.746MHz
0548 F0         466       movx @dptr,a
0549 22         467            ret
054A            468   
054A            469   ;---------------------------------;
054A            470   ; Initialize the SPI interface    ;
054A            471   ; and the pins associated to SPI. ;
054A            472   ;---------------------------------;
054A            473   Init_SPI:
054A            474            ; Configure MOSI (P2.2), CS* (P2.4), and SPICLK (P2.5) as push-pull outputs (see table 42, page 51)
054A 53A4CB     475            anl P2M1, #low(not(00110100B))
054D 43A534     476            orl P2M2, #00110100B
0550            477            ; Configure MISO (P2.3) as input (see table 42, page 51)
0550 43A408     478            orl P2M1, #00001000B
0553 53A5F7     479            anl P2M2, #low(not(00001000B)) 
0556            480            ; Configure SPI
0556 75E2D0     481            mov SPCTL, #11010000B ; Ignore /SS, Enable SPI, DORD=0, Master=1, CPOL=0, CPHA=0, clk/4
0559 22         482            ret
055A            483   
055A            484   ;---------------------------------;
055A            485   ; Sends AND receives a byte via   ;
055A            486   ; SPI.                            ;
055A            487   ;---------------------------------;
055A            488   Send_SPI:
055A F5E3       489            mov SPDAT, a
055C            490   Send_SPI_1:
055C E5E1       491            mov a, SPSTAT 
055E 30E7FB     492            jnb acc.7, Send_SPI_1 ; Check SPI Transfer Completion Flag
0561 F5E1       493            mov SPSTAT, a ; Clear SPI Transfer Completion Flag
0563 E5E3       494            mov a, SPDAT ; return received byte via accumulator
0565 22         495            ret
0566            496   
0566            497   ;---------------------------------;
0566            498   ; SPI flash 'write enable'        ;
0566            499   ; instruction.                    ;
0566            500   ;---------------------------------;
0566            501   Enable_Write:
0566 C2A4       502            clr FLASH_CE
0568 7406       503            mov a, #WRITE_ENABLE
056A 12055A     504            lcall Send_SPI
056D D2A4       505            setb FLASH_CE
056F 22         506            ret
0570            507   
0570            508   ;---------------------------------;
0570            509   ; This function checks the 'write ;
0570            510   ; in progress' bit of the SPI     ;
0570            511   ; flash memory.                   ;
0570            512   ;---------------------------------;
0570            513   Check_WIP:
0570 C2A4       514            clr FLASH_CE
0572 7405       515            mov a, #READ_STATUS
0574 12055A     516            lcall Send_SPI
0577 7455       517            mov a, #0x55
0579 12055A     518            lcall Send_SPI
057C D2A4       519            setb FLASH_CE
057E 20E0EF     520            jb acc.0, Check_WIP ;  Check the Write in Progress bit
0581 22         521            ret
0582            522            
0582            523   ; Display a binary number in the LCD (must be less than 99).  Number to display passed in accumulator.
0582            524   LCD_number:
0582 C0E0       525            push acc
0584 75F00A     526            mov b, #10
0587 84         527            div ab
0588 4430       528            orl a, #'0'
058A 12031C     529            lcall ?WriteData
058D E5F0       530            mov a, b
058F 4430       531            orl a, #'0'
0591 12031C     532            lcall ?WriteData
0594 D0E0       533            pop acc
0596 22         534            ret
0597            535   
0597            536   ; Sounds we need in the SPI flash: 0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 30; 40; 50; minutes; seconds;
0597            537   ; Approximate index of sounds in file 'stop_watch.wav'
0597            538   ; This was generated using: computer_sender -Asw_index.asm -S2000 stop_watch.wav
0597            539   sound_index:
0597 00002D     540       db 0x00, 0x00, 0x2d ; 0 
059A 003107     541       db 0x00, 0x31, 0x07 ; 1 
059D 007007     542       db 0x00, 0x70, 0x07 ; 2 
05A0 00ADB9     543       db 0x00, 0xad, 0xb9 ; 3 
05A3 00F266     544       db 0x00, 0xf2, 0x66 ; 4 
05A6 0135D5     545       db 0x01, 0x35, 0xd5 ; 5 
05A9 017D33     546       db 0x01, 0x7d, 0x33 ; 6 
05AC 01C761     547       db 0x01, 0xc7, 0x61 ; 7 
05AF 021279     548       db 0x02, 0x12, 0x79 ; 8 
05B2 0249C1     549       db 0x02, 0x49, 0xc1 ; 9 
05B5 028F7A     550       db 0x02, 0x8f, 0x7a ; 10 
05B8 02D063     551       db 0x02, 0xd0, 0x63 ; 11 
05BB 031B87     552       db 0x03, 0x1b, 0x87 ; 12 
05BE 03630E     553       db 0x03, 0x63, 0x0e ; 13 
05C1 03B95F     554       db 0x03, 0xb9, 0x5f ; 14 
05C4 04113A     555       db 0x04, 0x11, 0x3a ; 15 
05C7 0466C4     556       db 0x04, 0x66, 0xc4 ; 16 
05CA 04C012     557       db 0x04, 0xc0, 0x12 ; 17 
05CD 052698     558       db 0x05, 0x26, 0x98 ; 18 
05D0 0574E9     559       db 0x05, 0x74, 0xe9 ; 19 
05D3 05D28E     560       db 0x05, 0xd2, 0x8e ; 20 
05D6 061D83     561       db 0x06, 0x1d, 0x83 ; 21 -> 30 
05D9 066342     562       db 0x06, 0x63, 0x42 ; 22 -> 40 
05DC 06AAB9     563       db 0x06, 0xaa, 0xb9 ; 23 -> 50 
05DF 06F3D6     564       db 0x06, 0xf3, 0xd6 ; 24 -> Minutes 
05E2 073F02     565       db 0x07, 0x3f, 0x02 ; 25 -> Seconds 
05E5            566   
05E5            567   ; Size of each sound in 'sound_index'
05E5            568   ; Generated using: computer_sender -Asw_index.asm -S2000 stop_watch.wav
05E5            569   Size_Length:
05E5 0030DA     570       db 0x00, 0x30, 0xda ; 0 
05E8 003F00     571       db 0x00, 0x3f, 0x00 ; 1 
05EB 003DB2     572       db 0x00, 0x3d, 0xb2 ; 2 
05EE 0044AD     573       db 0x00, 0x44, 0xad ; 3 
05F1 00436F     574       db 0x00, 0x43, 0x6f ; 4 
05F4 00475E     575       db 0x00, 0x47, 0x5e ; 5 
05F7 004A2E     576       db 0x00, 0x4a, 0x2e ; 6 
05FA 004B18     577       db 0x00, 0x4b, 0x18 ; 7 
05FD 003748     578       db 0x00, 0x37, 0x48 ; 8 
0600 0045B9     579       db 0x00, 0x45, 0xb9 ; 9 
0603 0040E9     580       db 0x00, 0x40, 0xe9 ; 10 
0606 004B24     581       db 0x00, 0x4b, 0x24 ; 11 
0609 004787     582       db 0x00, 0x47, 0x87 ; 12 
060C 005651     583       db 0x00, 0x56, 0x51 ; 13 
060F 0057DB     584       db 0x00, 0x57, 0xdb ; 14 
0612 00558A     585       db 0x00, 0x55, 0x8a ; 15 
0615 00594E     586       db 0x00, 0x59, 0x4e ; 16 
0618 006686     587       db 0x00, 0x66, 0x86 ; 17 
061B 004E51     588       db 0x00, 0x4e, 0x51 ; 18 
061E 005DA5     589       db 0x00, 0x5d, 0xa5 ; 19 
0621 004AF5     590       db 0x00, 0x4a, 0xf5 ; 20 
0624 0045BF     591       db 0x00, 0x45, 0xbf ; 21 -> 30
0627 004777     592       db 0x00, 0x47, 0x77 ; 22 -> 40
062A 00491D     593       db 0x00, 0x49, 0x1d ; 23 -> 50
062D 004B2C     594       db 0x00, 0x4b, 0x2c ; 24 -> minutes
0630 005C87     595       db 0x00, 0x5c, 0x87 ; 25 -> seconds
0633            596   
0633            597   ; The sound and its length from the two tables above is passed in the accumulator.
0633            598   Play_Sound_Using_Index:
0633 D2A7       599            setb SOUND ; Turn speaker on
0635 C2C8       600            clr TMOD20 ; Stop the CCU from playing previous request
0637 D2A4       601            setb FLASH_CE
0639            602            
0639            603            ; There are three bytes per row in our tables, so multiply index by three
0639 75F003     604            mov b, #3
063C A4         605            mul ab
063D F8         606            mov R0, a ; Make a copy of the index*3
063E            607            
063E C2A4       608            clr FLASH_CE ; Enable SPI Flash
0640 7403       609            mov a, #READ_BYTES
0642 12055A     610            lcall Send_SPI
0645            611            ; Set the initial position in memory of where to start playing
0645 900597     612            mov dptr, #sound_index
0648 E8         613            mov a, R0
0649 93         614            movc a, @a+dptr
064A 12055A     615            lcall Send_SPI
064D A3         616            inc dptr
064E E8         617            mov a, R0
064F 93         618            movc a, @a+dptr
0650 12055A     619            lcall Send_SPI
0653 A3         620            inc dptr
0654 E8         621            mov a, R0
0655 93         622            movc a, @a+dptr
0656 12055A     623            lcall Send_SPI
0659            624            ; Now set how many bytes to play
0659 9005E5     625            mov dptr, #Size_Length
065C E8         626            mov a, R0
065D 93         627            movc a, @a+dptr
065E F55B       628            mov w+2, a
0660 A3         629            inc dptr
0661 E8         630            mov a, R0
0662 93         631            movc a, @a+dptr
0663 F55A       632            mov w+1, a
0665 A3         633            inc dptr
0666 E8         634            mov a, R0
0667 93         635            movc a, @a+dptr
0668 F559       636            mov w+0, a
066A            637            
066A 7400       638            mov a, #0x00 ; Request first byte to send to DAC
066C 12055A     639            lcall Send_SPI
066F            640            
066F D2C8       641            setb TMOD20 ; Start playback by enabling CCU timer
0671            642   
0671 22         643            ret
0672            644    ; Send a character using the serial port
0672            645   putchar:
0672 3099FD     646           jnb TI, putchar 
0675            647           ; TI serial interrupt flag is set and when last bit (stop bit) 
0675            648           ; of receiving data byte is received, RI flag get set. IE register
0675            649           ; is used to enable/disable interrupt sources.
0675 C299       650           clr TI
0677 F599       651           mov SBUF, a
0679 22         652           ret
067A            653   
067A            654   ;---------------------------------------------------------------------------------;
067A            655   ; This is the FSM that plays minutes and seconds after the STOP button is pressed ;
067A            656   ; The state diagram of this FSM is available as 'Stop_Watch_FSM.pdf'              ;
067A            657   ;---------------------------------------------------------------------------------;
067A            658   T2S_FSM:
067A E55E       659            mov a, T2S_FSM_state
067C            660   
067C            661   T2S_FSM_State0: ; Checks for the start signal (T2S_FSM_Start==1)
067C B40013     662            cjne a, #0, T2S_FSM_State1
067F 30000F     663            jnb T2S_FSM_Start, T2S_FSM_State0_Done
0682            664            ; Check if minutes is larger than 19
0682 C3         665            clr c
0683 E55C       666            mov a, minutes
0685 9414       667            subb a, #20
0687 5005       668            jnc minutes_gt_19
0689 755E01     669            mov T2S_FSM_state, #1
068C 8003       670            sjmp T2S_FSM_State0_Done
068E            671   minutes_gt_19:
068E 755E03     672            mov T2S_FSM_state, #3
0691            673   T2S_FSM_State0_Done:
0691 22         674            ret
0692            675            
0692            676   T2S_FSM_State1: ; Plays minutes when minutes is less than 20
0692 B40109     677            cjne a, #1, T2S_FSM_State2
0695 E55C       678            mov a, minutes
0697 120633     679            lcall Play_Sound_Using_Index
069A 755E02     680            mov T2S_FSM_State, #2
069D 22         681            ret 
069E            682   
069E            683   T2S_FSM_State2: ; Stay in this state until sound finishes playing
069E B40207     684            cjne a, #2, T2S_FSM_State3
06A1 20C803     685            jb TMOD20, T2S_FSM_State2_Done 
06A4 755E06     686            mov T2S_FSM_State, #6
06A7            687   T2S_FSM_State2_Done:
06A7 22         688            ret
06A8            689   
06A8            690   T2S_FSM_State3: ; Plays the tens when minutes is larger than 19, for example for 42 minutes, it plays 'forty'
06A8 B4030F     691            cjne a, #3, T2S_FSM_State4
06AB E55C       692            mov a, minutes
06AD 75F00A     693            mov b, #10
06B0 84         694            div ab
06B1 2412       695            add a, #18
06B3 120633     696            lcall Play_Sound_Using_Index
06B6 755E04     697            mov T2S_FSM_State, #4
06B9 22         698            ret
06BA            699   
06BA            700   T2S_FSM_State4: ; Stay in this state until sound finishes playing
06BA B40407     701            cjne a, #4, T2S_FSM_State5
06BD 20C803     702            jb TMOD20, T2S_FSM_State4_Done 
06C0 755E05     703            mov T2S_FSM_State, #5
06C3            704   T2S_FSM_State4_Done:
06C3 22         705       ret
06C4            706   
06C4            707   T2S_FSM_State5: ; Plays the units when minutes is larger than 19, for example for 42 minutes, it plays 'two'
06C4 B40511     708            cjne a, #5, T2S_FSM_State6
06C7 E55C       709            mov a, minutes
06C9 75F00A     710            mov b, #10
06CC 84         711            div ab
06CD E5F0       712            mov a, b
06CF 6003       713            jz T2S_FSM_State5_Done ; Prevents from playing something like 'forty zero'
06D1 120633     714            lcall Play_Sound_Using_Index
06D4            715   T2S_FSM_State5_Done:
06D4 755E02     716            mov T2S_FSM_State, #2
06D7 22         717            ret
06D8            718   
06D8            719   T2S_FSM_State6: ; Plays the word 'minutes'
06D8 B40609     720            cjne a, #6, T2S_FSM_State7
06DB 7418       721            mov a, #24 ; Index 24 has the word 'minutes'
06DD 120633     722            lcall Play_Sound_Using_Index
06E0 755E07     723            mov T2S_FSM_State, #7
06E3 22         724            ret
06E4            725   
06E4            726   T2S_FSM_State7: ; Stay in this state until sound finishes playing
06E4 B40713     727            cjne a, #7, T2S_FSM_State8
06E7 20C80F     728            jb TMOD20, T2S_FSM_State7_Done 
06EA            729            ; Done playing previous sound, check if seconds is larger than 19
06EA C3         730            clr c
06EB E55D       731            mov a, seconds
06ED 9414       732            subb a, #20
06EF 5005       733            jnc seconds_gt_19
06F1 755E08     734            mov T2S_FSM_state, #8
06F4 809B       735            sjmp T2S_FSM_State0_Done
06F6            736   seconds_gt_19:
06F6 755E0A     737            mov T2S_FSM_state, #10
06F9            738   T2S_FSM_State7_Done:
06F9 22         739       ret
06FA            740   
06FA            741   T2S_FSM_State8: ; Play the seconds when seconds is less than 20.
06FA B40809     742            cjne a, #8, T2S_FSM_State9
06FD E55D       743            mov a, seconds
06FF 120633     744            lcall Play_Sound_Using_Index
0702 755E09     745            mov T2S_FSM_state, #9
0705 22         746            ret
0706            747   
0706            748   T2S_FSM_State9: ; Stay in this state until sound finishes playing
0706 B40907     749            cjne a, #9, T2S_FSM_State10
0709 20C803     750            jb TMOD20, T2S_FSM_State9_Done 
070C 755E0D     751            mov T2S_FSM_State, #13
070F            752   T2S_FSM_State9_Done:
070F 22         753            ret
0710            754   
0710            755   T2S_FSM_State10:  ; Plays the tens when seconds is larger than 19, for example for 35 seconds, it plays 'thirty'
0710 B40A0F     756            cjne a, #10, T2S_FSM_State11
0713 E55D       757            mov a, seconds
0715 75F00A     758            mov b, #10
0718 84         759            div ab
0719 2412       760            add a, #18
071B 120633     761            lcall Play_Sound_Using_Index
071E 755E0B     762            mov T2S_FSM_state, #11
0721 22         763            ret
0722            764   
0722            765   T2S_FSM_State11: ; Stay in this state until sound finishes playing
0722 B40B07     766            cjne a, #11, T2S_FSM_State12
0725 20C803     767            jb TMOD20, T2S_FSM_State11_Done 
0728 755E0C     768            mov T2S_FSM_State, #12
072B            769   T2S_FSM_State11_Done:
072B 22         770            ret
072C            771   
072C            772   T2S_FSM_State12: ; Plays the units when seconds is larger than 19, for example for 35 seconds, it plays 'five'
072C B40C11     773            cjne a, #12, T2S_FSM_State13
072F E55D       774            mov a, seconds
0731 75F00A     775            mov b, #10
0734 84         776            div ab
0735 E5F0       777            mov a, b
0737 6003       778            jz T2S_FSM_State12_Done ; Prevents from saying something like 'thirty zero'
0739 120633     779            lcall Play_Sound_Using_Index
073C            780   T2S_FSM_State12_Done:
073C 755E09     781            mov T2S_FSM_State, #9
073F 22         782            ret
0740            783   
0740            784   T2S_FSM_State13: ; Plays the word 'seconds'
0740 B40D09     785            cjne a, #13, T2S_FSM_State14
0743 7419       786            mov a, #25 ; Index 25 has the word 'seconds'
0745 120633     787            lcall Play_Sound_Using_Index
0748 755E0E     788            mov T2S_FSM_State, #14
074B 22         789            ret
074C            790   
074C            791   T2S_FSM_State14: ; Stay in this state until sound finishes playing
074C B40E09     792            cjne a, #14, T2S_FSM_Error
074F 20C805     793            jb TMOD20, T2S_FSM_State14_Done 
0752 C200       794            clr T2S_FSM_Start 
0754 755E00     795            mov T2S_FSM_State, #0
0757            796   T2S_FSM_State14_Done:
0757 22         797            ret
0758            798   
0758            799   T2S_FSM_Error: ; If we got to this point, there is an error in the finite state machine.  Restart it.
0758 755E00     800            mov T2S_FSM_state, #0
075B C200       801            clr T2S_FSM_Start
075D 22         802            ret
075E            803       
075E            804   ;WaitHalfSec:
075E            805   ;        mov R2, #178
075E            806   ;        Lr3: mov R1, #250
075E            807   ;        Lr2: mov R0, #166
075E            808   ;        Lr1: djnz R0, Lr1 ; 3 cycles->3*45.21123ns*166=22.51519us
075E            809   ;        djnz R1, Lr2 ; 22.51519us*250=5.629ms
075E            810   ;        djnz R2, Lr3 ; 5.629ms*89=0.5s (approximately)
075E            811   ;        ret
075E            812   ;        
075E            813   ;blink:
075E            814   ;        mov SP, #7FH
075E            815   ;        mov P3M1, #0   ; Configure P3 in bidirectional mode
075E            816   ;    M0:
075E            817   ;        cpl P3.7
075E            818   ;        Set_Cursor(1, 1)
075E            819   ;        Send_Constant_String(#nothing)
075E            820   ;        Set_Cursor(2, 1)
075E            821   ;        Send_Constant_String(#nothing)
075E            822   ;        Set_Cursor(1, 1)
075E            823   ;        Send_Constant_String(#hot)
075E            824   ;        Set_Cursor(2, 1)
075E            825   ;        Send_Constant_String(#hot)
075E            826   ;
075E            827   ;        lcall WaitHalfSec
075E            828   ;
075E            829   ;        ret
075E            830   ;
075E            831   ;convert:
075E            832   ;    mov x+0, Result
075E            833   ;        mov x+1, Result+1 
075E            834   ;        mov x+2, #0
075E            835   ;        mov x+3, #0
075E            836   ;    ret
075E            837   ;    
075E            838   ;
075E            839   Display_temp:
075E            840   ;    Load_y(410)
075E            841   ;    lcall mul32
075E            842   ;    Load_y(1023)
075E            843   ;    lcall div32
075E            844   ;    Load_y(273)
075E            845   ;    lcall sub32
075E            846   ;    lcall hex2bcd
075E            847   ;    lcall InitSerialPort
075E C0E0       848            push acc
0760 7401       848            mov a, #1
0762 14         848            dec a
0763 120368     848            lcall ?Set_Cursor_1 ; Select column and row
0766 D0E0       848            pop acc
0768 C083       849            push dph
076A C082       849            push dpl
076C C0E0       849            push acc
076E 9003EB     849            mov dptr, #Temp0
0771 12035B     849            lcall ?Send_Constant_String
0774 D0E0       849            pop acc
0776 D082       849            pop dpl
0778 D083       849            pop dph
077A            850   ;    lcall SendString
077A            851   ;    Set_Cursor(1, 5)    
077A            852   ;    Send_BCD(bcd+1) ; send fisrt 2 digits to putty
077A            853   ;    Display_BCD(bcd+1); send fisrt 2 digits to lcd
077A            854   ;    Set_Cursor(1, 7) 
077A            855   ;    Send_BCD(bcd) ; send last 2 digits to putty
077A            856   ;    Display_BCD(bcd+0) ; send last 2 digits to lcd
077A            857   ;    Set_Cursor(1, 5)
077A            858   ;    Send_Constant_String(#dots)
077A            859   ;    lcall SendString
077A            860   ;    mov DPTR, #Newline
077A            861   ;    lcall SendString
077A 22         862       ret
077B            863   ;config_adc:
077B            864   ;        clr CE_ADC 
077B            865   ;        mov R0, #00000001B; Start bit:1 
077B            866   ;        lcall DO_SPI_G
077B            867   ;
077B            868   ;        mov R0, #10000000B; Single ended, read channel 0 
077B            869   ;        lcall DO_SPI_G 
077B            870   ;        mov a, R1          ; R1 contains bits 8 and 9 
077B            871   ;        anl a, #00000011B  ; We need only the two least significant bits 
077B            872   ;        mov Result+1, a    ; Save result high.
077B            873   ;
077B            874   ;        mov R0, #55H; It doesn't matter what we transmit... 
077B            875   ;        lcall DO_SPI_G 
077B            876   ;        mov Result, R1     ; R1 contains bits 0 to 7.  Save result low. 
077B            877   ;        setb CE_ADC 
077B            878   ;        lcall convert  
077B            879   ;        mov a, bcd ; move temp to accumulator 
077B            880   ;        ret
077B            881   Reset_timer:
077B            882   
077B C28E       883       clr TR1                 ; Stop timer 2
077D E4         884       clr a
077E F54B       885            mov Count1ms+0, a
0780 F54C       886            mov Count1ms+1, a
0782            887            ; Now clear the BCD counter and minutes
0782 F552       888            mov BCD_counter, a
0784 D28E       889            setb TR1                ; Start timer 2
0786            890   
0786 22         891       ret
0787            892   Display_time:
0787 C0E0       893            push acc
0789 7401       893            mov a, #1
078B 14         893            dec a
078C 120366     893            lcall ?Set_Cursor_2 ; Select column and row
078F D0E0       893            pop acc
0791 C083       894            push dph
0793 C082       894            push dpl
0795 C0E0       894            push acc
0797 9003FC     894            mov dptr, #Time
079A 12035B     894            lcall ?Send_Constant_String
079D D0E0       894            pop acc
079F D082       894            pop dpl
07A1 D083       894            pop dph
07A3 C203       895       clr half_seconds_flag ; We clear this flag in the main loop, but it is set in the ISR for timer 2
07A5 C0E0       896            push acc
07A7 7409       896            mov a, #9
07A9 14         896            dec a
07AA 120366     896            lcall ?Set_Cursor_2 ; Select column and row
07AD D0E0       896            pop acc     ; the place in the LCD where we want the BCD counter value
07AF C000       897            push ar0
07B1 A852       897            mov r0, BCD_counter
07B3 12036D     897            lcall ?Display_BCD
07B6 D000       897            pop ar0 ; This macro is also in 'LCD_4bit.inc'
07B8 C0E0       898            push acc
07BA 7406       898            mov a, #6
07BC 14         898            dec a
07BD 120366     898            lcall ?Set_Cursor_2 ; Select column and row
07C0 D0E0       898            pop acc     ; the place in the LCD where we want the BCD counter value
07C2 C000       899            push ar0
07C4 A85C       899            mov r0, minutes
07C6 12036D     899            lcall ?Display_BCD
07C9 D000       899            pop ar0 ; This macro is also in 'LCD_4bit.inc'
07CB            900   
07CB 22         901       ret
07CC            902   ;;Timer couter 
07CC            903       sec_counter: 
07CC E552       904           mov a,BCD_counter
07CE B4600A     905           cjne a, #0x60, Continue1 ; check if the couter reached 60s
07D1 E55C       906           mov a, minutes
07D3 2401       907           add a, #0x01 ; add one to the minutes
07D5 D4         908           da a ; Decimal adjust instruction.  Check datasheet for more details!
07D6 F55C       909           mov minutes, a
07D8 12077B     910           lcall Reset_timer
07DB            911                Continue1:
07DB 22         912           ret
07DC            913       min_counter:
07DC E55C       914                    mov a,minutes
07DE B4600B     915                    cjne a, #0x60, Continue2
07E1 C28E       916                    clr TR1                 ; Stop timer 2
07E3 E4         917                    clr a                   
07E4 F54B       918                    mov Count1ms+0, a
07E6 F54C       919                    mov Count1ms+1, a       ; Now clear the BCD counter
07E8 F55C       920                    mov minutes, a              ; Reset minutes
07EA D28E       921           setb TR1                ; Start timer 2
07EC            922   
07EC            923                    Continue2:
07EC 22         924           ret
07ED            925   home_page:
07ED            926       ;--------Timer----------;
07ED 300309     927       jnb half_seconds_flag, Temp_sensor
07F0 1207CC     928       lcall sec_counter
07F3 1207DC     929       lcall min_counter
07F6 120787     930       lcall Display_time
07F9            931       ;-----------------------;
07F9            932               
07F9            933       ;-----TEMP SENSOR-------;
07F9            934       Temp_sensor:
07F9            935    ;    lcall config_adc
07F9 12075E     936       lcall Display_temp
07FC            937    ;    lcall  WaitHalfSec 
07FC            938    ;    ;-----------------------;
07FC 22         939       ret
07FD            940   ;
07FD            941   setup_reflow_page:
07FD 20A011     942            jb set_BUTTON, continue9
0800 C002       942            push AR2
0802 7A0A       942            mov R2, #10
0804 1202D7     942            lcall ?Wait_Milli_Seconds
0807 D002       942            pop AR2
0809 20A005     942            jb set_BUTTON, continue9
080C 30A0FD     942            jnb set_BUTTON, $
080F            942   
080F B209       943       cpl tt_reflow_flag
0811            944       continue9:
0811            945   
0811 200906     946       jb tt_reflow_flag, jump1
0814            947       ;jnb tt_reflow_flag, jump1
0814 1208F6     948       lcall INC_DEC_Reflow_time
0817 02081D     949       ljmp display_reflow_page
081A            950       jump1:
081A 12093E     951       lcall INC_DEC_Reflow_temp
081D            952   
081D            953   
081D            954       display_reflow_page:
081D C0E0       955            push acc
081F 7405       955            mov a, #5
0821 14         955            dec a
0822 120368     955            lcall ?Set_Cursor_1 ; Select column and row
0825 D0E0       955            pop acc
0827 C000       956            push ar0
0829 A84D       956            mov r0, reflow_temp+0
082B 12036D     956            lcall ?Display_BCD
082E D000       956            pop ar0
0830 C0E0       957            push acc
0832 7407       957            mov a, #7
0834 14         957            dec a
0835 120368     957            lcall ?Set_Cursor_1 ; Select column and row
0838 D0E0       957            pop acc
083A C000       958            push ar0
083C A84E       958            mov r0, reflow_temp+1
083E 12036D     958            lcall ?Display_BCD
0841 D000       958            pop ar0
0843            959          
0843            960       
0843 C0E0       961            push acc
0845 7401       961            mov a, #1
0847 14         961            dec a
0848 120368     961            lcall ?Set_Cursor_1 ; Select column and row
084B D0E0       961            pop acc
084D C083       962            push dph
084F C082       962            push dpl
0851 C0E0       962            push acc
0853 90041E     962            mov dptr, #reflow_setup
0856 12035B     962            lcall ?Send_Constant_String
0859 D0E0       962            pop acc
085B D082       962            pop dpl
085D D083       962            pop dph
085F C0E0       963            push acc
0861 7409       963            mov a, #9
0863 14         963            dec a
0864 120368     963            lcall ?Set_Cursor_1 ; Select column and row
0867 D0E0       963            pop acc
0869 C083       964            push dph
086B C082       964            push dpl
086D C0E0       964            push acc
086F 900423     964            mov dptr, #reflow_setup4
0872 12035B     964            lcall ?Send_Constant_String
0875 D0E0       964            pop acc
0877 D082       964            pop dpl
0879 D083       964            pop dph
087B            965   
087B C0E0       966            push acc
087D 7401       966            mov a, #1
087F 14         966            dec a
0880 120366     966            lcall ?Set_Cursor_2 ; Select column and row
0883 D0E0       966            pop acc
0885 C083       967            push dph
0887 C082       967            push dpl
0889 C0E0       967            push acc
088B 90042C     967            mov dptr, #reflow_setup2
088E 12035B     967            lcall ?Send_Constant_String
0891 D0E0       967            pop acc
0893 D082       967            pop dpl
0895 D083       967            pop dph
0897 C0E0       968            push acc
0899 7408       968            mov a, #8
089B 14         968            dec a
089C 120366     968            lcall ?Set_Cursor_2 ; Select column and row
089F D0E0       968            pop acc
08A1 C083       969            push dph
08A3 C082       969            push dpl
08A5 C0E0       969            push acc
08A7 9003D8     969            mov dptr, #dots
08AA 12035B     969            lcall ?Send_Constant_String
08AD D0E0       969            pop acc
08AF D082       969            pop dpl
08B1 D083       969            pop dph
08B3 C0E0       970            push acc
08B5 740C       970            mov a, #12
08B7 14         970            dec a
08B8 120366     970            lcall ?Set_Cursor_2 ; Select column and row
08BB D0E0       970            pop acc
08BD C083       971            push dph
08BF C082       971            push dpl
08C1 C0E0       971            push acc
08C3 900431     971            mov dptr, #reflow_setup3
08C6 12035B     971            lcall ?Send_Constant_String
08C9 D0E0       971            pop acc
08CB D082       971            pop dpl
08CD D083       971            pop dph
08CF C0E0       972            push acc
08D1 7409       972            mov a, #9
08D3 14         972            dec a
08D4 120366     972            lcall ?Set_Cursor_2 ; Select column and row
08D7 D0E0       972            pop acc
08D9 C000       973            push ar0
08DB A854       973            mov r0, reflow_sec
08DD 12036D     973            lcall ?Display_BCD
08E0 D000       973            pop ar0
08E2 C0E0       974            push acc
08E4 7406       974            mov a, #6
08E6 14         974            dec a
08E7 120366     974            lcall ?Set_Cursor_2 ; Select column and row
08EA D0E0       974            pop acc
08EC C000       975            push ar0
08EE A855       975            mov r0, reflow_min
08F0 12036D     975            lcall ?Display_BCD
08F3 D000       975            pop ar0
08F5            976   
08F5 22         977       ret
08F6            978       INC_DEC_Reflow_time:
08F6            979   
08F6 20A124     980            jb SETUP_SOAK_Button, check_decrement
08F9 C002       980            push AR2
08FB 7A0A       980            mov R2, #10
08FD 1202D7     980            lcall ?Wait_Milli_Seconds
0900 D002       980            pop AR2
0902 20A118     980            jb SETUP_SOAK_Button, check_decrement
0905 30A1FD     980            jnb SETUP_SOAK_Button, $
0908            980    ; setup soak is also used to increment 
0908            981   
0908 E554       982           mov a, reflow_sec
090A B4590B     983           cjne a, #0x59, add_reflow_sec
090D E555       984           mov a, reflow_min
090F 2401       985           add a, #0x01
0911 D4         986           da a
0912 F555       987           mov reflow_min, a
0914 E4         988           clr a 
0915 02091B     989           ljmp Continue5
0918            990           add_reflow_sec:
0918 2401       991           add a, #0x01
091A D4         992           da a ; Decimal adjust instruction.  Check datasheet for more details!
091B            993           Continue5:
091B F554       994           mov reflow_sec, a
091D            995   
091D            996           check_decrement:
091D 20A61D     997            jb Button_min, continue8
0920 C002       997            push AR2
0922 7A0A       997            mov R2, #10
0924 1202D7     997            lcall ?Wait_Milli_Seconds
0927 D002       997            pop AR2
0929 20A611     997            jb Button_min, continue8
092C 30A6FD     997            jnb Button_min, $
092F            997   
092F E554       998           mov a, reflow_sec
0931 B40004     999           cjne a, #0x00, sub_reflow_sec
0934 E4        1000           clr a 
0935 02093B    1001           ljmp Continue6
0938           1002           sub_reflow_sec:
0938 2499      1003           add a, #0x99 ; add 99 reduces 1
093A D4        1004           da a ; Decimal adjust instruction.  Check datasheet for more details!
093B           1005           Continue6:
093B F554      1006           mov reflow_sec, a
093D           1007           continue8:
093D 22        1008           ret
093E           1009       INC_DEC_Reflow_temp:
093E           1010           ;PushButton(SETUP_SOAK_Button,check_decrement2) ; setup soak is also used to increment 
093E           1011   
093E 20A121    1012            jb SETUP_SOAK_Button, check_decrement2
0941 C002      1012            push AR2
0943 7A0A      1012            mov R2, #10
0945 1202D7    1012            lcall ?Wait_Milli_Seconds
0948 D002      1012            pop AR2
094A 20A115    1012            jb SETUP_SOAK_Button, check_decrement2
094D 30A1FD    1012            jnb SETUP_SOAK_Button, $
0950           1012   
0950           1013             ;  jb SETUP_SOAK_Button, check_decrement2  
0950           1014             ;      Wait_Milli_Seconds(#50)         
0950           1015             ;  jb SETUP_SOAK_Button, check_decrement2  
0950           1016             ;  loop_hold_inc:
0950           1017   ;
0950           1018             ;  jnb SETUP_SOAK_Button, jump2
0950           1019             ;  ;Wait_Milli_Seconds(#50)
0950           1020             ;  jnb SETUP_SOAK_Button, jump2
0950           1021             ;  ljmp hold_done
0950           1022             ;  jump2:
0950           1023             ;  Set_Cursor(1, 5)
0950           1024             ;  Display_BCD(reflow_temp+0)
0950           1025             ;  Set_Cursor(1, 7)
0950           1026             ;  Display_BCD(reflow_temp+1)
0950           1027             ;  Wait_Milli_Seconds(#100)    
0950 E54E      1028               mov a, reflow_temp+1
0952 2401      1029               add a, #0x01
0954 D4        1030               da a ; Decimal adjust instruction.  Check datasheet for more details!
0955 F54E      1031               mov reflow_temp+1, a
0957 E54E      1032               mov a, reflow_temp+1
0959 7007      1033               jnz INC_reflow_temp_done2
095B E54D      1034               mov a, reflow_temp+0
095D 2401      1035               add a, #0x01
095F D4        1036               da a ; Decimal adjust instruction.  Check datasheet for more details!
0960 F54D      1037               mov reflow_temp+0, a
0962           1038              ; mov a, reflow_temp+1
0962           1039               INC_reflow_temp_done2:
0962           1040               
0962           1041             ;  ljmp loop_hold_inc
0962           1042           hold_done:
0962           1043           
0962           1044   
0962           1045   
0962           1046           check_decrement2:
0962           1047   
0962 20A621    1048            jb Button_min, DEC_reflow_temp_done2
0965 C002      1048            push AR2
0967 7A0A      1048            mov R2, #10
0969 1202D7    1048            lcall ?Wait_Milli_Seconds
096C D002      1048            pop AR2
096E 20A615    1048            jb Button_min, DEC_reflow_temp_done2
0971 30A6FD    1048            jnb Button_min, $
0974           1048   
0974           1049            ;   jb Button_min, DEC_reflow_temp_done2  
0974           1050            ;       Wait_Milli_Seconds(#50)         
0974           1051            ;   jb Button_min, DEC_reflow_temp_done2  
0974           1052            ;   loop_hold_dec:
0974           1053   ;
0974           1054            ;   jnb Button_min, jump3
0974           1055            ;   ljmp DEC_reflow_temp_done2
0974           1056            ;   jump3:
0974           1057            ;   Set_Cursor(1, 5)
0974           1058            ;   Display_BCD(reflow_temp+0)
0974           1059            ;   Set_Cursor(1, 7)
0974           1060            ;   Display_BCD(reflow_temp+1)
0974           1061            ;   Wait_Milli_Seconds(#100)    
0974 E54E      1062               mov a, reflow_temp+1
0976 2499      1063               add a, #0x99
0978 D4        1064               da a ; Decimal adjust instruction.  Check datasheet for more details!
0979 F54E      1065               mov reflow_temp+1, a
097B E54E      1066               mov a, reflow_temp+1
097D 7007      1067               jnz INC_reflow_temp_done
097F E54D      1068               mov a, reflow_temp+0
0981 2499      1069               add a, #0x99
0983 D4        1070               da a ; Decimal adjust instruction.  Check datasheet for more details!
0984 F54D      1071               mov reflow_temp+0, a
0986           1072             ;  mov a, reflow_temp+1
0986           1073               INC_reflow_temp_done:
0986           1074               
0986           1075             ;  ljmp loop_hold_dec
0986           1076   
0986           1077           DEC_reflow_temp_done2:
0986           1078       
0986           1079   
0986 22        1080       ret
0987           1081   setup_soak_page:
0987 20A011    1082            jb set_BUTTON, continue11
098A C002      1082            push AR2
098C 7A0A      1082            mov R2, #10
098E 1202D7    1082            lcall ?Wait_Milli_Seconds
0991 D002      1082            pop AR2
0993 20A005    1082            jb set_BUTTON, continue11
0996 30A0FD    1082            jnb set_BUTTON, $
0999           1082   
0999 B20A      1083       cpl tt_flag_soak
099B           1084       continue11:
099B           1085   
099B 200A06    1086       jb tt_flag_soak, jump4
099E 120A80    1087       lcall INC_DEC_soak_time
09A1 0209A7    1088       ljmp display_soak_page
09A4           1089       jump4:
09A4 120AC8    1090       lcall INC_DEC_soak_temp
09A7           1091   
09A7           1092   
09A7           1093       display_soak_page:
09A7 C0E0      1094            push acc
09A9 7405      1094            mov a, #5
09AB 14        1094            dec a
09AC 120368    1094            lcall ?Set_Cursor_1 ; Select column and row
09AF D0E0      1094            pop acc
09B1 C000      1095            push ar0
09B3 A84F      1095            mov r0, soak_temp+0
09B5 12036D    1095            lcall ?Display_BCD
09B8 D000      1095            pop ar0
09BA C0E0      1096            push acc
09BC 7407      1096            mov a, #7
09BE 14        1096            dec a
09BF 120368    1096            lcall ?Set_Cursor_1 ; Select column and row
09C2 D0E0      1096            pop acc
09C4 C000      1097            push ar0
09C6 A850      1097            mov r0, soak_temp+1
09C8 12036D    1097            lcall ?Display_BCD
09CB D000      1097            pop ar0
09CD           1098          
09CD           1099       
09CD C0E0      1100            push acc
09CF 7401      1100            mov a, #1
09D1 14        1100            dec a
09D2 120368    1100            lcall ?Set_Cursor_1 ; Select column and row
09D5 D0E0      1100            pop acc
09D7 C083      1101            push dph
09D9 C082      1101            push dpl
09DB C0E0      1101            push acc
09DD 900436    1101            mov dptr, #soak_setup0
09E0 12035B    1101            lcall ?Send_Constant_String
09E3 D0E0      1101            pop acc
09E5 D082      1101            pop dpl
09E7 D083      1101            pop dph
09E9 C0E0      1102            push acc
09EB 7409      1102            mov a, #9
09ED 14        1102            dec a
09EE 120368    1102            lcall ?Set_Cursor_1 ; Select column and row
09F1 D0E0      1102            pop acc
09F3           1102   
09F3 C083      1103            push dph
09F5 C082      1103            push dpl
09F7 C0E0      1103            push acc
09F9 90043B    1103            mov dptr, #soak_setup1
09FC 12035B    1103            lcall ?Send_Constant_String
09FF D0E0      1103            pop acc
0A01 D082      1103            pop dpl
0A03 D083      1103            pop dph
0A05           1104   
0A05 C0E0      1105            push acc
0A07 7401      1105            mov a, #1
0A09 14        1105            dec a
0A0A 120366    1105            lcall ?Set_Cursor_2 ; Select column and row
0A0D D0E0      1105            pop acc
0A0F           1105   
0A0F C083      1106            push dph
0A11 C082      1106            push dpl
0A13 C0E0      1106            push acc
0A15 900443    1106            mov dptr, #soak_setup2
0A18 12035B    1106            lcall ?Send_Constant_String
0A1B D0E0      1106            pop acc
0A1D D082      1106            pop dpl
0A1F D083      1106            pop dph
0A21 C0E0      1107            push acc
0A23 7408      1107            mov a, #8
0A25 14        1107            dec a
0A26 120366    1107            lcall ?Set_Cursor_2 ; Select column and row
0A29 D0E0      1107            pop acc
0A2B           1107   
0A2B C083      1108            push dph
0A2D C082      1108            push dpl
0A2F C0E0      1108            push acc
0A31 9003D8    1108            mov dptr, #dots
0A34 12035B    1108            lcall ?Send_Constant_String
0A37 D0E0      1108            pop acc
0A39 D082      1108            pop dpl
0A3B D083      1108            pop dph
0A3D C0E0      1109            push acc
0A3F 740C      1109            mov a, #12
0A41 14        1109            dec a
0A42 120366    1109            lcall ?Set_Cursor_2 ; Select column and row
0A45 D0E0      1109            pop acc
0A47 C083      1110            push dph
0A49 C082      1110            push dpl
0A4B C0E0      1110            push acc
0A4D 900448    1110            mov dptr, #soak_setup3
0A50 12035B    1110            lcall ?Send_Constant_String
0A53 D0E0      1110            pop acc
0A55 D082      1110            pop dpl
0A57 D083      1110            pop dph
0A59 C0E0      1111            push acc
0A5B 7409      1111            mov a, #9
0A5D 14        1111            dec a
0A5E 120366    1111            lcall ?Set_Cursor_2 ; Select column and row
0A61 D0E0      1111            pop acc
0A63           1111   
0A63 C000      1112            push ar0
0A65 A856      1112            mov r0, soak_sec
0A67 12036D    1112            lcall ?Display_BCD
0A6A D000      1112            pop ar0
0A6C C0E0      1113            push acc
0A6E 7406      1113            mov a, #6
0A70 14        1113            dec a
0A71 120366    1113            lcall ?Set_Cursor_2 ; Select column and row
0A74 D0E0      1113            pop acc
0A76 C000      1114            push ar0
0A78 A857      1114            mov r0, soak_min
0A7A 12036D    1114            lcall ?Display_BCD
0A7D D000      1114            pop ar0
0A7F 22        1115   ret
0A80           1116       INC_DEC_soak_time:
0A80           1117       
0A80 20A124    1118            jb SETUP_SOAK_Button, check_decrement_soak
0A83 C002      1118            push AR2
0A85 7A0A      1118            mov R2, #10
0A87 1202D7    1118            lcall ?Wait_Milli_Seconds
0A8A D002      1118            pop AR2
0A8C 20A118    1118            jb SETUP_SOAK_Button, check_decrement_soak
0A8F 30A1FD    1118            jnb SETUP_SOAK_Button, $
0A92           1118    ; setup soak is also used to increment 
0A92           1119   
0A92 E556      1120           mov a, soak_sec
0A94 B4590B    1121           cjne a, #0x59, add_soak_sec
0A97 E557      1122           mov a, soak_min
0A99 2401      1123           add a, #0x01
0A9B D4        1124           da a
0A9C F557      1125           mov soak_min, a
0A9E E4        1126           clr a 
0A9F 020AA5    1127           ljmp Continue12
0AA2           1128           add_soak_sec:
0AA2 2401      1129           add a, #0x01
0AA4 D4        1130           da a ; Decimal adjust instruction.  Check datasheet for more details!
0AA5           1131           Continue12:
0AA5 F556      1132           mov soak_sec, a
0AA7           1133   
0AA7           1134           check_decrement_soak:
0AA7 20A61D    1135            jb Button_min, continue13
0AAA C002      1135            push AR2
0AAC 7A0A      1135            mov R2, #10
0AAE 1202D7    1135            lcall ?Wait_Milli_Seconds
0AB1 D002      1135            pop AR2
0AB3 20A611    1135            jb Button_min, continue13
0AB6 30A6FD    1135            jnb Button_min, $
0AB9           1135   
0AB9 E556      1136           mov a, soak_sec
0ABB B40004    1137           cjne a, #0x00, sub_soak_sec
0ABE E4        1138           clr a 
0ABF 020AC5    1139           ljmp Continue14
0AC2           1140           sub_soak_sec:
0AC2 2499      1141           add a, #0x99 ; add 99 reduces 1
0AC4 D4        1142           da a ; Decimal adjust instruction.  Check datasheet for more details!
0AC5           1143           Continue14:
0AC5 F556      1144           mov soak_sec, a
0AC7           1145           continue13:
0AC7           1146           
0AC7 22        1147           ret
0AC8           1148       INC_DEC_soak_temp:
0AC8           1149           
0AC8 20A121    1150            jb SETUP_SOAK_Button, check_decrement2_soak
0ACB C002      1150            push AR2
0ACD 7A0A      1150            mov R2, #10
0ACF 1202D7    1150            lcall ?Wait_Milli_Seconds
0AD2 D002      1150            pop AR2
0AD4 20A115    1150            jb SETUP_SOAK_Button, check_decrement2_soak
0AD7 30A1FD    1150            jnb SETUP_SOAK_Button, $
0ADA           1150   
0ADA           1151           ;    jb SETUP_SOAK_Button, check_decrement2_soak  
0ADA           1152           ;        Wait_Milli_Seconds(#50)         
0ADA           1153           ;    jb SETUP_SOAK_Button, check_decrement2_soak  
0ADA           1154           ;    loop_hold_inc_soak:
0ADA           1155   ;
0ADA           1156           ;    jnb SETUP_SOAK_Button, jump6
0ADA           1157           ;    Wait_Milli_Seconds(#100)
0ADA           1158           ;    jnb SETUP_SOAK_Button, jump6
0ADA           1159           ;    ljmp hold_done_soak
0ADA           1160           ;    jump6:
0ADA           1161           ;    Set_Cursor(1, 5)
0ADA           1162           ;    Display_BCD(soak_temp+0)
0ADA           1163           ;    Set_Cursor(1, 7)
0ADA           1164           ;    Display_BCD(soak_temp+1)
0ADA           1165           ;    Wait_Milli_Seconds(#200)    
0ADA E550      1166               mov a, soak_temp+1
0ADC 2401      1167               add a, #0x01
0ADE D4        1168               da a ; Decimal adjust instruction.  Check datasheet for more details!
0ADF F550      1169               mov soak_temp+1, a
0AE1 E550      1170               mov a, soak_temp+1
0AE3 7007      1171               jnz INC_soak_temp_done2
0AE5 E54F      1172               mov a, soak_temp+0
0AE7 2401      1173               add a, #0x01
0AE9 D4        1174               da a ; Decimal adjust instruction.  Check datasheet for more details!
0AEA F54F      1175               mov soak_temp+0, a
0AEC           1176              ; mov a, soak_temp+1
0AEC           1177               INC_soak_temp_done2:
0AEC           1178               
0AEC           1179             ;  ljmp loop_hold_inc_soak
0AEC           1180           hold_done_soak:
0AEC           1181           
0AEC           1182   
0AEC           1183   
0AEC           1184           check_decrement2_soak:
0AEC           1185   
0AEC 20A621    1186            jb Button_min, DEC_soak_temp_done2
0AEF C002      1186            push AR2
0AF1 7A0A      1186            mov R2, #10
0AF3 1202D7    1186            lcall ?Wait_Milli_Seconds
0AF6 D002      1186            pop AR2
0AF8 20A615    1186            jb Button_min, DEC_soak_temp_done2
0AFB 30A6FD    1186            jnb Button_min, $
0AFE           1186   
0AFE           1187              ; 
0AFE           1188              ; jb Button_min, DEC_soak_temp_done2  
0AFE           1189              ;     Wait_Milli_Seconds(#50)         
0AFE           1190              ; jb Button_min, DEC_soak_temp_done2  
0AFE           1191              ; loop_hold_dec_soak:
0AFE           1192   ;
0AFE           1193              ; jnb Button_min, jump7
0AFE           1194              ; Wait_Milli_Seconds(#100)
0AFE           1195              ; jnb Button_min, jump7
0AFE           1196              ; ljmp DEC_soak_temp_done2
0AFE           1197              ; jump7:
0AFE           1198              ; Set_Cursor(1, 5)
0AFE           1199              ; Display_BCD(soak_temp+0)
0AFE           1200              ; Set_Cursor(1, 7)
0AFE           1201              ; Display_BCD(soak_temp+1)
0AFE           1202              ; Wait_Milli_Seconds(#100)    
0AFE E550      1203               mov a, soak_temp+1
0B00 2499      1204               add a, #0x99
0B02 D4        1205               da a ; Decimal adjust instruction.  Check datasheet for more details!
0B03 F550      1206               mov soak_temp+1, a
0B05 E550      1207               mov a, soak_temp+1
0B07 7007      1208               jnz INC_soak_temp_done
0B09 E54F      1209               mov a, soak_temp+0
0B0B 2499      1210               add a, #0x99
0B0D D4        1211               da a ; Decimal adjust instruction.  Check datasheet for more details!
0B0E F54F      1212               mov soak_temp+0, a
0B10           1213             ;  mov a, soak_temp+1
0B10           1214               INC_soak_temp_done:
0B10           1215               
0B10           1216              ; ljmp loop_hold_dec_soak
0B10           1217   
0B10           1218           DEC_soak_temp_done2:
0B10 22        1219           ret
0B11           1220   second_page:
0B11 C0E0      1221            push acc
0B13 7401      1221            mov a, #1
0B15 14        1221            dec a
0B16 120368    1221            lcall ?Set_Cursor_1 ; Select column and row
0B19 D0E0      1221            pop acc
0B1B C083      1222            push dph
0B1D C082      1222            push dpl
0B1F C0E0      1222            push acc
0B21 90040D    1222            mov dptr, #soak_reflw
0B24 12035B    1222            lcall ?Send_Constant_String
0B27 D0E0      1222            pop acc
0B29 D082      1222            pop dpl
0B2B D083      1222            pop dph
0B2D C0E0      1223            push acc
0B2F 7401      1223            mov a, #1
0B31 14        1223            dec a
0B32 120366    1223            lcall ?Set_Cursor_2 ; Select column and row
0B35 D0E0      1223            pop acc
0B37 C083      1224            push dph
0B39 C082      1224            push dpl
0B3B C0E0      1224            push acc
0B3D 9003A5    1224            mov dptr, #nothing
0B40 12035B    1224            lcall ?Send_Constant_String
0B43 D0E0      1224            pop acc
0B45 D082      1224            pop dpl
0B47 D083      1224            pop dph
0B49 22        1225       ret
0B4A           1226   
0B4A           1227   FSM_LCD:
0B4A E546      1228           mov a, state_lcd
0B4C           1229   
0B4C           1230   
0B4C           1231           ;----------------STATE 0------------------;
0B4C           1232            home_state:
0B4C B4001E    1233               cjne a, #0, soak_reflow_state
0B4F 20A015    1234            jb set_BUTTON, done_home2
0B52 C002      1234            push AR2
0B54 7A0A      1234            mov R2, #10
0B56 1202D7    1234            lcall ?Wait_Milli_Seconds
0B59 D002      1234            pop AR2
0B5B 20A009    1234            jb set_BUTTON, done_home2
0B5E 30A0FD    1234            jnb set_BUTTON, $
0B61           1234    
0B61           1235               ;setb set_flag  
0B61 754601    1236               mov state_lcd, #1
0B64 020B6A    1237               ljmp done_home
0B67           1238               done_home2:
0B67           1239               ;clr set_flag
0B67 1207ED    1240               lcall home_page
0B6A           1241               done_home:
0B6A 020C09    1242               ljmp Forever_done           
0B6D           1243           ;------------------------------------------;
0B6D           1244           
0B6D           1245        ;   ;----------------STATE 1-------------------;
0B6D           1246           soak_reflow_state:
0B6D B4014B    1247               cjne a, #1, setup_soak
0B70 120B11    1248               lcall second_page
0B73           1249             ;  Wait_Milli_Seconds(#50)
0B73 1207CC    1250               lcall sec_counter ; prevent the timer to go over 60
0B76 1207DC    1251               lcall min_counter
0B79 20A712    1252            jb HOME_BUTTON, next_pushb
0B7C C002      1252            push AR2
0B7E 7A0A      1252            mov R2, #10
0B80 1202D7    1252            lcall ?Wait_Milli_Seconds
0B83 D002      1252            pop AR2
0B85 20A706    1252            jb HOME_BUTTON, next_pushb
0B88 30A7FD    1252            jnb HOME_BUTTON, $
0B8B           1252    ; check if home button is pressed 
0B8B 754600    1253               mov state_lcd, #0
0B8E           1254               next_pushb:
0B8E 20A112    1255            jb SETUP_SOAK_Button, next_pushb2
0B91 C002      1255            push AR2
0B93 7A0A      1255            mov R2, #10
0B95 1202D7    1255            lcall ?Wait_Milli_Seconds
0B98 D002      1255            pop AR2
0B9A 20A106    1255            jb SETUP_SOAK_Button, next_pushb2
0B9D 30A1FD    1255            jnb SETUP_SOAK_Button, $
0BA0           1255    ; check if the the button to setup soak is pressed
0BA0 754602    1256               mov state_lcd, #2
0BA3           1257               next_pushb2:
0BA3 20A612    1258            jb Button_min, done_soak
0BA6 C002      1258            push AR2
0BA8 7A0A      1258            mov R2, #10
0BAA 1202D7    1258            lcall ?Wait_Milli_Seconds
0BAD D002      1258            pop AR2
0BAF 20A606    1258            jb Button_min, done_soak
0BB2 30A6FD    1258            jnb Button_min, $
0BB5           1258    ; check if the buttion to setup the reflow was pressed 
0BB5 754603    1259               mov state_lcd, #3
0BB8           1260               done_soak:
0BB8 020C09    1261              ljmp Forever_done 
0BBB           1262           ;------------------------------------------;
0BBB           1263   ;
0BBB           1264        ;   ;-----------------STATE 2------------------;
0BBB           1265           setup_soak: ; its actually set up reflow Im dumb
0BBB B40221    1266               cjne a, #2, setup_reflow
0BBE 1207FD    1267               lcall setup_reflow_page
0BC1           1268             ;  Wait_Milli_Seconds(#50)
0BC1 1207CC    1269               lcall sec_counter ; prevent the timer to go over 60
0BC4 1207DC    1270               lcall min_counter
0BC7 20A712    1271            jb HOME_BUTTON, done_setup_soak
0BCA C002      1271            push AR2
0BCC 7A0A      1271            mov R2, #10
0BCE 1202D7    1271            lcall ?Wait_Milli_Seconds
0BD1 D002      1271            pop AR2
0BD3 20A706    1271            jb HOME_BUTTON, done_setup_soak
0BD6 30A7FD    1271            jnb HOME_BUTTON, $
0BD9           1271    ; check if home button is pressed 
0BD9 754600    1272               mov state_lcd, #0
0BDC           1273               done_setup_soak:
0BDC 020C09    1274               ljmp Forever_done 
0BDF           1275           ;------------------------------------------;
0BDF           1276   ;
0BDF           1277        ;   ;----------------STATE 3-------------------;
0BDF           1278           setup_reflow: ; its actually set up soak Im dumb
0BDF B40303    1279               cjne a, #3, FDP
0BE2 020BE8    1280               ljmp FDP2
0BE5           1281               FDP:
0BE5 020B4C    1282               ljmp home_state
0BE8           1283               FDP2:
0BE8 120987    1284               lcall setup_soak_page
0BEB 1207CC    1285               lcall sec_counter ; prevent the timer to go over 60
0BEE 1207DC    1286               lcall min_counter
0BF1 20A712    1287            jb HOME_BUTTON, done_setup_reflow
0BF4 C002      1287            push AR2
0BF6 7A0A      1287            mov R2, #10
0BF8 1202D7    1287            lcall ?Wait_Milli_Seconds
0BFB D002      1287            pop AR2
0BFD 20A706    1287            jb HOME_BUTTON, done_setup_reflow
0C00 30A7FD    1287            jnb HOME_BUTTON, $
0C03           1287    ; check if home button is pressed 
0C03 754600    1288               mov state_lcd, #0
0C06           1289               done_setup_reflow:
0C06 020C09    1290               ljmp Forever_done 
0C09           1291        ;   ;------------------------------------------;
0C09           1292           Forever_done:
0C09 22        1293   ret
0C0A           1294   
0C0A           1295   ;------------------------------
0C0A           1296   ;---------------------------------;
0C0A           1297   ; Main program. Includes hardware ;
0C0A           1298   ; initialization and 'forever'    ;
0C0A           1299   ; loop.                           ;
0C0A           1300   ;---------------------------------;
0C0A           1301   main:
0C0A           1302            ; Initialization
0C0A 75817F    1303       mov SP, #0x7F
0C0D 12044D    1304       lcall Timer0_Init
0C10 120467    1305       lcall Timer1_Init
0C13           1306   
0C13 120519    1307       lcall Ports_Init ; Default all pins as bidirectional I/O. See Table 42.
0C16 120326    1308       lcall LCD_4BIT
0C19 120542    1309       lcall Double_Clk
0C1C 120532    1310            lcall InitDAC1 ; Call after 'Ports_Init'
0C1F 1204CB    1311            lcall CCU_Init
0C22 12054A    1312            lcall Init_SPI
0C25           1313            
0C25           1314            
0C25 D2AF      1315            setb EA ; Enable global interrupts.
0C27           1316   
0C27           1317            ; Initialize variables
0C27 C200      1318            clr T2S_FSM_Start
0C29 755E00    1319            mov T2S_FSM_state, #0
0C2C           1320       ; Configure all the ports in bidirectional mode:
0C2C           1321   
0C2C 758400    1322       mov P0M1, #00H
0C2F 758500    1323       mov P0M2, #00H
0C32 759100    1324       mov P1M1, #00H
0C35 759200    1325       mov P1M2, #00H ; WARNING: P1.2 and P1.3 need 1kohm pull-up resistors!
0C38 75A400    1326       mov P2M1, #00H
0C3B 75A500    1327       mov P2M2, #00H
0C3E 75B100    1328       mov P3M1, #00H
0C41 75B200    1329       mov P3M2, #00H
0C44           1330       
0C44           1331       ;mov minutes, #0
0C44 755D00    1332            mov seconds, #0
0C47           1333   
0C47           1334      ; lcall LCD_4BIT
0C47           1335       ; For convenience a few handy macros are included in 'LCD_4bit_LPC9351.inc':
0C47 C0E0      1336            push acc
0C49 7401      1336            mov a, #1
0C4B 14        1336            dec a
0C4C 120368    1336            lcall ?Set_Cursor_1 ; Select column and row
0C4F D0E0      1336            pop acc
0C51 C000      1337            push ar0
0C53 A852      1337            mov r0, BCD_counter
0C55 12036D    1337            lcall ?Display_BCD
0C58 D000      1337            pop ar0
0C5A           1338   
0C5A D203      1339       setb half_seconds_flag
0C5C E4        1340       clr a
0C5D F54B      1341       mov Count1ms+0, a
0C5F F54C      1342       mov Count1ms+1, a    
0C61           1343   
0C61 755200    1344            mov BCD_counter, #0x00
0C64 754A00    1345            mov pwm , #0
0C67 754800    1346            mov sec , #0
0C6A 754500    1347            mov state, #0
0C6D 754796    1348            mov temp, #150
0C70 754205    1349       mov time_soak, #5
0C73 7543DC    1350       mov temp_refl, #220
0C76 754105    1351       mov temp_soak, #5
0C79 756000    1352       mov five_sec_flag,#0
0C7C           1353            ; After initialization the program stays in this 'forever' loop
0C7C           1354   
0C7C 755400    1355       mov reflow_sec, #0x00
0C7F 755500    1356       mov reflow_min, #0x00
0C82 755C00    1357       mov minutes, #0x00
0C85 754600    1358       mov state_lcd, #0
0C88 C208      1359       clr TR1_flag
0C8A 754D01    1360       mov reflow_temp+0, #0x01
0C8D 754E50    1361       mov reflow_temp+1, #0x50
0C90 C209      1362       clr tt_reflow_flag
0C92 755600    1363       mov soak_sec, #0x00
0C95 755700    1364       mov soak_min, #0x00
0C98           1365   
0C98 754F01    1366       mov soak_temp+0, #0x01
0C9B 755050    1367       mov soak_temp+1, #0x50
0C9E C20B      1368       clr stop_flag
0CA0           1369   
0CA0           1370       
0CA0           1371   forever:         
0CA0 120B4A    1372       lcall FSM_LCD
0CA3           1373   
0CA3 12067A    1374       lcall T2S_FSM
0CA6           1375            ; One second has passed, refresh the LCD with new time
0CA6           1376   ;        Set_Cursor(1, 1)
0CA6           1377   ;    Send_Constant_String(#timee)
0CA6           1378   ;    Set_Cursor(1, 5)
0CA6           1379   ;    Display_BCD(sec)
0CA6           1380   ;    Set_Cursor(2, 1)
0CA6           1381   ;    Send_Constant_String(#statee)
0CA6           1382   ;    Set_Cursor(2, 5)
0CA6           1383   ;    Display_BCD(BCD_counter)
0CA6           1384   
0CA6 20A630    1385            jb P2.6, done_loop
0CA9 C002      1385            push AR2
0CAB 7A0A      1385            mov R2, #10
0CAD 1202D7    1385            lcall ?Wait_Milli_Seconds
0CB0 D002      1385            pop AR2
0CB2 20A624    1385            jb P2.6, done_loop
0CB5 30A6FD    1385            jnb P2.6, $
0CB8           1385   
0CB8           1386   stop:
0CB8 C28E      1387        clr TR1
0CBA 120CB8    1388        lcall stop
0CBD C0E0      1389            push acc
0CBF 740E      1389            mov a, #14
0CC1 14        1389            dec a
0CC2 120368    1389            lcall ?Set_Cursor_1 ; Select column and row
0CC5 D0E0      1389            pop acc
0CC7 C083      1390            push dph
0CC9 C082      1390            push dpl
0CCB C0E0      1390            push acc
0CCD 9004C9    1390            mov dptr, #statee
0CD0 12035B    1390            lcall ?Send_Constant_String
0CD3 D0E0      1390            pop acc
0CD5 D082      1390            pop dpl
0CD7 D083      1390            pop dph
0CD9           1391        
0CD9           1392   done_loop:
0CD9           1393      
0CD9           1394   
0CD9 E560      1395       mov a, five_sec_flag
0CDB B4050A    1396       cjne a,#5, pass_quack
0CDE           1397       quack_like_a_duck:
0CDE C28E      1398       clr TR1 ; Stop timer 1.
0CE0 7400      1399       mov a,#0
0CE2 F560      1400       mov five_sec_flag,a
0CE4 C28E      1401       clr TR1 ; Stop timer 1.
0CE6 D200      1402            setb T2S_FSM_Start ; This plays the current minutes:seconds by making the state machine get out of state zero.
0CE8           1403       pass_hash:
0CE8           1404       pass_quack:
0CE8 D28E      1405       setb TR1 ; en timer 1.
0CEA           1406       
0CEA E545      1407       mov a, state
0CEC           1408     state0: 
0CEC B40013    1409         cjne a, #0, state1
0CEF 754A00    1410         mov pwm, #0
0CF2 C28E      1411         clr TR1
0CF4 20B008    1412         jb p3.0, state0_done
0CF7 30B0FD    1413         jnb p3.0, $ ;wait for key release
0CFA D28E      1414         setb TR1
0CFC 754501    1415         mov state, #1
0CFF           1416     state0_done:
0CFF 020CA0    1417         ljmp forever
0D02           1418      
0D02           1419      state1:
0D02 B40113    1420         cjne a, #1 , state2
0D05 754A64    1421         mov pwm, #100
0D08 754800    1422         mov sec, #0
0D0B E541      1423         mov a, temp_soak
0D0D C3        1424         clr c
0D0E 9547      1425         subb a, temp
0D10           1426         ;add branches to compare temp with 150
0D10 5003      1427         jnc state1_done
0D12 754502    1428         mov state, #2
0D15           1429     state1_done:
0D15 020CA0    1430          ljmp forever
0D18           1431          
0D18           1432     state2: ;press p3.0 multiple time plz cos it is stuck
0D18 B40210    1433         cjne a, #2 , state3
0D1B 754A14    1434         mov pwm, #20
0D1E E542      1435         mov a, time_soak
0D20 C3        1436         clr c
0D21 9548      1437         subb a, sec
0D23           1438         ;add branches to compare sec with  60
0D23 5003      1439         jnc state2_done
0D25 754503    1440         mov state, #3
0D28           1441     state2_done:
0D28 020CA0    1442          ljmp forever          
0D2B           1443     
0D2B           1444     state3:
0D2B B40313    1445         cjne a, #3 , state4
0D2E 754A50    1446         mov pwm, #80
0D31 754800    1447         mov sec, #0     
0D34 E543      1448         mov a, temp_refl
0D36 C3        1449         clr c
0D37 9547      1450         subb a, temp
0D39           1451         ;add branches to compare temp with 220
0D39 5003      1452         jnc state3_done
0D3B 754504    1453         mov state, #4
0D3E           1454     state3_done:
0D3E 020CA0    1455          ljmp forever
0D41           1456          
0D41           1457      state4:
0D41 B40410    1458         cjne a, #4 , state5
0D44 754A14    1459         mov pwm, #20
0D47 E544      1460         mov a, time_refl
0D49 C3        1461         clr c
0D4A 9548      1462         subb a, sec
0D4C           1463         ;add branches to compare sec with 45
0D4C 5003      1464         jnc state4_done
0D4E 754505    1465         mov state, #5
0D51           1466     state4_done:
0D51 020CA0    1467          ljmp forever    
0D54           1468          
0D54           1469      state5:
0D54 B40595    1470         cjne a, #5 , state0
0D57 754A00    1471         mov pwm, #0
0D5A C3        1472         clr c
0D5B 9547      1473         subb a, temp
0D5D           1474         ;add branches to compare temp with 60
0D5D 5003      1475         jnc state5_done
0D5F 754500    1476         mov state, #0
0D62           1477     state5_done:
0D62 020CA0    1478          ljmp forever 
0D65           1479          
0D65           1480   
0D65           1481   EN
