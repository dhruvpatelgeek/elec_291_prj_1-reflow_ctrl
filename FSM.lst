0000              1   ; ISR_example.asm: a) Increments/decrements a BCD variable every half second using
0000              2   ; an ISR for timer 2; b) Generates a 2kHz square wave at pin P3.7 using
0000              3   ; an ISR for timer 0; and c) in the 'main' loop it displays the variable
0000              4   ; incremented/decremented using the ISR for timer 2 on the LCD.  Also resets it to 
0000              5   ; zero if the 'CLEAR' pushbutton connected to P1.7 is pressed.
0000              6   ; Start/Constants
                  8       $LIST
0000             10   
0000             11       CLK           EQU 7373000  ; Microcontroller system crystal frequency in Hz
0000             12       TIMER0_RATE   EQU 100     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0000             13       TIMER0_RELOAD EQU ((65536-(CLK/(2*TIMER0_RATE))))
0000             14       TIMER1_RATE   EQU 100     ; 100Hz, for a timer tick of 10ms
0000             15       TIMER1_RELOAD EQU ((65536-(CLK/(2*TIMER1_RATE))))
0000             16   
0000             17   
0000             18   
0000             19       CCU_RATE    EQU 11025     ; 22050Hz is the sampling rate of the wav file we are playing
0000             20       CCU_RELOAD  EQU ((65536-((CLK/(2*CCU_RATE)))))
0000             21       BAUD        EQU 115200
0000             22       BRVAL       EQU ((CLK/BAUD)-16)
0000             23   
0000             24   
0000             25   
0000             26       ; Commands supported by the SPI flash memory according to the datasheet
0000             27       WRITE_ENABLE     EQU 0x06  ; Address:0 Dummy:0 Num:0
0000             28       WRITE_DISABLE    EQU 0x04  ; Address:0 Dummy:0 Num:0
0000             29       READ_STATUS      EQU 0x05  ; Address:0 Dummy:0 Num:1 to infinite
0000             30       READ_BYTES       EQU 0x03  ; Address:3 Dummy:0 Num:1 to infinite
0000             31       READ_SILICON_ID  EQU 0xab  ; Address:0 Dummy:3 Num:1 to infinite
0000             32       FAST_READ        EQU 0x0b  ; Address:3 Dummy:1 Num:1 to infinite
0000             33       WRITE_STATUS     EQU 0x01  ; Address:0 Dummy:0 Num:1
0000             34       WRITE_BYTES      EQU 0x02  ; Address:3 Dummy:0 Num:1 to 256
0000             35       ERASE_ALL        EQU 0xc7  ; Address:0 Dummy:0 Num:0
0000             36       ERASE_BLOCK      EQU 0xd8  ; Address:3 Dummy:0 Num:0
0000             37       READ_DEVICE_ID   EQU 0x9f  ; Address:0 Dummy:2 Num:1 to infinite
0000             38   ;Vectors
0000             39       ; Reset vector
0000             40       org 0x0000
0000 020C34      41           ljmp main
0003             42   
0003             43       ; External interrupt 0 vector (not used in this code)
0003             44       org 0x0003
0003 32          45           reti
0004             46   
0004             47       ; Timer/Counter 0 overflow interrupt vector
000B             48       org 0x000B
000B 020460      49           ljmp Timer0_ISR
000E             50   
000E             51       ; External interrupt 1 vector (not used in this code)
0013             52       org 0x0013
0013 32          53           reti
0014             54   
0014             55       ; Timer/Counter 1 overflow interrupt vector
001B             56       org 0x001B
001B 02048B      57           ljmp Timer1_ISR
001E             58   
001E             59       ; Serial port receive/transmit interrupt vector (not used in this code)
0023             60       org 0x0023 
0023 32          61           reti
0024             62   
005B             63       org 0x005b ; CCU interrupt vector.  Used in this code to replay the wave file.
005B 0204EF      64           ljmp CCU_ISR
005E             65   
005E             66   
005E             67       ;                                                        -                     
005E             68       ;                                                       -  -                    
005E             69       ;                                                      -    -                   
005E             70       ;                              leave it at this temp>>-      -                  
005E             71       ;                                                    -        -                 
005E             72       ;                                                   -          -                 
005E             73       ;                                                  -            -               
005E             74       ;                                                 -              -              
005E             75       ;                                                -                -             
005E             76       ;                                               -                  -            
005E             77       ;                                              -                    -           
005E             78       ;                                             -    reflow>>cool     -          
005E             79       ;               -----------------------------    (temperature only)  -         
005E             80       ;              -     soak (time+temp)                                 -        
005E             81       ;             -                                                        -       
005E             82       ;            -                                                          -       
005E             83       ;          -                                                             -      
005E             84       ;         -                                                               -     
005E             85       ;        -                                                                 -    
005E             86       ;      -                                                                    -    
005E             87       ;     - ramp to soak (temperature)                                           -   
005E             88       ;   -                                                                         -   
005E             89       ;   state 1 ((temp==soak)? ssr_off: ssr_on)
005E             90       ;          state 2 ((time=soak_time)?(pwm_off):(pwn_on)
005E             91       ;                                           state 3 ((temp==soak)? ssr_off: ssr_on)
005E             92       ;                                                        state 4 (cooling ssr_off)
005E             93       ;                                                                             state 5 (done)
005E             94   
005E             95       ; In the 8051 we can define direct access variables starting at location 0x30 up to location 0x7F
005E             96   ;Variables(dseg) 
0030             97       dseg at 0x30
0030             98   
0030             99       Result:    ds 4
0034            100       x:         ds 4
0038            101       y:         ds 4
003C            102       bcd:       ds 5
0041            103       ;FSM varialbles
0041            104       temp_soak: ds 1 ; temp to soak
0042            105       time_soak: ds 1 ; time to soak
0043            106       temp_refl: ds 1 ; temp of relfow
0044            107       time_refl: ds 1 ; time to reflow 
0045            108       state: ds 1 ; current state 
0046            109       state_lcd: ds 1
0047            110       temp: ds 1 ; current temp in degree C
0048            111       sec: ds 1 ; current time in seconds 
0049            112       product: ds 1; pwm-currsec
004A            113       pwm: ds 1 ; 
004B            114   
004B            115       ;Timer variables
004B            116       Count1ms:     ds 2 ; Used to determine when half second has passed
004D            117       reflow_temp:  ds 2
004F            118       soak_temp:    ds 2
0051            119       reflow_temp_var: ds 1
0052            120       BCD_counter:  ds 1 ; The BCD counter incrememted in the ISR and displayed in the main loop
0053            121       hour:         ds 1
0054            122       reflow_sec:   ds 1
0055            123       reflow_min:   ds 1
0056            124       soak_sec:     ds 1
0057            125       soak_min:     ds 1
0058            126       Count10ms:    ds 1 ; Used to determine when half second has passed
0059            127       Count10ms2:    ds 1
005A            128       w:             ds 3 ; 24-bit play counter.  Decremented in CCU ISR.
005D            129       minutes:       ds 1
005E            130       seconds:       ds 1
005F            131       T2S_FSM_state: ds 1
0060            132       Count5ms:      ds 1
0061            133       five_sec_flag:  ds 1
0062            134   
0062            135   ;flags(bseg)
0000            136       BSEG
0000            137       T2S_FSM_start:     dbit 1
0001            138       seconds_flag:      dbit 1
0002            139       mf:                dbit 1
0003            140       half_seconds_flag: dbit 1 ; Set to one in the ISR every time 500 ms had passed
0004            141       AMPM_flag:         dbit 1
0005            142       alarm_AMPM_flag:   dbit 1
0006            143       on_off_flag:       dbit 1 ; 1 is on
0007            144       alarm_buzzer_flag: dbit 1
0008            145       TR1_flag:          dbit 1
0009            146       tt_reflow_flag:    dbit 1
000A            147       tt_flag_soak:      dbit 1
000B            148       stop_flag:         dbit 1
000C            149       my_flag:           dbit 1
000D            150   
000D            151       ;_ _ _ _ | _ _ _ _ _ _
000D            152       ;
000D            153       ;pwm = 40 (say)
000D            154       ;then output will be 100 
000D            155       ;_________
000D            156       ;         |
000D            157       ;         |_____________
000D            158       ; where period is 1 second 
000D            159       ; In the 8051 we have variables that are 1-bit in size.  We can use the setb, clr, jb, and jnb
000D            160       ; instructions with these variables.  This is how you define a 1-bit variable:
000D            161   
000D            162   ;Pin config(cseg)
000D            163   
005E            164       cseg
005E            165       ; These 'equ' must match the wiring between the microcontroller and the LCD!
005E            166       LCD_RS equ P0.5
005E            167       LCD_RW equ P0.6
005E            168       LCD_E  equ P0.7
005E            169       LCD_D4 equ P1.2
005E            170       LCD_D5 equ P1.3
005E            171       LCD_D6 equ P1.4
005E            172       LCD_D7 equ P1.6
005E            173   
005E            174       CLEAR         equ P3.0
005E            175    ;   SOUND_OUT     equ P2.7
005E            176    ;   UPDOWN        equ P2.4
005E            177   
005E            178       FLASH_CE    EQU P2.4
005E            179       SOUND       EQU P2.7
005E            180       
005E            181       SETUP_SOAK_Button equ  P2.1
005E            182       set_BUTTON        equ  P2.0
005E            183       Button_min    equ  P2.6
005E            184       HOME_BUTTON   equ  P2.7
005E            185   
005E            186   
005E            187    ;start         equ P0.7
005E            188   
005E            189   ;include files
                546   $LIST
                192   	    $LIST
0399            194   ;Strings
0399            195     ;                       1234567890123456
0399            196      ;General
0399 0D0A00     197       Newline:          db   '\r', '\n', 0
039C 20202020   198       Space:            db   '      ','\r', '\n', 0
     20200D0A
     00
03A5 20202020   199       nothing:          db '                ',0      
     20202020
     20202020
     20202020
     00
03B6 20202020   200       test2:            db '      Test2     ',0
     20205465
     73743220
     20202020
     00
03C7 20202020   201       hot:                           db '      HOT       ', 0
     2020484F
     54202020
     20202020
     00
03D8 3A00       202       dots:             db ':',0
03DA 4243445F   203       Initial_Message:  db 'BCD_counter: xx ', 0
     636F756E
     7465723A
     20787820
     00
03EB            204      ;Home page
03EB 54656D70   205       Temp0:            db 'Temp:xxxC       ', 0
     3A787878
     43202020
     20202020
     00
03FC 54696D65   206       Time:             db 'Time xx:xx SET  ', 0
     2078783A
     78782053
     45542020
     00
040D            207      ;Second Page
040D 2020534F   208       soak_reflw:       db '  SOAK  REFLOW  ', 0
     414B2020
     5245464C
     4F572020
     00
041E            209      ;Reflow Setup
041E 54656D70   210       reflow_setup:     db 'Temp',0
     00
0423 2A524546   211       reflow_setup4:    db '*REFLOW*',0
     4C4F572A
     00
042C 54696D65   212       reflow_setup2:    db 'Time',0
     00
0431 484F4D45   213       reflow_setup3:    db 'HOME',0
     00
0436            214      ;Soak Setup
0436 54656D70   215       soak_setup0:      db 'Temp',0
     00
043B 202A534F   216       soak_setup1:      db ' *SOAK*',0
     414B2A00
0443 54696D65   217       soak_setup2:      db 'Time',0
     00
0448 484F4D45   218       soak_setup3:      db 'HOME',0
     00
044D            219   
044D            220   ;------ISR-------;
044D            221       ;---------------------------------;
044D            222       ; Routine to initialize the ISR   ;
044D            223       ; for timer 0                     ;
044D            224       ;---------------------------------;
044D            225       Timer0_Init:
044D E589       226           mov a, TMOD
044F 54F0       227           anl a, #0xf0 ; Clear the bits for timer 0
0451 4401       228           orl a, #0x01 ; Configure timer 0 as 16-timer
0453 F589       229           mov TMOD, a
0455 758C6F     230           mov TH0, #high(TIMER0_RELOAD)
0458 758AFF     231           mov TL0, #low(TIMER0_RELOAD)
045B            232           ; Enable the timer and interrupts
045B D2A9       233           setb ET0  ; Enable timer 0 interrupt
045D D28C       234           setb TR0  ; Start timer 0
045F 22         235           ret
0460            236   
0460            237       ;---------------------------------;
0460            238       ; ISR for timer 0.  Set to execute;
0460            239       ; every 1/4096Hz to generate a    ;
0460            240       ; 2048 Hz square wave at pin P3.7 ;
0460            241       ;---------------------------------;
0460            242       Timer0_ISR:
0460 758C6F     243           mov TH0, #high(TIMER0_RELOAD)
0463 758AFF     244           mov TL0, #low(TIMER0_RELOAD)
0466            245       ;    cpl SOUND_OUT ; Connect speaker to this pin
0466 C0E0       246           push acc
0468 C0D0       247           push psw
046A            248           
046A 0559       249           inc Count10ms2
046C E559       250           mov a, Count10ms2
046E B4C802     251           cjne a, #200, Timer0_ISR_done 
0471 D20C       252           setb my_flag 
0473            253   
0473            254            Timer0_ISR_done:
0473 D0D0       255           pop psw
0475 D0E0       256           pop acc
0477 32         257           reti
0478            258   
0478            259       ;---------------------------------;
0478            260       ; Routine to initialize the ISR   ;
0478            261       ; for timer 1                     ;
0478            262       ;---------------------------------;
0478            263       Timer1_Init:
0478 E589       264           mov a, TMOD
047A 540F       265           anl a, #0x0f ; Clear the bits for timer 1
047C 4410       266           orl a, #0x10 ; Configure timer 1 as 16-timer
047E F589       267           mov TMOD, a
0480 758D6F     268           mov TH1, #high(TIMER1_RELOAD)
0483 758BFF     269           mov TL1, #low(TIMER1_RELOAD)
0486            270           ; Enable the timer and interrupts
0486 D2AB       271           setb ET1  ; Enable timer 1 interrupt
0488 D28E       272           setb TR1  ; Start timer 1
048A 22         273           ret
048B            274   
048B            275       ;---------------------------------;
048B            276       ; ISR for timer 1                 ;
048B            277       ;---------------------------------;
048B            278       Timer1_ISR:
048B 758D6F     279           mov TH1, #high(TIMER1_RELOAD)
048E 758BFF     280           mov TL1, #low(TIMER1_RELOAD)
0491            281         ;  cpl P2.6 ; To check the interrupt rate with oscilloscope. It must be precisely a 10 ms pulse.
0491            282           
0491            283           ; The two registers used in the ISR must be saved in the stack
0491 C0E0       284           push acc
0493 C0D0       285           push psw
0495            286           
0495            287    
0495            288           ; Increment the 8-bit 10-mili-second counter
0495 0558       289           inc Count10ms
0497            290           ; Increment the 16-bit one mili second counter
0497            291   
0497            292   
0497            293       Inc_Done:
0497 E558       294           mov a, Count10ms
0499 954A       295           subb a, pwm ; if pwm greater than a pwm is on else off
049B D4         296           da a
049C            297          ; mov a, product
049C 5005       298           jnc off_segment
049E D281       299           setb p0.1
04A0 C3         300           clr c
04A1 8005       301           sjmp pass
04A3            302           off_segment:
04A3 C281       303           clr p0.1
04A5 C3         304           clr c
04A6 8000       305           sjmp pass
04A8            306   
04A8            307           ; Check if 1 second has passed
04A8            308           pass:
04A8            309   
04A8            310           ; Check if half second has passed
04A8 E558       311           mov a, Count10ms
04AA B4C81F     312           cjne a, #200, Timer1_ISR_done ; Warning: this instruction changes the carry flag!
04AD            313           ;----------------------------
04AD 0548       314           inc sec ; one second has passed
04AF E548       315           mov a,sec
04B1 D4         316           da a
04B2 F548       317           mov sec,a
04B4            318   
04B4 0561       319           inc five_sec_flag ; one second has passed
04B6 E561       320           mov a,five_sec_flag
04B8 D4         321           da a
04B9 F561       322           mov five_sec_flag,a
04BB            323   
04BB E548       324           mov a,sec
04BD            325          ; mov minutes, #0
04BD            326   
04BD 85E05E     327           mov seconds, acc
04C0            328   
04C0            329           
04C0            330           ;----------------------------
04C0            331           ; 500 milliseconds have passed.  Set a flag so the main program knows
04C0 D203       332           setb half_seconds_flag ; Let the main program know half second had passed
04C2            333        ;   cpl TR0 ; Enable/disable timer/counter 0. This line creates a beep-silence-beep-silence sound.
04C2            334           ; Reset to zero the 10-milli-seconds counter, it is a 8-bit variable
04C2 755800     335           mov Count10ms, #0x0
04C5            336      ;     mov Count1ms, #0x00
04C5            337           ; Increment the BCD counter
04C5 E552       338           mov a, BCD_counter
04C7            339       ;    jnb UPDOWN, Timer1_ISR_decrement
04C7 2401       340           add a, #0x01
04C9            341       ;    sjmp Timer1_ISR_da
04C9            342       ;Timer1_ISR_decrement:
04C9            343           ;add a, #0x99 ; Adding the 10-complement of -1 is like subtracting 1.
04C9            344       Timer1_ISR_da:
04C9 D4         345           da a ; Decimal adjust instruction.  Check datasheet for more details!
04CA F552       346           mov BCD_counter, a
04CC            347           
04CC            348       Timer1_ISR_done:
04CC D0D0       349           pop psw
04CE D0E0       350           pop acc
04D0 32         351           reti
04D1            352   
04D1            353   
04D1            354   
04D1 74696D65   355       timee:  db 'time', 0
     00
04D6 3100       356       statee:  db '1', 0
04D8            357   
04D8            358   
04D8            359       ;------------------------------
04D8            360       ;---------------------------------;
04D8            361       ; Routine to initialize the CCU.  ;
04D8            362       ; We are using the CCU timer in a ;
04D8            363       ; manner similar to the timer 2   ;
04D8            364       ; available in other 8051s        ;
04D8            365       ;---------------------------------;
04D8            366       CCU_Init:
04D8 75CDFE     367           mov TH2, #high(CCU_RELOAD)
04DB 75CCB2     368           mov TL2, #low(CCU_RELOAD)
04DE 75CFFE     369           mov TOR2H, #high(CCU_RELOAD)
04E1 75CEB2     370           mov TOR2L, #low(CCU_RELOAD)
04E4 75F980     371           mov TCR21, #10000000b ; Latch the reload value
04E7 75C980     372           mov TICR2, #10000000b ; Enable CCU Timer Overflow Interrupt
04EA D2EC       373           setb ECCU ; Enable CCU interrupt
04EC D2C8       374           setb TMOD20 ; Start CCU timer
04EE 22         375           ret
04EF            376   
04EF            377       ;---------------------------------;
04EF            378       ; ISR for CCU.  Used to playback  ;
04EF            379       ; the WAV file stored in the SPI  ;
04EF            380       ; flash memory.                   ;
04EF            381       ;---------------------------------;
04EF            382       CCU_ISR:
04EF 75E900     383           mov TIFR2, #0 ; Clear CCU Timer Overflow Interrupt Flag bit. Actually, it clears all the bits!
04F2            384           
04F2            385           ; The registers used in the ISR must be saved in the stack
04F2 C0E0       386           push acc
04F4 C0D0       387           push psw
04F6            388           
04F6            389           ; Check if the play counter is zero.  If so, stop playing sound.
04F6 E55A       390           mov a, w+0
04F8 455B       391           orl a, w+1
04FA 455C       392           orl a, w+2
04FC 601D       393           jz stop_playing
04FE            394           
04FE            395           ;;yolo this is gonna fuck with the speaker
04FE            396           ; Increment the 16-bit one mili second counter
04FE 054B       397           inc Count1ms+0    ; Increment the low 8-bits first
0500 E54B       398           mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
0502 7093       399           jnz Inc_Done
0504 054C       400           inc Count1ms+1
0506            401           ; Decrement play counter 'w'.  In this implementation 'w' is a 24-bit counter.
0506 74FF       402           mov a, #0xff
0508 155A       403           dec w+0
050A B55A07     404           cjne a, w+0, keep_playing
050D 155B       405           dec w+1
050F B55B02     406           cjne a, w+1, keep_playing
0512 155C       407           dec w+2
0514            408           
0514            409       keep_playing:
0514            410   
0514 120567     411           lcall Send_SPI ; Read the next byte from the SPI Flash...
0517 F5F5       412           mov AD1DAT3, a ; and send it to the DAC
0519            413           
0519 8006       414           sjmp CCU_ISR_Done
051B            415   
051B            416       stop_playing:
051B C2C8       417           clr TMOD20 ; Stop CCU timer
051D D2A4       418           setb FLASH_CE  ; Disable SPI Flash
051F C2A7       419           clr SOUND ; Turn speaker off
0521            420   
0521            421       CCU_ISR_Done:        
0521 D0D0       422           pop psw
0523 D0E0       423           pop acc
0525 32         424           reti
0526            425   ;----------------;
0526            426   
0526            427   ;---------------------------------;
0526            428   ; Initial configuration of ports. ;
0526            429   ; After reset the default for the ;
0526            430   ; pins is 'Open Drain'.  This     ;
0526            431   ; routine changes them pins to    ;
0526            432   ; Quasi-bidirectional like in the ;
0526            433   ; original 8051.                  ;
0526            434   ; Notice that P1.2 and P1.3 are   ;
0526            435   ; always 'Open Drain'. If those   ;
0526            436   ; pins are to be used as output   ;
0526            437   ; they need a pull-up resistor.   ;
0526            438   ;---------------------------------;
0526            439   Ports_Init:
0526            440       ; Configure all the ports in bidirectional mode:
0526 758400     441       mov P0M1, #00H
0529 758500     442       mov P0M2, #00H
052C 759100     443       mov P1M1, #00H
052F 759200     444       mov P1M2, #00H ; WARNING: P1.2 and P1.3 need 1 kohm pull-up resistors if used as outputs!
0532 75A400     445       mov P2M1, #00H
0535 75A500     446       mov P2M2, #00H
0538 75B100     447       mov P3M1, #00H
053B 75B200     448       mov P3M2, #00H
053E 22         449            ret
053F            450   
053F            451   ;---------------------------------;
053F            452   ; Initialize ADC1/DAC1 as DAC1.   ;
053F            453   ; Warning, the ADC1/DAC1 can work ;
053F            454   ; only as ADC or DAC, not both.   ;
053F            455   ; The P89LPC9351 has two ADC/DAC  ;
053F            456   ; interfaces.  One can be used as ;
053F            457   ; ADC and the other can be used   ;
053F            458   ; as DAC.  Also configures the    ;
053F            459   ; pin associated with the DAC, in ;
053F            460   ; this case P0.4 as 'Open Drain'. ;
053F            461   ;---------------------------------;
053F            462   InitDAC1:
053F            463       ; Configure pin P0.4 (DAC1 output pin) as open drain
053F 438410     464            orl     P0M1,   #00010000B
0542 438510     465            orl     P0M2,   #00010000B
0545 75A128     466       mov ADMODB, #00101000B ; Select main clock/2 for ADC/DAC.  Also enable DAC1 output (Table 25 of reference manual)
0548 759704     467            mov     ADCON1, #00000100B ; Enable the converter
054B 75F580     468            mov AD1DAT3, #0x80     ; Start value is 3.3V/2 (zero reference for AC WAV file)
054E 22         469            ret
054F            470   
054F            471   ;---------------------------------;
054F            472   ; Change the internal RC osc. clk ;
054F            473   ; from 7.373MHz to 14.746MHz.     ;
054F            474   ;---------------------------------;
054F            475   Double_Clk:
054F 90FFDE     476       mov dptr, #CLKCON
0552 E0         477       movx a, @dptr
0553 4408       478       orl a, #00001000B ; double the clock speed to 14.746MHz
0555 F0         479       movx @dptr,a
0556 22         480            ret
0557            481   
0557            482   ;---------------------------------;
0557            483   ; Initialize the SPI interface    ;
0557            484   ; and the pins associated to SPI. ;
0557            485   ;---------------------------------;
0557            486   Init_SPI:
0557            487            ; Configure MOSI (P2.2), CS* (P2.4), and SPICLK (P2.5) as push-pull outputs (see table 42, page 51)
0557 53A4CB     488            anl P2M1, #low(not(00110100B))
055A 43A534     489            orl P2M2, #00110100B
055D            490            ; Configure MISO (P2.3) as input (see table 42, page 51)
055D 43A408     491            orl P2M1, #00001000B
0560 53A5F7     492            anl P2M2, #low(not(00001000B)) 
0563            493            ; Configure SPI
0563 75E2D0     494            mov SPCTL, #11010000B ; Ignore /SS, Enable SPI, DORD=0, Master=1, CPOL=0, CPHA=0, clk/4
0566 22         495            ret
0567            496   
0567            497   ;---------------------------------;
0567            498   ; Sends AND receives a byte via   ;
0567            499   ; SPI.                            ;
0567            500   ;---------------------------------;
0567            501   Send_SPI:
0567 F5E3       502            mov SPDAT, a
0569            503   Send_SPI_1:
0569 E5E1       504            mov a, SPSTAT 
056B 30E7FB     505            jnb acc.7, Send_SPI_1 ; Check SPI Transfer Completion Flag
056E F5E1       506            mov SPSTAT, a ; Clear SPI Transfer Completion Flag
0570 E5E3       507            mov a, SPDAT ; return received byte via accumulator
0572 22         508            ret
0573            509   
0573            510   ;---------------------------------;
0573            511   ; SPI flash 'write enable'        ;
0573            512   ; instruction.                    ;
0573            513   ;---------------------------------;
0573            514   Enable_Write:
0573 C2A4       515            clr FLASH_CE
0575 7406       516            mov a, #WRITE_ENABLE
0577 120567     517            lcall Send_SPI
057A D2A4       518            setb FLASH_CE
057C 22         519            ret
057D            520   
057D            521   ;---------------------------------;
057D            522   ; This function checks the 'write ;
057D            523   ; in progress' bit of the SPI     ;
057D            524   ; flash memory.                   ;
057D            525   ;---------------------------------;
057D            526   Check_WIP:
057D C2A4       527            clr FLASH_CE
057F 7405       528            mov a, #READ_STATUS
0581 120567     529            lcall Send_SPI
0584 7455       530            mov a, #0x55
0586 120567     531            lcall Send_SPI
0589 D2A4       532            setb FLASH_CE
058B 20E0EF     533            jb acc.0, Check_WIP ;  Check the Write in Progress bit
058E 22         534            ret
058F            535            
058F            536   ; Display a binary number in the LCD (must be less than 99).  Number to display passed in accumulator.
058F            537   LCD_number:
058F C0E0       538            push acc
0591 75F00A     539            mov b, #10
0594 84         540            div ab
0595 4430       541            orl a, #'0'
0597 12031C     542            lcall ?WriteData
059A E5F0       543            mov a, b
059C 4430       544            orl a, #'0'
059E 12031C     545            lcall ?WriteData
05A1 D0E0       546            pop acc
05A3 22         547            ret
05A4            548   
05A4            549   ; Sounds we need in the SPI flash: 0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 30; 40; 50; minutes; seconds;
05A4            550   ; Approximate index of sounds in file 'stop_watch.wav'
05A4            551   ; This was generated using: computer_sender -Asw_index.asm -S2000 stop_watch.wav
05A4            552   sound_index:
05A4 00002D     553       db 0x00, 0x00, 0x2d ; 0 
05A7 003107     554       db 0x00, 0x31, 0x07 ; 1 
05AA 007007     555       db 0x00, 0x70, 0x07 ; 2 
05AD 00ADB9     556       db 0x00, 0xad, 0xb9 ; 3 
05B0 00F266     557       db 0x00, 0xf2, 0x66 ; 4 
05B3 0135D5     558       db 0x01, 0x35, 0xd5 ; 5 
05B6 017D33     559       db 0x01, 0x7d, 0x33 ; 6 
05B9 01C761     560       db 0x01, 0xc7, 0x61 ; 7 
05BC 021279     561       db 0x02, 0x12, 0x79 ; 8 
05BF 0249C1     562       db 0x02, 0x49, 0xc1 ; 9 
05C2 028F7A     563       db 0x02, 0x8f, 0x7a ; 10 
05C5 02D063     564       db 0x02, 0xd0, 0x63 ; 11 
05C8 031B87     565       db 0x03, 0x1b, 0x87 ; 12 
05CB 03630E     566       db 0x03, 0x63, 0x0e ; 13 
05CE 03B95F     567       db 0x03, 0xb9, 0x5f ; 14 
05D1 04113A     568       db 0x04, 0x11, 0x3a ; 15 
05D4 0466C4     569       db 0x04, 0x66, 0xc4 ; 16 
05D7 04C012     570       db 0x04, 0xc0, 0x12 ; 17 
05DA 052698     571       db 0x05, 0x26, 0x98 ; 18 
05DD 0574E9     572       db 0x05, 0x74, 0xe9 ; 19 
05E0 05D28E     573       db 0x05, 0xd2, 0x8e ; 20 
05E3 061D83     574       db 0x06, 0x1d, 0x83 ; 21 -> 30 
05E6 066342     575       db 0x06, 0x63, 0x42 ; 22 -> 40 
05E9 06AAB9     576       db 0x06, 0xaa, 0xb9 ; 23 -> 50 
05EC 06F3D6     577       db 0x06, 0xf3, 0xd6 ; 24 -> Minutes 
05EF 073F02     578       db 0x07, 0x3f, 0x02 ; 25 -> Seconds 
05F2            579   
05F2            580   ; Size of each sound in 'sound_index'
05F2            581   ; Generated using: computer_sender -Asw_index.asm -S2000 stop_watch.wav
05F2            582   Size_Length:
05F2 0030DA     583       db 0x00, 0x30, 0xda ; 0 
05F5 003F00     584       db 0x00, 0x3f, 0x00 ; 1 
05F8 003DB2     585       db 0x00, 0x3d, 0xb2 ; 2 
05FB 0044AD     586       db 0x00, 0x44, 0xad ; 3 
05FE 00436F     587       db 0x00, 0x43, 0x6f ; 4 
0601 00475E     588       db 0x00, 0x47, 0x5e ; 5 
0604 004A2E     589       db 0x00, 0x4a, 0x2e ; 6 
0607 004B18     590       db 0x00, 0x4b, 0x18 ; 7 
060A 003748     591       db 0x00, 0x37, 0x48 ; 8 
060D 0045B9     592       db 0x00, 0x45, 0xb9 ; 9 
0610 0040E9     593       db 0x00, 0x40, 0xe9 ; 10 
0613 004B24     594       db 0x00, 0x4b, 0x24 ; 11 
0616 004787     595       db 0x00, 0x47, 0x87 ; 12 
0619 005651     596       db 0x00, 0x56, 0x51 ; 13 
061C 0057DB     597       db 0x00, 0x57, 0xdb ; 14 
061F 00558A     598       db 0x00, 0x55, 0x8a ; 15 
0622 00594E     599       db 0x00, 0x59, 0x4e ; 16 
0625 006686     600       db 0x00, 0x66, 0x86 ; 17 
0628 004E51     601       db 0x00, 0x4e, 0x51 ; 18 
062B 005DA5     602       db 0x00, 0x5d, 0xa5 ; 19 
062E 004AF5     603       db 0x00, 0x4a, 0xf5 ; 20 
0631 0045BF     604       db 0x00, 0x45, 0xbf ; 21 -> 30
0634 004777     605       db 0x00, 0x47, 0x77 ; 22 -> 40
0637 00491D     606       db 0x00, 0x49, 0x1d ; 23 -> 50
063A 004B2C     607       db 0x00, 0x4b, 0x2c ; 24 -> minutes
063D 005C87     608       db 0x00, 0x5c, 0x87 ; 25 -> seconds
0640            609   
0640            610   ; The sound and its length from the two tables above is passed in the accumulator.
0640            611   Play_Sound_Using_Index:
0640 D2A7       612            setb SOUND ; Turn speaker on
0642 C2C8       613            clr TMOD20 ; Stop the CCU from playing previous request
0644 D2A4       614            setb FLASH_CE
0646            615            
0646            616            ; There are three bytes per row in our tables, so multiply index by three
0646 75F003     617            mov b, #3
0649 A4         618            mul ab
064A F8         619            mov R0, a ; Make a copy of the index*3
064B            620            
064B C2A4       621            clr FLASH_CE ; Enable SPI Flash
064D 7403       622            mov a, #READ_BYTES
064F 120567     623            lcall Send_SPI
0652            624            ; Set the initial position in memory of where to start playing
0652 9005A4     625            mov dptr, #sound_index
0655 E8         626            mov a, R0
0656 93         627            movc a, @a+dptr
0657 120567     628            lcall Send_SPI
065A A3         629            inc dptr
065B E8         630            mov a, R0
065C 93         631            movc a, @a+dptr
065D 120567     632            lcall Send_SPI
0660 A3         633            inc dptr
0661 E8         634            mov a, R0
0662 93         635            movc a, @a+dptr
0663 120567     636            lcall Send_SPI
0666            637            ; Now set how many bytes to play
0666 9005F2     638            mov dptr, #Size_Length
0669 E8         639            mov a, R0
066A 93         640            movc a, @a+dptr
066B F55C       641            mov w+2, a
066D A3         642            inc dptr
066E E8         643            mov a, R0
066F 93         644            movc a, @a+dptr
0670 F55B       645            mov w+1, a
0672 A3         646            inc dptr
0673 E8         647            mov a, R0
0674 93         648            movc a, @a+dptr
0675 F55A       649            mov w+0, a
0677            650            
0677 7400       651            mov a, #0x00 ; Request first byte to send to DAC
0679 120567     652            lcall Send_SPI
067C            653            
067C D2C8       654            setb TMOD20 ; Start playback by enabling CCU timer
067E            655   
067E 22         656            ret
067F            657    ; Send a character using the serial port
067F            658   putchar:
067F 3099FD     659           jnb TI, putchar 
0682            660           ; TI serial interrupt flag is set and when last bit (stop bit) 
0682            661           ; of receiving data byte is received, RI flag get set. IE register
0682            662           ; is used to enable/disable interrupt sources.
0682 C299       663           clr TI
0684 F599       664           mov SBUF, a
0686 22         665           ret
0687            666   
0687            667   ;---------------------------------------------------------------------------------;
0687            668   ; This is the FSM that plays minutes and seconds after the STOP button is pressed ;
0687            669   ; The state diagram of this FSM is available as 'Stop_Watch_FSM.pdf'              ;
0687            670   ;---------------------------------------------------------------------------------;
0687            671   T2S_FSM:
0687 E55F       672            mov a, T2S_FSM_state
0689            673   
0689            674   T2S_FSM_State0: ; Checks for the start signal (T2S_FSM_Start==1)
0689 B40013     675            cjne a, #0, T2S_FSM_State1
068C 30000F     676            jnb T2S_FSM_Start, T2S_FSM_State0_Done
068F            677            ; Check if minutes is larger than 19
068F C3         678            clr c
0690 E55D       679            mov a, minutes
0692 9414       680            subb a, #20
0694 5005       681            jnc minutes_gt_19
0696 755F01     682            mov T2S_FSM_state, #1
0699 8003       683            sjmp T2S_FSM_State0_Done
069B            684   minutes_gt_19:
069B 755F03     685            mov T2S_FSM_state, #3
069E            686   T2S_FSM_State0_Done:
069E 22         687            ret
069F            688            
069F            689   T2S_FSM_State1: ; Plays minutes when minutes is less than 20
069F B40109     690            cjne a, #1, T2S_FSM_State2
06A2 E55D       691            mov a, minutes
06A4 120640     692            lcall Play_Sound_Using_Index
06A7 755F02     693            mov T2S_FSM_State, #2
06AA 22         694            ret 
06AB            695   
06AB            696   T2S_FSM_State2: ; Stay in this state until sound finishes playing
06AB B40207     697            cjne a, #2, T2S_FSM_State3
06AE 20C803     698            jb TMOD20, T2S_FSM_State2_Done 
06B1 755F06     699            mov T2S_FSM_State, #6
06B4            700   T2S_FSM_State2_Done:
06B4 22         701            ret
06B5            702   
06B5            703   T2S_FSM_State3: ; Plays the tens when minutes is larger than 19, for example for 42 minutes, it plays 'forty'
06B5 B4030F     704            cjne a, #3, T2S_FSM_State4
06B8 E55D       705            mov a, minutes
06BA 75F00A     706            mov b, #10
06BD 84         707            div ab
06BE 2412       708            add a, #18
06C0 120640     709            lcall Play_Sound_Using_Index
06C3 755F04     710            mov T2S_FSM_State, #4
06C6 22         711            ret
06C7            712   
06C7            713   T2S_FSM_State4: ; Stay in this state until sound finishes playing
06C7 B40407     714            cjne a, #4, T2S_FSM_State5
06CA 20C803     715            jb TMOD20, T2S_FSM_State4_Done 
06CD 755F05     716            mov T2S_FSM_State, #5
06D0            717   T2S_FSM_State4_Done:
06D0 22         718       ret
06D1            719   
06D1            720   T2S_FSM_State5: ; Plays the units when minutes is larger than 19, for example for 42 minutes, it plays 'two'
06D1 B40511     721            cjne a, #5, T2S_FSM_State6
06D4 E55D       722            mov a, minutes
06D6 75F00A     723            mov b, #10
06D9 84         724            div ab
06DA E5F0       725            mov a, b
06DC 6003       726            jz T2S_FSM_State5_Done ; Prevents from playing something like 'forty zero'
06DE 120640     727            lcall Play_Sound_Using_Index
06E1            728   T2S_FSM_State5_Done:
06E1 755F02     729            mov T2S_FSM_State, #2
06E4 22         730            ret
06E5            731   
06E5            732   T2S_FSM_State6: ; Plays the word 'minutes'
06E5 B40609     733            cjne a, #6, T2S_FSM_State7
06E8 7418       734            mov a, #24 ; Index 24 has the word 'minutes'
06EA 120640     735            lcall Play_Sound_Using_Index
06ED 755F07     736            mov T2S_FSM_State, #7
06F0 22         737            ret
06F1            738   
06F1            739   T2S_FSM_State7: ; Stay in this state until sound finishes playing
06F1 B40713     740            cjne a, #7, T2S_FSM_State8
06F4 20C80F     741            jb TMOD20, T2S_FSM_State7_Done 
06F7            742            ; Done playing previous sound, check if seconds is larger than 19
06F7 C3         743            clr c
06F8 E55E       744            mov a, seconds
06FA 9414       745            subb a, #20
06FC 5005       746            jnc seconds_gt_19
06FE 755F08     747            mov T2S_FSM_state, #8
0701 809B       748            sjmp T2S_FSM_State0_Done
0703            749   seconds_gt_19:
0703 755F0A     750            mov T2S_FSM_state, #10
0706            751   T2S_FSM_State7_Done:
0706 22         752       ret
0707            753   
0707            754   T2S_FSM_State8: ; Play the seconds when seconds is less than 20.
0707 B40809     755            cjne a, #8, T2S_FSM_State9
070A E55E       756            mov a, seconds
070C 120640     757            lcall Play_Sound_Using_Index
070F 755F09     758            mov T2S_FSM_state, #9
0712 22         759            ret
0713            760   
0713            761   T2S_FSM_State9: ; Stay in this state until sound finishes playing
0713 B40907     762            cjne a, #9, T2S_FSM_State10
0716 20C803     763            jb TMOD20, T2S_FSM_State9_Done 
0719 755F0D     764            mov T2S_FSM_State, #13
071C            765   T2S_FSM_State9_Done:
071C 22         766            ret
071D            767   
071D            768   T2S_FSM_State10:  ; Plays the tens when seconds is larger than 19, for example for 35 seconds, it plays 'thirty'
071D B40A0F     769            cjne a, #10, T2S_FSM_State11
0720 E55E       770            mov a, seconds
0722 75F00A     771            mov b, #10
0725 84         772            div ab
0726 2412       773            add a, #18
0728 120640     774            lcall Play_Sound_Using_Index
072B 755F0B     775            mov T2S_FSM_state, #11
072E 22         776            ret
072F            777   
072F            778   T2S_FSM_State11: ; Stay in this state until sound finishes playing
072F B40B07     779            cjne a, #11, T2S_FSM_State12
0732 20C803     780            jb TMOD20, T2S_FSM_State11_Done 
0735 755F0C     781            mov T2S_FSM_State, #12
0738            782   T2S_FSM_State11_Done:
0738 22         783            ret
0739            784   
0739            785   T2S_FSM_State12: ; Plays the units when seconds is larger than 19, for example for 35 seconds, it plays 'five'
0739 B40C11     786            cjne a, #12, T2S_FSM_State13
073C E55E       787            mov a, seconds
073E 75F00A     788            mov b, #10
0741 84         789            div ab
0742 E5F0       790            mov a, b
0744 6003       791            jz T2S_FSM_State12_Done ; Prevents from saying something like 'thirty zero'
0746 120640     792            lcall Play_Sound_Using_Index
0749            793   T2S_FSM_State12_Done:
0749 755F09     794            mov T2S_FSM_State, #9
074C 22         795            ret
074D            796   
074D            797   T2S_FSM_State13: ; Plays the word 'seconds'
074D B40D09     798            cjne a, #13, T2S_FSM_State14
0750 7419       799            mov a, #25 ; Index 25 has the word 'seconds'
0752 120640     800            lcall Play_Sound_Using_Index
0755 755F0E     801            mov T2S_FSM_State, #14
0758 22         802            ret
0759            803   
0759            804   T2S_FSM_State14: ; Stay in this state until sound finishes playing
0759 B40E09     805            cjne a, #14, T2S_FSM_Error
075C 20C805     806            jb TMOD20, T2S_FSM_State14_Done 
075F C200       807            clr T2S_FSM_Start 
0761 755F00     808            mov T2S_FSM_State, #0
0764            809   T2S_FSM_State14_Done:
0764 22         810            ret
0765            811   
0765            812   T2S_FSM_Error: ; If we got to this point, there is an error in the finite state machine.  Restart it.
0765 755F00     813            mov T2S_FSM_state, #0
0768 C200       814            clr T2S_FSM_Start
076A 22         815            ret
076B            816       
076B            817   ;WaitHalfSec:
076B            818   ;        mov R2, #178
076B            819   ;        Lr3: mov R1, #250
076B            820   ;        Lr2: mov R0, #166
076B            821   ;        Lr1: djnz R0, Lr1 ; 3 cycles->3*45.21123ns*166=22.51519us
076B            822   ;        djnz R1, Lr2 ; 22.51519us*250=5.629ms
076B            823   ;        djnz R2, Lr3 ; 5.629ms*89=0.5s (approximately)
076B            824   ;        ret
076B            825   ;        
076B            826   ;blink:
076B            827   ;        mov SP, #7FH
076B            828   ;        mov P3M1, #0   ; Configure P3 in bidirectional mode
076B            829   ;    M0:
076B            830   ;        cpl P3.7
076B            831   ;        Set_Cursor(1, 1)
076B            832   ;        Send_Constant_String(#nothing)
076B            833   ;        Set_Cursor(2, 1)
076B            834   ;        Send_Constant_String(#nothing)
076B            835   ;        Set_Cursor(1, 1)
076B            836   ;        Send_Constant_String(#hot)
076B            837   ;        Set_Cursor(2, 1)
076B            838   ;        Send_Constant_String(#hot)
076B            839   ;
076B            840   ;        lcall WaitHalfSec
076B            841   ;
076B            842   ;        ret
076B            843   ;
076B            844   ;convert:
076B            845   ;    mov x+0, Result
076B            846   ;        mov x+1, Result+1 
076B            847   ;        mov x+2, #0
076B            848   ;        mov x+3, #0
076B            849   ;    ret
076B            850   ;    
076B            851   ;
076B            852   Display_temp:
076B            853   ;    Load_y(410)
076B            854   ;    lcall mul32
076B            855   ;    Load_y(1023)
076B            856   ;    lcall div32
076B            857   ;    Load_y(273)
076B            858   ;    lcall sub32
076B            859   ;    lcall hex2bcd
076B            860   ;    lcall InitSerialPort
076B C0E0       861            push acc
076D 7401       861            mov a, #1
076F 14         861            dec a
0770 120368     861            lcall ?Set_Cursor_1 ; Select column and row
0773 D0E0       861            pop acc
0775 C083       862            push dph
0777 C082       862            push dpl
0779 C0E0       862            push acc
077B 9003EB     862            mov dptr, #Temp0
077E 12035B     862            lcall ?Send_Constant_String
0781 D0E0       862            pop acc
0783 D082       862            pop dpl
0785 D083       862            pop dph
0787            863   ;    lcall SendString
0787            864   ;    Set_Cursor(1, 5)    
0787            865   ;    Send_BCD(bcd+1) ; send fisrt 2 digits to putty
0787            866   ;    Display_BCD(bcd+1); send fisrt 2 digits to lcd
0787            867   ;    Set_Cursor(1, 7) 
0787            868   ;    Send_BCD(bcd) ; send last 2 digits to putty
0787            869   ;    Display_BCD(bcd+0) ; send last 2 digits to lcd
0787            870   ;    Set_Cursor(1, 5)
0787            871   ;    Send_Constant_String(#dots)
0787            872   ;    lcall SendString
0787            873   ;    mov DPTR, #Newline
0787            874   ;    lcall SendString
0787 22         875       ret
0788            876   ;config_adc:
0788            877   ;        clr CE_ADC 
0788            878   ;        mov R0, #00000001B; Start bit:1 
0788            879   ;        lcall DO_SPI_G
0788            880   ;
0788            881   ;        mov R0, #10000000B; Single ended, read channel 0 
0788            882   ;        lcall DO_SPI_G 
0788            883   ;        mov a, R1          ; R1 contains bits 8 and 9 
0788            884   ;        anl a, #00000011B  ; We need only the two least significant bits 
0788            885   ;        mov Result+1, a    ; Save result high.
0788            886   ;
0788            887   ;        mov R0, #55H; It doesn't matter what we transmit... 
0788            888   ;        lcall DO_SPI_G 
0788            889   ;        mov Result, R1     ; R1 contains bits 0 to 7.  Save result low. 
0788            890   ;        setb CE_ADC 
0788            891   ;        lcall convert  
0788            892   ;        mov a, bcd ; move temp to accumulator 
0788            893   ;        ret
0788            894   Reset_timer:
0788            895   
0788 C28E       896       clr TR1                 ; Stop timer 2
078A E4         897       clr a
078B F54B       898            mov Count1ms+0, a
078D F54C       899            mov Count1ms+1, a
078F            900            ; Now clear the BCD counter and minutes
078F F552       901            mov BCD_counter, a
0791 D28E       902            setb TR1                ; Start timer 2
0793            903   
0793 22         904       ret
0794            905   Display_time:
0794 C0E0       906            push acc
0796 7401       906            mov a, #1
0798 14         906            dec a
0799 120366     906            lcall ?Set_Cursor_2 ; Select column and row
079C D0E0       906            pop acc
079E C083       907            push dph
07A0 C082       907            push dpl
07A2 C0E0       907            push acc
07A4 9003FC     907            mov dptr, #Time
07A7 12035B     907            lcall ?Send_Constant_String
07AA D0E0       907            pop acc
07AC D082       907            pop dpl
07AE D083       907            pop dph
07B0 C203       908       clr half_seconds_flag ; We clear this flag in the main loop, but it is set in the ISR for timer 2
07B2 C20C       909       clr my_flag
07B4 C0E0       910            push acc
07B6 7409       910            mov a, #9
07B8 14         910            dec a
07B9 120366     910            lcall ?Set_Cursor_2 ; Select column and row
07BC D0E0       910            pop acc     ; the place in the LCD where we want the BCD counter value
07BE C000       911            push ar0
07C0 A852       911            mov r0, BCD_counter
07C2 12036D     911            lcall ?Display_BCD
07C5 D000       911            pop ar0 ; This macro is also in 'LCD_4bit.inc'
07C7 C0E0       912            push acc
07C9 7406       912            mov a, #6
07CB 14         912            dec a
07CC 120366     912            lcall ?Set_Cursor_2 ; Select column and row
07CF D0E0       912            pop acc     ; the place in the LCD where we want the BCD counter value
07D1 C000       913            push ar0
07D3 A85D       913            mov r0, minutes
07D5 12036D     913            lcall ?Display_BCD
07D8 D000       913            pop ar0 ; This macro is also in 'LCD_4bit.inc'
07DA            914   
07DA 22         915       ret
07DB            916   ;;Timer couter 
07DB            917       sec_counter: 
07DB E552       918           mov a,BCD_counter
07DD B4600A     919           cjne a, #0x60, Continue1 ; check if the couter reached 60s
07E0 E55D       920           mov a, minutes
07E2 2401       921           add a, #0x01 ; add one to the minutes
07E4 D4         922           da a ; Decimal adjust instruction.  Check datasheet for more details!
07E5 F55D       923           mov minutes, a
07E7 120788     924           lcall Reset_timer
07EA            925                Continue1:
07EA 22         926           ret
07EB            927       min_counter:
07EB E55D       928                    mov a,minutes
07ED B4600B     929                    cjne a, #0x60, Continue2
07F0 C28E       930                    clr TR1                 ; Stop timer 2
07F2 E4         931                    clr a                   
07F3 F54B       932                    mov Count1ms+0, a
07F5 F54C       933                    mov Count1ms+1, a       ; Now clear the BCD counter
07F7 F55D       934                    mov minutes, a              ; Reset minutes
07F9 D28E       935           setb TR1                ; Start timer 2
07FB            936   
07FB            937                    Continue2:
07FB 22         938           ret
07FC            939   home_page:
07FC            940   
07FC 20A718     941         jb P2.7, continue20
07FF C002       942            push AR2
0801 7A32       942            mov R2, #50
0803 1202D7     942            lcall ?Wait_Milli_Seconds
0806 D002       942            pop AR2 ; debounce
0808 20A70C     943      jb P2.7, continue20
080B 30A7FD     944      jnb p2.7, $
080E            945      ;clr TR1 
080E 755200     946       mov BCD_counter, #0x00
0811 755D00     947       mov minutes, #0x0   
0814 120794     948       lcall Display_time
0817            949   
0817            950      continue20:
0817            951       ;--------Timer----------;
0817            952   
0817 300C09     953       jnb my_flag, Temp_sensor
081A 1207DB     954       lcall sec_counter
081D 1207EB     955       lcall min_counter
0820 120794     956       lcall Display_time
0823            957       ;-----------------------;
0823            958   
0823            959       ;-----TEMP SENSOR-------;
0823            960       Temp_sensor:
0823            961    ;    lcall config_adc
0823 12076B     962       lcall Display_temp
0826            963    ;    lcall  WaitHalfSec 
0826            964    ;    ;-----------------------;
0826            965   
0826            966   
0826            967   
0826            968   
0826 22         969       ret
0827            970   ;
0827            971   setup_reflow_page:
0827 20A011     972            jb set_BUTTON, continue9
082A C002       972            push AR2
082C 7A0A       972            mov R2, #10
082E 1202D7     972            lcall ?Wait_Milli_Seconds
0831 D002       972            pop AR2
0833 20A005     972            jb set_BUTTON, continue9
0836 30A0FD     972            jnb set_BUTTON, $
0839            972   
0839 B209       973       cpl tt_reflow_flag
083B            974       continue9:
083B            975   
083B 200906     976       jb tt_reflow_flag, jump1
083E            977       ;jnb tt_reflow_flag, jump1
083E 120920     978       lcall INC_DEC_Reflow_time
0841 020847     979       ljmp display_reflow_page
0844            980       jump1:
0844 120968     981       lcall INC_DEC_Reflow_temp
0847            982   
0847            983   
0847            984       display_reflow_page:
0847 C0E0       985            push acc
0849 7405       985            mov a, #5
084B 14         985            dec a
084C 120368     985            lcall ?Set_Cursor_1 ; Select column and row
084F D0E0       985            pop acc
0851 C000       986            push ar0
0853 A84D       986            mov r0, reflow_temp+0
0855 12036D     986            lcall ?Display_BCD
0858 D000       986            pop ar0
085A C0E0       987            push acc
085C 7407       987            mov a, #7
085E 14         987            dec a
085F 120368     987            lcall ?Set_Cursor_1 ; Select column and row
0862 D0E0       987            pop acc
0864 C000       988            push ar0
0866 A84E       988            mov r0, reflow_temp+1
0868 12036D     988            lcall ?Display_BCD
086B D000       988            pop ar0
086D            989          
086D            990       
086D C0E0       991            push acc
086F 7401       991            mov a, #1
0871 14         991            dec a
0872 120368     991            lcall ?Set_Cursor_1 ; Select column and row
0875 D0E0       991            pop acc
0877 C083       992            push dph
0879 C082       992            push dpl
087B C0E0       992            push acc
087D 90041E     992            mov dptr, #reflow_setup
0880 12035B     992            lcall ?Send_Constant_String
0883 D0E0       992            pop acc
0885 D082       992            pop dpl
0887 D083       992            pop dph
0889 C0E0       993            push acc
088B 7409       993            mov a, #9
088D 14         993            dec a
088E 120368     993            lcall ?Set_Cursor_1 ; Select column and row
0891 D0E0       993            pop acc
0893 C083       994            push dph
0895 C082       994            push dpl
0897 C0E0       994            push acc
0899 900423     994            mov dptr, #reflow_setup4
089C 12035B     994            lcall ?Send_Constant_String
089F D0E0       994            pop acc
08A1 D082       994            pop dpl
08A3 D083       994            pop dph
08A5            995   
08A5 C0E0       996            push acc
08A7 7401       996            mov a, #1
08A9 14         996            dec a
08AA 120366     996            lcall ?Set_Cursor_2 ; Select column and row
08AD D0E0       996            pop acc
08AF C083       997            push dph
08B1 C082       997            push dpl
08B3 C0E0       997            push acc
08B5 90042C     997            mov dptr, #reflow_setup2
08B8 12035B     997            lcall ?Send_Constant_String
08BB D0E0       997            pop acc
08BD D082       997            pop dpl
08BF D083       997            pop dph
08C1 C0E0       998            push acc
08C3 7408       998            mov a, #8
08C5 14         998            dec a
08C6 120366     998            lcall ?Set_Cursor_2 ; Select column and row
08C9 D0E0       998            pop acc
08CB C083       999            push dph
08CD C082       999            push dpl
08CF C0E0       999            push acc
08D1 9003D8     999            mov dptr, #dots
08D4 12035B     999            lcall ?Send_Constant_String
08D7 D0E0       999            pop acc
08D9 D082       999            pop dpl
08DB D083       999            pop dph
08DD C0E0      1000            push acc
08DF 740C      1000            mov a, #12
08E1 14        1000            dec a
08E2 120366    1000            lcall ?Set_Cursor_2 ; Select column and row
08E5 D0E0      1000            pop acc
08E7 C083      1001            push dph
08E9 C082      1001            push dpl
08EB C0E0      1001            push acc
08ED 900431    1001            mov dptr, #reflow_setup3
08F0 12035B    1001            lcall ?Send_Constant_String
08F3 D0E0      1001            pop acc
08F5 D082      1001            pop dpl
08F7 D083      1001            pop dph
08F9 C0E0      1002            push acc
08FB 7409      1002            mov a, #9
08FD 14        1002            dec a
08FE 120366    1002            lcall ?Set_Cursor_2 ; Select column and row
0901 D0E0      1002            pop acc
0903 C000      1003            push ar0
0905 A854      1003            mov r0, reflow_sec
0907 12036D    1003            lcall ?Display_BCD
090A D000      1003            pop ar0
090C C0E0      1004            push acc
090E 7406      1004            mov a, #6
0910 14        1004            dec a
0911 120366    1004            lcall ?Set_Cursor_2 ; Select column and row
0914 D0E0      1004            pop acc
0916 C000      1005            push ar0
0918 A855      1005            mov r0, reflow_min
091A 12036D    1005            lcall ?Display_BCD
091D D000      1005            pop ar0
091F           1006   
091F 22        1007       ret
0920           1008       INC_DEC_Reflow_time:
0920           1009   
0920 20A124    1010            jb SETUP_SOAK_Button, check_decrement
0923 C002      1010            push AR2
0925 7A0A      1010            mov R2, #10
0927 1202D7    1010            lcall ?Wait_Milli_Seconds
092A D002      1010            pop AR2
092C 20A118    1010            jb SETUP_SOAK_Button, check_decrement
092F 30A1FD    1010            jnb SETUP_SOAK_Button, $
0932           1010    ; setup soak is also used to increment 
0932           1011   
0932 E554      1012           mov a, reflow_sec
0934 B4590B    1013           cjne a, #0x59, add_reflow_sec
0937 E555      1014           mov a, reflow_min
0939 2401      1015           add a, #0x01
093B D4        1016           da a
093C F555      1017           mov reflow_min, a
093E E4        1018           clr a 
093F 020945    1019           ljmp Continue5
0942           1020           add_reflow_sec:
0942 2401      1021           add a, #0x01
0944 D4        1022           da a ; Decimal adjust instruction.  Check datasheet for more details!
0945           1023           Continue5:
0945 F554      1024           mov reflow_sec, a
0947           1025   
0947           1026           check_decrement:
0947 20A61D    1027            jb Button_min, continue8
094A C002      1027            push AR2
094C 7A0A      1027            mov R2, #10
094E 1202D7    1027            lcall ?Wait_Milli_Seconds
0951 D002      1027            pop AR2
0953 20A611    1027            jb Button_min, continue8
0956 30A6FD    1027            jnb Button_min, $
0959           1027   
0959 E554      1028           mov a, reflow_sec
095B B40004    1029           cjne a, #0x00, sub_reflow_sec
095E E4        1030           clr a 
095F 020965    1031           ljmp Continue6
0962           1032           sub_reflow_sec:
0962 2499      1033           add a, #0x99 ; add 99 reduces 1
0964 D4        1034           da a ; Decimal adjust instruction.  Check datasheet for more details!
0965           1035           Continue6:
0965 F554      1036           mov reflow_sec, a
0967           1037           continue8:
0967 22        1038           ret
0968           1039       INC_DEC_Reflow_temp:
0968           1040           ;PushButton(SETUP_SOAK_Button,check_decrement2) ; setup soak is also used to increment 
0968           1041   
0968 20A121    1042            jb SETUP_SOAK_Button, check_decrement2
096B C002      1042            push AR2
096D 7A0A      1042            mov R2, #10
096F 1202D7    1042            lcall ?Wait_Milli_Seconds
0972 D002      1042            pop AR2
0974 20A115    1042            jb SETUP_SOAK_Button, check_decrement2
0977 30A1FD    1042            jnb SETUP_SOAK_Button, $
097A           1042   
097A           1043             ;  jb SETUP_SOAK_Button, check_decrement2  
097A           1044             ;      Wait_Milli_Seconds(#50)         
097A           1045             ;  jb SETUP_SOAK_Button, check_decrement2  
097A           1046             ;  loop_hold_inc:
097A           1047   ;
097A           1048             ;  jnb SETUP_SOAK_Button, jump2
097A           1049             ;  ;Wait_Milli_Seconds(#50)
097A           1050             ;  jnb SETUP_SOAK_Button, jump2
097A           1051             ;  ljmp hold_done
097A           1052             ;  jump2:
097A           1053             ;  Set_Cursor(1, 5)
097A           1054             ;  Display_BCD(reflow_temp+0)
097A           1055             ;  Set_Cursor(1, 7)
097A           1056             ;  Display_BCD(reflow_temp+1)
097A           1057             ;  Wait_Milli_Seconds(#100)    
097A E54E      1058               mov a, reflow_temp+1
097C 2401      1059               add a, #0x01
097E D4        1060               da a ; Decimal adjust instruction.  Check datasheet for more details!
097F F54E      1061               mov reflow_temp+1, a
0981 E54E      1062               mov a, reflow_temp+1
0983 7007      1063               jnz INC_reflow_temp_done2
0985 E54D      1064               mov a, reflow_temp+0
0987 2401      1065               add a, #0x01
0989 D4        1066               da a ; Decimal adjust instruction.  Check datasheet for more details!
098A F54D      1067               mov reflow_temp+0, a
098C           1068              ; mov a, reflow_temp+1
098C           1069               INC_reflow_temp_done2:
098C           1070               
098C           1071             ;  ljmp loop_hold_inc
098C           1072           hold_done:
098C           1073           
098C           1074   
098C           1075   
098C           1076           check_decrement2:
098C           1077   
098C 20A621    1078            jb Button_min, DEC_reflow_temp_done2
098F C002      1078            push AR2
0991 7A0A      1078            mov R2, #10
0993 1202D7    1078            lcall ?Wait_Milli_Seconds
0996 D002      1078            pop AR2
0998 20A615    1078            jb Button_min, DEC_reflow_temp_done2
099B 30A6FD    1078            jnb Button_min, $
099E           1078   
099E           1079            ;   jb Button_min, DEC_reflow_temp_done2  
099E           1080            ;       Wait_Milli_Seconds(#50)         
099E           1081            ;   jb Button_min, DEC_reflow_temp_done2  
099E           1082            ;   loop_hold_dec:
099E           1083   ;
099E           1084            ;   jnb Button_min, jump3
099E           1085            ;   ljmp DEC_reflow_temp_done2
099E           1086            ;   jump3:
099E           1087            ;   Set_Cursor(1, 5)
099E           1088            ;   Display_BCD(reflow_temp+0)
099E           1089            ;   Set_Cursor(1, 7)
099E           1090            ;   Display_BCD(reflow_temp+1)
099E           1091            ;   Wait_Milli_Seconds(#100)    
099E E54E      1092               mov a, reflow_temp+1
09A0 2499      1093               add a, #0x99
09A2 D4        1094               da a ; Decimal adjust instruction.  Check datasheet for more details!
09A3 F54E      1095               mov reflow_temp+1, a
09A5 E54E      1096               mov a, reflow_temp+1
09A7 7007      1097               jnz INC_reflow_temp_done
09A9 E54D      1098               mov a, reflow_temp+0
09AB 2499      1099               add a, #0x99
09AD D4        1100               da a ; Decimal adjust instruction.  Check datasheet for more details!
09AE F54D      1101               mov reflow_temp+0, a
09B0           1102             ;  mov a, reflow_temp+1
09B0           1103               INC_reflow_temp_done:
09B0           1104               
09B0           1105             ;  ljmp loop_hold_dec
09B0           1106   
09B0           1107           DEC_reflow_temp_done2:
09B0           1108       
09B0           1109   
09B0 22        1110       ret
09B1           1111   setup_soak_page:
09B1 20A011    1112            jb set_BUTTON, continue11
09B4 C002      1112            push AR2
09B6 7A0A      1112            mov R2, #10
09B8 1202D7    1112            lcall ?Wait_Milli_Seconds
09BB D002      1112            pop AR2
09BD 20A005    1112            jb set_BUTTON, continue11
09C0 30A0FD    1112            jnb set_BUTTON, $
09C3           1112   
09C3 B20A      1113       cpl tt_flag_soak
09C5           1114       continue11:
09C5           1115   
09C5 200A06    1116       jb tt_flag_soak, jump4
09C8 120AAA    1117       lcall INC_DEC_soak_time
09CB 0209D1    1118       ljmp display_soak_page
09CE           1119       jump4:
09CE 120AF2    1120       lcall INC_DEC_soak_temp
09D1           1121   
09D1           1122   
09D1           1123       display_soak_page:
09D1 C0E0      1124            push acc
09D3 7405      1124            mov a, #5
09D5 14        1124            dec a
09D6 120368    1124            lcall ?Set_Cursor_1 ; Select column and row
09D9 D0E0      1124            pop acc
09DB C000      1125            push ar0
09DD A84F      1125            mov r0, soak_temp+0
09DF 12036D    1125            lcall ?Display_BCD
09E2 D000      1125            pop ar0
09E4 C0E0      1126            push acc
09E6 7407      1126            mov a, #7
09E8 14        1126            dec a
09E9 120368    1126            lcall ?Set_Cursor_1 ; Select column and row
09EC D0E0      1126            pop acc
09EE C000      1127            push ar0
09F0 A850      1127            mov r0, soak_temp+1
09F2 12036D    1127            lcall ?Display_BCD
09F5 D000      1127            pop ar0
09F7           1128          
09F7           1129       
09F7 C0E0      1130            push acc
09F9 7401      1130            mov a, #1
09FB 14        1130            dec a
09FC 120368    1130            lcall ?Set_Cursor_1 ; Select column and row
09FF D0E0      1130            pop acc
0A01 C083      1131            push dph
0A03 C082      1131            push dpl
0A05 C0E0      1131            push acc
0A07 900436    1131            mov dptr, #soak_setup0
0A0A 12035B    1131            lcall ?Send_Constant_String
0A0D D0E0      1131            pop acc
0A0F D082      1131            pop dpl
0A11 D083      1131            pop dph
0A13 C0E0      1132            push acc
0A15 7409      1132            mov a, #9
0A17 14        1132            dec a
0A18 120368    1132            lcall ?Set_Cursor_1 ; Select column and row
0A1B D0E0      1132            pop acc
0A1D           1132   
0A1D C083      1133            push dph
0A1F C082      1133            push dpl
0A21 C0E0      1133            push acc
0A23 90043B    1133            mov dptr, #soak_setup1
0A26 12035B    1133            lcall ?Send_Constant_String
0A29 D0E0      1133            pop acc
0A2B D082      1133            pop dpl
0A2D D083      1133            pop dph
0A2F           1134   
0A2F C0E0      1135            push acc
0A31 7401      1135            mov a, #1
0A33 14        1135            dec a
0A34 120366    1135            lcall ?Set_Cursor_2 ; Select column and row
0A37 D0E0      1135            pop acc
0A39           1135   
0A39 C083      1136            push dph
0A3B C082      1136            push dpl
0A3D C0E0      1136            push acc
0A3F 900443    1136            mov dptr, #soak_setup2
0A42 12035B    1136            lcall ?Send_Constant_String
0A45 D0E0      1136            pop acc
0A47 D082      1136            pop dpl
0A49 D083      1136            pop dph
0A4B C0E0      1137            push acc
0A4D 7408      1137            mov a, #8
0A4F 14        1137            dec a
0A50 120366    1137            lcall ?Set_Cursor_2 ; Select column and row
0A53 D0E0      1137            pop acc
0A55           1137   
0A55 C083      1138            push dph
0A57 C082      1138            push dpl
0A59 C0E0      1138            push acc
0A5B 9003D8    1138            mov dptr, #dots
0A5E 12035B    1138            lcall ?Send_Constant_String
0A61 D0E0      1138            pop acc
0A63 D082      1138            pop dpl
0A65 D083      1138            pop dph
0A67 C0E0      1139            push acc
0A69 740C      1139            mov a, #12
0A6B 14        1139            dec a
0A6C 120366    1139            lcall ?Set_Cursor_2 ; Select column and row
0A6F D0E0      1139            pop acc
0A71 C083      1140            push dph
0A73 C082      1140            push dpl
0A75 C0E0      1140            push acc
0A77 900448    1140            mov dptr, #soak_setup3
0A7A 12035B    1140            lcall ?Send_Constant_String
0A7D D0E0      1140            pop acc
0A7F D082      1140            pop dpl
0A81 D083      1140            pop dph
0A83 C0E0      1141            push acc
0A85 7409      1141            mov a, #9
0A87 14        1141            dec a
0A88 120366    1141            lcall ?Set_Cursor_2 ; Select column and row
0A8B D0E0      1141            pop acc
0A8D           1141   
0A8D C000      1142            push ar0
0A8F A856      1142            mov r0, soak_sec
0A91 12036D    1142            lcall ?Display_BCD
0A94 D000      1142            pop ar0
0A96 C0E0      1143            push acc
0A98 7406      1143            mov a, #6
0A9A 14        1143            dec a
0A9B 120366    1143            lcall ?Set_Cursor_2 ; Select column and row
0A9E D0E0      1143            pop acc
0AA0 C000      1144            push ar0
0AA2 A857      1144            mov r0, soak_min
0AA4 12036D    1144            lcall ?Display_BCD
0AA7 D000      1144            pop ar0
0AA9 22        1145   ret
0AAA           1146       INC_DEC_soak_time:
0AAA           1147       
0AAA 20A124    1148            jb SETUP_SOAK_Button, check_decrement_soak
0AAD C002      1148            push AR2
0AAF 7A0A      1148            mov R2, #10
0AB1 1202D7    1148            lcall ?Wait_Milli_Seconds
0AB4 D002      1148            pop AR2
0AB6 20A118    1148            jb SETUP_SOAK_Button, check_decrement_soak
0AB9 30A1FD    1148            jnb SETUP_SOAK_Button, $
0ABC           1148    ; setup soak is also used to increment 
0ABC           1149   
0ABC E556      1150           mov a, soak_sec
0ABE B4590B    1151           cjne a, #0x59, add_soak_sec
0AC1 E557      1152           mov a, soak_min
0AC3 2401      1153           add a, #0x01
0AC5 D4        1154           da a
0AC6 F557      1155           mov soak_min, a
0AC8 E4        1156           clr a 
0AC9 020ACF    1157           ljmp Continue12
0ACC           1158           add_soak_sec:
0ACC 2401      1159           add a, #0x01
0ACE D4        1160           da a ; Decimal adjust instruction.  Check datasheet for more details!
0ACF           1161           Continue12:
0ACF F556      1162           mov soak_sec, a
0AD1           1163   
0AD1           1164           check_decrement_soak:
0AD1 20A61D    1165            jb Button_min, continue13
0AD4 C002      1165            push AR2
0AD6 7A0A      1165            mov R2, #10
0AD8 1202D7    1165            lcall ?Wait_Milli_Seconds
0ADB D002      1165            pop AR2
0ADD 20A611    1165            jb Button_min, continue13
0AE0 30A6FD    1165            jnb Button_min, $
0AE3           1165   
0AE3 E556      1166           mov a, soak_sec
0AE5 B40004    1167           cjne a, #0x00, sub_soak_sec
0AE8 E4        1168           clr a 
0AE9 020AEF    1169           ljmp Continue14
0AEC           1170           sub_soak_sec:
0AEC 2499      1171           add a, #0x99 ; add 99 reduces 1
0AEE D4        1172           da a ; Decimal adjust instruction.  Check datasheet for more details!
0AEF           1173           Continue14:
0AEF F556      1174           mov soak_sec, a
0AF1           1175           continue13:
0AF1           1176           
0AF1 22        1177           ret
0AF2           1178       INC_DEC_soak_temp:
0AF2           1179           
0AF2 20A121    1180            jb SETUP_SOAK_Button, check_decrement2_soak
0AF5 C002      1180            push AR2
0AF7 7A0A      1180            mov R2, #10
0AF9 1202D7    1180            lcall ?Wait_Milli_Seconds
0AFC D002      1180            pop AR2
0AFE 20A115    1180            jb SETUP_SOAK_Button, check_decrement2_soak
0B01 30A1FD    1180            jnb SETUP_SOAK_Button, $
0B04           1180   
0B04           1181           ;    jb SETUP_SOAK_Button, check_decrement2_soak  
0B04           1182           ;        Wait_Milli_Seconds(#50)         
0B04           1183           ;    jb SETUP_SOAK_Button, check_decrement2_soak  
0B04           1184           ;    loop_hold_inc_soak:
0B04           1185         ;
0B04           1186           ;    jnb SETUP_SOAK_Button, jump6
0B04           1187           ;    Wait_Milli_Seconds(#100)
0B04           1188           ;    jnb SETUP_SOAK_Button, jump6
0B04           1189           ;    ljmp hold_done_soak
0B04           1190           ;    jump6:
0B04           1191           ;    Set_Cursor(1, 5)
0B04           1192           ;    Display_BCD(soak_temp+0)
0B04           1193           ;    Set_Cursor(1, 7)
0B04           1194           ;    Display_BCD(soak_temp+1)
0B04           1195           ;    Wait_Milli_Seconds(#200)    
0B04 E550      1196               mov a, soak_temp+1
0B06 2401      1197               add a, #0x01
0B08 D4        1198               da a ; Decimal adjust instruction.  Check datasheet for more details!
0B09 F550      1199               mov soak_temp+1, a
0B0B E550      1200               mov a, soak_temp+1
0B0D 7007      1201               jnz INC_soak_temp_done2
0B0F E54F      1202               mov a, soak_temp+0
0B11 2401      1203               add a, #0x01
0B13 D4        1204               da a ; Decimal adjust instruction.  Check datasheet for more details!
0B14 F54F      1205               mov soak_temp+0, a
0B16           1206              ; mov a, soak_temp+1
0B16           1207               INC_soak_temp_done2:
0B16           1208               
0B16           1209             ;  ljmp loop_hold_inc_soak
0B16           1210           hold_done_soak:
0B16           1211           
0B16           1212   
0B16           1213   
0B16           1214           check_decrement2_soak:
0B16           1215   
0B16 20A621    1216            jb Button_min, DEC_soak_temp_done2
0B19 C002      1216            push AR2
0B1B 7A0A      1216            mov R2, #10
0B1D 1202D7    1216            lcall ?Wait_Milli_Seconds
0B20 D002      1216            pop AR2
0B22 20A615    1216            jb Button_min, DEC_soak_temp_done2
0B25 30A6FD    1216            jnb Button_min, $
0B28           1216   
0B28           1217              ; 
0B28           1218              ; jb Button_min, DEC_soak_temp_done2  
0B28           1219              ;     Wait_Milli_Seconds(#50)         
0B28           1220              ; jb Button_min, DEC_soak_temp_done2  
0B28           1221              ; loop_hold_dec_soak:
0B28           1222                ;
0B28           1223              ; jnb Button_min, jump7
0B28           1224              ; Wait_Milli_Seconds(#100)
0B28           1225              ; jnb Button_min, jump7
0B28           1226              ; ljmp DEC_soak_temp_done2
0B28           1227              ; jump7:
0B28           1228              ; Set_Cursor(1, 5)
0B28           1229              ; Display_BCD(soak_temp+0)
0B28           1230              ; Set_Cursor(1, 7)
0B28           1231              ; Display_BCD(soak_temp+1)
0B28           1232              ; Wait_Milli_Seconds(#100)    
0B28 E550      1233               mov a, soak_temp+1
0B2A 2499      1234               add a, #0x99
0B2C D4        1235               da a ; Decimal adjust instruction.  Check datasheet for more details!
0B2D F550      1236               mov soak_temp+1, a
0B2F E550      1237               mov a, soak_temp+1
0B31 7007      1238               jnz INC_soak_temp_done
0B33 E54F      1239               mov a, soak_temp+0
0B35 2499      1240               add a, #0x99
0B37 D4        1241               da a ; Decimal adjust instruction.  Check datasheet for more details!
0B38 F54F      1242               mov soak_temp+0, a
0B3A           1243             ;  mov a, soak_temp+1
0B3A           1244               INC_soak_temp_done:
0B3A           1245               
0B3A           1246              ; ljmp loop_hold_dec_soak
0B3A           1247   
0B3A           1248           DEC_soak_temp_done2:
0B3A 22        1249           ret
0B3B           1250   second_page:
0B3B C0E0      1251            push acc
0B3D 7401      1251            mov a, #1
0B3F 14        1251            dec a
0B40 120368    1251            lcall ?Set_Cursor_1 ; Select column and row
0B43 D0E0      1251            pop acc
0B45 C083      1252            push dph
0B47 C082      1252            push dpl
0B49 C0E0      1252            push acc
0B4B 90040D    1252            mov dptr, #soak_reflw
0B4E 12035B    1252            lcall ?Send_Constant_String
0B51 D0E0      1252            pop acc
0B53 D082      1252            pop dpl
0B55 D083      1252            pop dph
0B57 C0E0      1253            push acc
0B59 7401      1253            mov a, #1
0B5B 14        1253            dec a
0B5C 120366    1253            lcall ?Set_Cursor_2 ; Select column and row
0B5F D0E0      1253            pop acc
0B61 C083      1254            push dph
0B63 C082      1254            push dpl
0B65 C0E0      1254            push acc
0B67 9003A5    1254            mov dptr, #nothing
0B6A 12035B    1254            lcall ?Send_Constant_String
0B6D D0E0      1254            pop acc
0B6F D082      1254            pop dpl
0B71 D083      1254            pop dph
0B73 22        1255       ret
0B74           1256   
0B74           1257   FSM_LCD:
0B74 E546      1258           mov a, state_lcd
0B76           1259   
0B76           1260   
0B76           1261           ;----------------STATE 0------------------;
0B76           1262            home_state:
0B76 B4001E    1263               cjne a, #0, soak_reflow_state
0B79 20A015    1264            jb set_BUTTON, done_home2
0B7C C002      1264            push AR2
0B7E 7A0A      1264            mov R2, #10
0B80 1202D7    1264            lcall ?Wait_Milli_Seconds
0B83 D002      1264            pop AR2
0B85 20A009    1264            jb set_BUTTON, done_home2
0B88 30A0FD    1264            jnb set_BUTTON, $
0B8B           1264    
0B8B           1265               ;setb set_flag  
0B8B 754601    1266               mov state_lcd, #1
0B8E 020B94    1267               ljmp done_home
0B91           1268               done_home2:
0B91           1269               ;clr set_flag
0B91 1207FC    1270               lcall home_page
0B94           1271               done_home:
0B94 020C33    1272               ljmp Forever_done           
0B97           1273           ;------------------------------------------;
0B97           1274           
0B97           1275        ;   ;----------------STATE 1-------------------;
0B97           1276           soak_reflow_state:
0B97 B4014B    1277               cjne a, #1, setup_soak
0B9A 120B3B    1278               lcall second_page
0B9D           1279             ;  Wait_Milli_Seconds(#50)
0B9D 1207DB    1280               lcall sec_counter ; prevent the timer to go over 60
0BA0 1207EB    1281               lcall min_counter
0BA3 20A712    1282            jb HOME_BUTTON, next_pushb
0BA6 C002      1282            push AR2
0BA8 7A0A      1282            mov R2, #10
0BAA 1202D7    1282            lcall ?Wait_Milli_Seconds
0BAD D002      1282            pop AR2
0BAF 20A706    1282            jb HOME_BUTTON, next_pushb
0BB2 30A7FD    1282            jnb HOME_BUTTON, $
0BB5           1282    ; check if home button is pressed 
0BB5 754600    1283               mov state_lcd, #0
0BB8           1284               next_pushb:
0BB8 20A112    1285            jb SETUP_SOAK_Button, next_pushb2
0BBB C002      1285            push AR2
0BBD 7A0A      1285            mov R2, #10
0BBF 1202D7    1285            lcall ?Wait_Milli_Seconds
0BC2 D002      1285            pop AR2
0BC4 20A106    1285            jb SETUP_SOAK_Button, next_pushb2
0BC7 30A1FD    1285            jnb SETUP_SOAK_Button, $
0BCA           1285    ; check if the the button to setup soak is pressed
0BCA 754602    1286               mov state_lcd, #2
0BCD           1287               next_pushb2:
0BCD 20A612    1288            jb Button_min, done_soak
0BD0 C002      1288            push AR2
0BD2 7A0A      1288            mov R2, #10
0BD4 1202D7    1288            lcall ?Wait_Milli_Seconds
0BD7 D002      1288            pop AR2
0BD9 20A606    1288            jb Button_min, done_soak
0BDC 30A6FD    1288            jnb Button_min, $
0BDF           1288    ; check if the buttion to setup the reflow was pressed 
0BDF 754603    1289               mov state_lcd, #3
0BE2           1290               done_soak:
0BE2 020C33    1291              ljmp Forever_done 
0BE5           1292           ;------------------------------------------;
0BE5           1293   ;
0BE5           1294        ;   ;-----------------STATE 2------------------;
0BE5           1295           setup_soak: ; its actually set up reflow Im dumb
0BE5 B40221    1296               cjne a, #2, setup_reflow
0BE8 120827    1297               lcall setup_reflow_page
0BEB           1298             ;  Wait_Milli_Seconds(#50)
0BEB 1207DB    1299               lcall sec_counter ; prevent the timer to go over 60
0BEE 1207EB    1300               lcall min_counter
0BF1 20A712    1301            jb HOME_BUTTON, done_setup_soak
0BF4 C002      1301            push AR2
0BF6 7A0A      1301            mov R2, #10
0BF8 1202D7    1301            lcall ?Wait_Milli_Seconds
0BFB D002      1301            pop AR2
0BFD 20A706    1301            jb HOME_BUTTON, done_setup_soak
0C00 30A7FD    1301            jnb HOME_BUTTON, $
0C03           1301    ; check if home button is pressed 
0C03 754600    1302               mov state_lcd, #0
0C06           1303               done_setup_soak:
0C06 020C33    1304               ljmp Forever_done 
0C09           1305           ;------------------------------------------;
0C09           1306   ;
0C09           1307        ;   ;----------------STATE 3-------------------;
0C09           1308           setup_reflow: ; its actually set up soak Im dumb
0C09 B40303    1309               cjne a, #3, FDP
0C0C 020C12    1310               ljmp FDP2
0C0F           1311               FDP:
0C0F 020B76    1312               ljmp home_state
0C12           1313               FDP2:
0C12 1209B1    1314               lcall setup_soak_page
0C15 1207DB    1315               lcall sec_counter ; prevent the timer to go over 60
0C18 1207EB    1316               lcall min_counter
0C1B 20A712    1317            jb HOME_BUTTON, done_setup_reflow
0C1E C002      1317            push AR2
0C20 7A0A      1317            mov R2, #10
0C22 1202D7    1317            lcall ?Wait_Milli_Seconds
0C25 D002      1317            pop AR2
0C27 20A706    1317            jb HOME_BUTTON, done_setup_reflow
0C2A 30A7FD    1317            jnb HOME_BUTTON, $
0C2D           1317    ; check if home button is pressed 
0C2D 754600    1318               mov state_lcd, #0
0C30           1319               done_setup_reflow:
0C30 020C33    1320               ljmp Forever_done 
0C33           1321        ;   ;------------------------------------------;
0C33           1322           Forever_done:
0C33 22        1323   ret
0C34           1324   
0C34           1325   ;------------------------------
0C34           1326   ;---------------------------------;
0C34           1327   ; Main program. Includes hardware ;
0C34           1328   ; initialization and 'forever'    ;
0C34           1329   ; loop.                           ;
0C34           1330   ;---------------------------------;
0C34           1331   main:
0C34           1332            ; Initialization
0C34 75817F    1333       mov SP, #0x7F
0C37 12044D    1334       lcall Timer0_Init
0C3A 120478    1335       lcall Timer1_Init
0C3D           1336   
0C3D 120526    1337       lcall Ports_Init ; Default all pins as bidirectional I/O. See Table 42.
0C40 120326    1338       lcall LCD_4BIT
0C43 12054F    1339       lcall Double_Clk
0C46 12053F    1340            lcall InitDAC1 ; Call after 'Ports_Init'
0C49 1204D8    1341            lcall CCU_Init
0C4C 120557    1342            lcall Init_SPI
0C4F           1343            
0C4F           1344            
0C4F D2AF      1345            setb EA ; Enable global interrupts.
0C51           1346   
0C51           1347            ; Initialize variables
0C51 C200      1348            clr T2S_FSM_Start
0C53 755F00    1349            mov T2S_FSM_state, #0
0C56           1350       ; Configure all the ports in bidirectional mode:
0C56           1351   
0C56 758400    1352       mov P0M1, #00H
0C59 758500    1353       mov P0M2, #00H
0C5C 759100    1354       mov P1M1, #00H
0C5F 759200    1355       mov P1M2, #00H ; WARNING: P1.2 and P1.3 need 1kohm pull-up resistors!
0C62 75A400    1356       mov P2M1, #00H
0C65 75A500    1357       mov P2M2, #00H
0C68 75B100    1358       mov P3M1, #00H
0C6B 75B200    1359       mov P3M2, #00H
0C6E           1360       
0C6E           1361       ;mov minutes, #0
0C6E 755E00    1362            mov seconds, #0
0C71           1363   
0C71           1364      ; lcall LCD_4BIT
0C71           1365       ; For convenience a few handy macros are included in 'LCD_4bit_LPC9351.inc':
0C71 C0E0      1366            push acc
0C73 7401      1366            mov a, #1
0C75 14        1366            dec a
0C76 120368    1366            lcall ?Set_Cursor_1 ; Select column and row
0C79 D0E0      1366            pop acc
0C7B C000      1367            push ar0
0C7D A852      1367            mov r0, BCD_counter
0C7F 12036D    1367            lcall ?Display_BCD
0C82 D000      1367            pop ar0
0C84           1368   
0C84 D203      1369       setb half_seconds_flag
0C86 D20C      1370       setb my_flag
0C88 E4        1371       clr a
0C89 F54B      1372       mov Count1ms+0, a
0C8B F54C      1373       mov Count1ms+1, a    
0C8D           1374   
0C8D 755200    1375            mov BCD_counter, #0x00
0C90 754A00    1376            mov pwm , #0
0C93 754800    1377            mov sec , #0
0C96 754500    1378            mov state, #0
0C99 754796    1379            mov temp, #150
0C9C 754205    1380       mov time_soak, #5
0C9F 7543DC    1381       mov temp_refl, #220
0CA2 754105    1382       mov temp_soak, #5
0CA5 756100    1383       mov five_sec_flag,#0
0CA8           1384            ; After initialization the program stays in this 'forever' loop
0CA8           1385   
0CA8 755400    1386       mov reflow_sec, #0x00
0CAB 755500    1387       mov reflow_min, #0x00
0CAE 755D00    1388       mov minutes, #0x00
0CB1 754600    1389       mov state_lcd, #0
0CB4 C208      1390       clr TR1_flag
0CB6 754D01    1391       mov reflow_temp+0, #0x01
0CB9 754E50    1392       mov reflow_temp+1, #0x50
0CBC C209      1393       clr tt_reflow_flag
0CBE 755600    1394       mov soak_sec, #0x00
0CC1 755700    1395       mov soak_min, #0x00
0CC4           1396   
0CC4 754F01    1397       mov soak_temp+0, #0x01
0CC7 755050    1398       mov soak_temp+1, #0x50
0CCA C20B      1399       clr stop_flag
0CCC           1400   
0CCC           1401       
0CCC           1402   forever:         
0CCC 120B74    1403       lcall FSM_LCD
0CCF           1404   
0CCF 120687    1405       lcall T2S_FSM
0CD2           1406            ; One second has passed, refresh the LCD with new time
0CD2           1407   ;        Set_Cursor(1, 1)
0CD2           1408   ;    Send_Constant_String(#timee)
0CD2           1409   ;    Set_Cursor(1, 5)
0CD2           1410   ;    Display_BCD(sec)
0CD2           1411   ;    Set_Cursor(2, 1)
0CD2           1412   ;    Send_Constant_String(#statee)
0CD2           1413    ;   Set_Cursor(2, 5)
0CD2           1414     ;  Display_BCD(BCD_counter)
0CD2           1415   
0CD2           1416       
0CD2           1417           
0CD2 20A614    1418       jb P2.6, continue19
0CD5 C002      1419            push AR2
0CD7 7A32      1419            mov R2, #50
0CD9 1202D7    1419            lcall ?Wait_Milli_Seconds
0CDC D002      1419            pop AR2 ; debounce
0CDE 20A608    1420            jb P2.6, continue19
0CE1 30A6FD    1421            jnb P2.6, $
0CE4 C28E      1422            clr TR1 
0CE6 020CCC    1423            ljmp forever
0CE9           1424      continue19:
0CE9           1425   
0CE9           1426   
0CE9           1427   
0CE9           1428     ;  mov a, five_sec_flag
0CE9           1429     ;  cjne a,#5, pass_quack
0CE9           1430     ;  quack_like_a_duck:
0CE9           1431     ;  clr TR1 ; Stop timer 1.
0CE9           1432     ;  mov a,#0
0CE9           1433     ;  mov five_sec_flag,a
0CE9           1434     ;  clr TR1 ; Stop timer 1.
0CE9           1435   ;        setb T2S_FSM_Start ; This plays the current minutes:seconds by making the state machine get out of state zero.
0CE9           1436     ;  pass_hash:
0CE9           1437     ;  pass_quack:
0CE9           1438     ;  setb TR1 ; en timer 1.
0CE9           1439       
0CE9 E545      1440       mov a, state
0CEB           1441     state0: 
0CEB B40013    1442         cjne a, #0, state1
0CEE 754A00    1443         mov pwm, #0
0CF1 C28E      1444         clr TR1
0CF3 20B008    1445         jb p3.0, state0_done
0CF6 30B0FD    1446         jnb p3.0, $ ;wait for key release
0CF9 D28E      1447         setb TR1
0CFB 754501    1448         mov state, #1
0CFE           1449     state0_done:
0CFE 020CCC    1450         ljmp forever
0D01           1451      
0D01           1452      state1:
0D01 B40113    1453         cjne a, #1 , state2
0D04 754A64    1454         mov pwm, #100
0D07 754800    1455         mov sec, #0
0D0A E541      1456         mov a, temp_soak
0D0C C3        1457         clr c
0D0D 9547      1458         subb a, temp
0D0F           1459         ;add branches to compare temp with 150
0D0F 5003      1460         jnc state1_done
0D11 754502    1461         mov state, #2
0D14           1462     state1_done:
0D14 020CCC    1463          ljmp forever
0D17           1464          
0D17           1465     state2: ;press p3.0 multiple time plz cos it is stuck
0D17 B40210    1466         cjne a, #2 , state3
0D1A 754A14    1467         mov pwm, #20
0D1D E542      1468         mov a, time_soak
0D1F C3        1469         clr c
0D20 9548      1470         subb a, sec
0D22           1471         ;add branches to compare sec with  60
0D22 5003      1472         jnc state2_done
0D24 754503    1473         mov state, #3
0D27           1474     state2_done:
0D27 020CCC    1475          ljmp forever          
0D2A           1476     
0D2A           1477     state3:
0D2A B40313    1478         cjne a, #3 , state4
0D2D 754A50    1479         mov pwm, #80
0D30 754800    1480         mov sec, #0     
0D33 E543      1481         mov a, temp_refl
0D35 C3        1482         clr c
0D36 9547      1483         subb a, temp
0D38           1484         ;add branches to compare temp with 220
0D38 5003      1485         jnc state3_done
0D3A 754504    1486         mov state, #4
0D3D           1487     state3_done:
0D3D 020CCC    1488          ljmp forever
0D40           1489          
0D40           1490      state4:
0D40 B40410    1491         cjne a, #4 , state5
0D43 754A14    1492         mov pwm, #20
0D46 E544      1493         mov a, time_refl
0D48 C3        1494         clr c
0D49 9548      1495         subb a, sec
0D4B           1496         ;add branches to compare sec with 45
0D4B 5003      1497         jnc state4_done
0D4D 754505    1498         mov state, #5
0D50           1499     state4_done:
0D50 020CCC    1500          ljmp forever    
0D53           1501          
0D53           1502      state5:
0D53 B40595    1503         cjne a, #5 , state0
0D56 754A00    1504         mov pwm, #0
0D59 C3        1505         clr c
0D5A 9547      1506         subb a, temp
0D5C           1507         ;add branches to compare temp with 60
0D5C 5003      1508         jnc state5_done
0D5E 754500    1509         mov state, #0
0D61           1510     state5_done:
0D61 020CCC    1511          ljmp forever 
0D64           1512          
0D64           1513   
0D64           1514   EN
