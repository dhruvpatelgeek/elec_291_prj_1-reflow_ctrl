0000              1   
0000              2   ;;;;;;;;
0000              3   ; Start/Constants
                  5       $LIST
0000              7   
0000              8       CLK           EQU 7373000  ; Microcontroller system crystal frequency in Hz
0000              9       TIMER0_RATE   EQU 100     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0000             10       TIMER0_RELOAD EQU ((65536-(CLK/(2*TIMER0_RATE))))
0000             11       TIMER1_RATE   EQU 100     ; 100Hz, for a timer tick of 10ms
0000             12       TIMER1_RELOAD EQU ((65536-(CLK/(2*TIMER1_RATE))))
0000             13   
0000             14   
0000             15   
0000             16       CCU_RATE    EQU 11025     ; 22050Hz is the sampling rate of the wav file we are playing
0000             17       CCU_RELOAD  EQU ((65536-((CLK/(2*CCU_RATE)))))
0000             18       BAUD        EQU 115200
0000             19       BRVAL       EQU ((CLK/BAUD)-16)
0000             20   
0000             21           ;definitions for clk, baud rate, etc.
0000             22       OP_AMP_GAIN EQU 340 ;what is the exact gain?
0000             23   
0000             24   
0000             25   
0000             26       ; Commands supported by the SPI flash memory according to the datasheet
0000             27       WRITE_ENABLE     EQU 0x06  ; Address:0 Dummy:0 Num:0
0000             28       WRITE_DISABLE    EQU 0x04  ; Address:0 Dummy:0 Num:0
0000             29       READ_STATUS      EQU 0x05  ; Address:0 Dummy:0 Num:1 to infinite
0000             30       READ_BYTES       EQU 0x03  ; Address:3 Dummy:0 Num:1 to infinite
0000             31       READ_SILICON_ID  EQU 0xab  ; Address:0 Dummy:3 Num:1 to infinite
0000             32       FAST_READ        EQU 0x0b  ; Address:3 Dummy:1 Num:1 to infinite
0000             33       WRITE_STATUS     EQU 0x01  ; Address:0 Dummy:0 Num:1
0000             34       WRITE_BYTES      EQU 0x02  ; Address:3 Dummy:0 Num:1 to 256
0000             35       ERASE_ALL        EQU 0xc7  ; Address:0 Dummy:0 Num:0
0000             36       ERASE_BLOCK      EQU 0xd8  ; Address:3 Dummy:0 Num:0
0000             37       READ_DEVICE_ID   EQU 0x9f  ; Address:0 Dummy:2 Num:1 to infinite
0000             38   ;Vectors
0000             39       ; Reset vector
0000             40       org 0x0000
0000 020DCB      41           ljmp main
0003             42   
0003             43       ; External interrupt 0 vector (not used in this code)
0003             44       org 0x0003
0003 32          45           reti
0004             46   
0004             47       ; Timer/Counter 0 overflow interrupt vector
000B             48       org 0x000B
000B 020478      49           ljmp Timer0_ISR
000E             50   
000E             51       ; External interrupt 1 vector (not used in this code)
0013             52       org 0x0013
0013 32          53           reti
0014             54   
0014             55       ; Timer/Counter 1 overflow interrupt vector
001B             56       org 0x001B
001B 0204A3      57           ljmp Timer1_ISR
001E             58   
001E             59       ; Serial port receive/transmit interrupt vector (not used in this code)
0023             60       org 0x0023 
0023 32          61           reti
0024             62   
005B             63       org 0x005b ; CCU interrupt vector.  Used in this code to replay the wave file.
005B 0204F9      64           ljmp CCU_ISR
005E             65   
005E             66   
005E             67       ;                                                        -                     
005E             68       ;                                                       -  -                    
005E             69       ;                                                      -    -                   
005E             70       ;                              leave it at this temp>>-      -                  
005E             71       ;                                                    -        -                 
005E             72       ;                                                   -          -                 
005E             73       ;                                                  -            -               
005E             74       ;                                                 -              -              
005E             75       ;                                                -                -             
005E             76       ;                                               -                  -            
005E             77       ;                                              -                    -           
005E             78       ;                                             -    reflow>>cool     -          
005E             79       ;               -----------------------------    (temperature only)  -         
005E             80       ;              -     soak (time+temp)                                 -        
005E             81       ;             -                                                        -       
005E             82       ;            -                                                          -       
005E             83       ;          -                                                             -      
005E             84       ;         -                                                               -     
005E             85       ;        -                                                                 -    
005E             86       ;      -                                                                    -    
005E             87       ;     - ramp to soak (temperature)                                           -   
005E             88       ;   -                                                                         -   
005E             89       ;   state 1 ((temp==soak)? ssr_off: ssr_on)
005E             90       ;          state 2 ((time=soak_time)?(pwm_off):(pwn_on)
005E             91       ;                                           state 3 ((temp==soak)? ssr_off: ssr_on)
005E             92       ;                                                        state 4 (cooling ssr_off)
005E             93       ;                                                                             state 5 (done)
005E             94   
005E             95       ; In the 8051 we can define direct access variables starting at location 0x30 up to location 0x7F
005E             96   ;Variables(dseg) 
0030             97       dseg at 0x30
0030             98   
0030             99       ;FSM varialbles
0030            100       temp_soak:       ds 1 ; temp to soak
0031            101       time_soak:       ds 1 ; time to soak
0032            102       temp_refl:       ds 1 ; temp of relfow
0033            103       time_refl:       ds 1 ; time to reflow 
0034            104       state:           ds 1 ; current state 
0035            105       state_lcd:       ds 1
0036            106       temp:            ds 1 ; current temp in degree C
0037            107       sec:             ds 1 ; current time in seconds 
0038            108       product:         ds 1; pwm-currsec
0039            109       pwm:             ds 1 ; 
003A            110   
003A            111       ;Timer variables
003A            112       Count1ms:        ds 2 ; Used to determine when half second has passed
003C            113       reflow_temp:     ds 2
003E            114       soak_temp:       ds 2
0040            115       reflow_temp_var: ds 1
0041            116       BCD_counter:     ds 1 ; The BCD counter incrememted in the ISR and displayed in the main loop
0042            117       hour:            ds 1
0043            118       reflow_sec:      ds 1
0044            119       reflow_min:      ds 1
0045            120       soak_sec:        ds 1
0046            121       soak_min:        ds 1
0047            122       Count10ms:       ds 1 ; Used to determine when half second has passed
0048            123       Count10ms2:      ds 1
0049            124       w:               ds 3 ; 24-bit play counter.  Decremented in CCU ISR.
004C            125       minutes:         ds 1
004D            126       seconds:         ds 1
004E            127       T2S_FSM_state:   ds 1
004F            128       Count5ms:        ds 1
0050            129       five_sec_flag:   ds 1
0051            130   
0051            131       ; Temperature 
0051            132   
0051            133       x: ds 4
0055            134       y: ds 4
0059            135       Result: ds 2 
005B            136       ch0: ds 2
005D            137       ch1: ds 2
005F            138       oven_temp: ds 2
0061            139       bcd: ds 5
0066            140   
0066            141   ;flags(bseg)
0000            142       BSEG
0000            143       T2S_FSM_start:     dbit 1
0001            144       seconds_flag:      dbit 1
0002            145       mf:                dbit 1
0003            146       half_seconds_flag: dbit 1 ; Set to one in the ISR every time 500 ms had passed
0004            147       AMPM_flag:         dbit 1
0005            148       alarm_AMPM_flag:   dbit 1
0006            149       on_off_flag:       dbit 1 ; 1 is on
0007            150       alarm_buzzer_flag: dbit 1
0008            151       TR1_flag:          dbit 1
0009            152       tt_reflow_flag:    dbit 1
000A            153       tt_flag_soak:      dbit 1
000B            154       stop_flag:         dbit 1
000C            155       my_flag:           dbit 1
000D            156   
000D            157   
000D            158       ;_ _ _ _ | _ _ _ _ _ _
000D            159       ;
000D            160       ;pwm = 40 (say)
000D            161       ;then output will be 100 
000D            162       ;_________
000D            163       ;         |
000D            164       ;         |_____________
000D            165       ; where period is 1 second 
000D            166       ; In the 8051 we have variables that are 1-bit in size.  We can use the setb, clr, jb, and jnb
000D            167       ; instructions with these variables.  This is how you define a 1-bit variable:
000D            168   
000D            169   ;Pin config(cseg)
000D            170   
005E            171       cseg
005E            172       ; These 'equ' must match the wiring between the microcontroller and the LCD!
005E            173       LCD_RS equ P0.5
005E            174       LCD_RW equ P0.6
005E            175       LCD_E  equ P0.7
005E            176       LCD_D4 equ P1.2
005E            177       LCD_D5 equ P1.3
005E            178       LCD_D6 equ P1.4
005E            179       LCD_D7 equ P1.6
005E            180   
005E            181       CLEAR         equ P3.0
005E            182       FLASH_CE      EQU P2.4
005E            183       SOUND         EQU P2.7
005E            184       
005E            185       SETUP_SOAK_Button equ  P2.1
005E            186       set_BUTTON        equ  P2.0
005E            187       Button_min        equ  P2.6
005E            188       HOME_BUTTON       equ  P2.7
005E            189   
005E            190       SQUARE_WAVE       EQU P0.1
005E            191   
005E            192       ;define the connections between the ADC and MCU (P89 & MCP3008)
005E            193       CE_ADC    EQU  P1.7;P2.4   ;SS
005E            194       MY_MOSI   EQU  P3.1 ;P2.2  ;MOSI
005E            195       MY_MISO   EQU  P0.3   ;MISO
005E            196       MY_SCLK   EQU  P0.2   ;SPICLK
005E            197       
005E            198   ;include files
                546   $LIST
                201   	    $LIST
0399            203   ;Strings
0399            204     ;                       1234567890123456
0399            205      ;General
0399 0D0A00     206       Newline:          db   '\r', '\n', 0
039C 20202020   207       Space:            db   '      ','\r', '\n', 0
     20200D0A
     00
03A5 20202020   208       nothing:          db '                ',0      
     20202020
     20202020
     20202020
     00
03B6 20202020   209       test2:            db '      Test2     ',0
     20205465
     73743220
     20202020
     00
03C7 20202020   210       hot:                           db '      HOT       ', 0
     2020484F
     54202020
     20202020
     00
03D8 3A00       211       dots:             db ':',0
03DA 74696D65   212       timee:            db 'time', 0
     00
03DF 3100       213       statee:           db '1', 0
03E1            214   
03E1 4243445F   215       Initial_Message:  db 'BCD_counter: xx ', 0
     636F756E
     7465723A
     20787820
     00
03F2            216      ;Home page
03F2 54656D70   217       Temp0:            db 'Temp:xxxC       ', 0
     3A787878
     43202020
     20202020
     00
0403 54696D65   218       Time:             db 'Time xx:xx SET  ', 0
     2078783A
     78782053
     45542020
     00
0414            219      ;Second Page
0414 2020534F   220       soak_reflw:       db '  SOAK  REFLOW  ', 0
     414B2020
     5245464C
     4F572020
     00
0425            221      ;Reflow Setup
0425 54656D70   222       reflow_setup:     db 'Temp',0
     00
042A 2A524546   223       reflow_setup4:    db '*REFLOW*',0
     4C4F572A
     00
0433 54696D65   224       reflow_setup2:    db 'Time',0
     00
0438 484F4D45   225       reflow_setup3:    db 'HOME',0
     00
043D            226      ;Soak Setup
043D 54656D70   227       soak_setup0:      db 'Temp',0
     00
0442 202A534F   228       soak_setup1:      db ' *SOAK*',0
     414B2A00
044A 54696D65   229       soak_setup2:      db 'Time',0
     00
044F 484F4D45   230       soak_setup3:      db 'HOME',0
     00
0454            231   
0454            232       ;Termperature
0454 30313233   233       HexAscii: db '0123456789ABCDEF',0
     34353637
     38394142
     43444546
     00
0465            234   ;------ISR-------;
0465            235       ;---------------------------------;
0465            236       ; Routine to initialize the ISR   ;
0465            237       ; for timer 0                     ;
0465            238       ;---------------------------------;
0465            239       Timer0_Init:
0465 E589       240           mov a, TMOD
0467 54F0       241           anl a, #0xf0 ; Clear the bits for timer 0
0469 4401       242           orl a, #0x01 ; Configure timer 0 as 16-timer
046B F589       243           mov TMOD, a
046D 758C6F     244           mov TH0, #high(TIMER0_RELOAD)
0470 758AFF     245           mov TL0, #low(TIMER0_RELOAD)
0473            246           ; Enable the timer and interrupts
0473 D2A9       247           setb ET0  ; Enable timer 0 interrupt
0475 D28C       248           setb TR0  ; Start timer 0
0477 22         249           ret
0478            250   
0478            251       ;---------------------------------;
0478            252       ; ISR for timer 0.  Set to execute;
0478            253       ; every 1/4096Hz to generate a    ;
0478            254       ; 2048 Hz square wave at pin P3.7 ;
0478            255       ;---------------------------------;
0478            256       Timer0_ISR:
0478 758C6F     257           mov TH0, #high(TIMER0_RELOAD)
047B 758AFF     258           mov TL0, #low(TIMER0_RELOAD)
047E C0E0       259           push acc
0480 C0D0       260           push psw
0482            261           
0482 0548       262           inc Count10ms2
0484 E548       263           mov a, Count10ms2
0486 B43202     264           cjne a, #50, Timer0_ISR_done 
0489 D20C       265           setb my_flag  ; used to refresh the page even if timer 1 is disabled 
048B            266   
048B            267           Timer0_ISR_done:
048B D0D0       268           pop psw
048D D0E0       269           pop acc
048F 32         270           reti
0490            271   
0490            272       ;---------------------------------;
0490            273       ; Routine to initialize the ISR   ;
0490            274       ; for timer 1                     ;
0490            275       ;---------------------------------;
0490            276       Timer1_Init:
0490 E589       277           mov a, TMOD
0492 540F       278           anl a, #0x0f ; Clear the bits for timer 1
0494 4410       279           orl a, #0x10 ; Configure timer 1 as 16-timer
0496 F589       280           mov TMOD, a
0498 758D6F     281           mov TH1, #high(TIMER1_RELOAD)
049B 758BFF     282           mov TL1, #low(TIMER1_RELOAD)
049E            283           ; Enable the timer and interrupts
049E D2AB       284           setb ET1  ; Enable timer 1 interrupt
04A0 D28E       285           setb TR1  ; Start timer 1
04A2 22         286           ret
04A3            287   
04A3            288       ;---------------------------------;
04A3            289       ; ISR for timer 1                 ;
04A3            290       ;---------------------------------;
04A3            291       Timer1_ISR:
04A3 758D6F     292           mov TH1, #high(TIMER1_RELOAD)
04A6 758BFF     293           mov TL1, #low(TIMER1_RELOAD)       
04A9            294           ; The two registers used in the ISR must be saved in the stack
04A9 C0E0       295           push acc
04AB C0D0       296           push psw 
04AD            297           ; Increment the 8-bit 10-mili-second counter
04AD 0547       298           inc Count10ms
04AF            299           ; Increment the 16-bit one mili second counter
04AF            300       Inc_Done:
04AF E547       301           mov a, Count10ms
04B1 9539       302           subb a, pwm ; if pwm greater than a count 10 ms  is  the pin is off else on 
04B3 D4         303           da a
04B4 5005       304           jnc off_segment
04B6 D281       305           setb SQUARE_WAVE
04B8 C3         306           clr c
04B9 8005       307           sjmp pass
04BB            308           off_segment:
04BB C281       309           clr SQUARE_WAVE
04BD C3         310           clr c
04BE 8000       311           sjmp pass
04C0            312           ; Check if 1 second has passed
04C0            313           pass:
04C0 E547       314           mov a, Count10ms
04C2 B4C818     315           cjne a, #200, Timer1_ISR_done ; Warning: this instruction changes the carry flag!
04C5            316           ;----------------------------;
04C5 0537       317           inc sec ; one second has passed
04C7 E537       318           mov a,sec
04C9 D4         319           da a
04CA F537       320           mov sec,a
04CC E537       321           mov a,sec
04CE            322          ; mov minutes, #0
04CE 85E04D     323           mov seconds, acc 
04D1            324           ;----------------------------
04D1            325           ; 500 milliseconds have passed.  Set a flag so the main program knows
04D1 D203       326           setb half_seconds_flag ; Let the main program know half second had passed
04D3            327           ; Reset to zero the 10-milli-seconds counter, it is a 8-bit variable
04D3 754700     328           mov Count10ms, #0x00
04D6            329           ; Increment the BCD counter
04D6 E541       330           mov a, BCD_counter
04D8 2401       331           add a, #0x01
04DA            332       Timer1_ISR_da:
04DA D4         333           da a ; Decimal adjust instruction.  Check datasheet for more details!
04DB F541       334           mov BCD_counter, a
04DD            335           
04DD            336       Timer1_ISR_done:
04DD D0D0       337           pop psw
04DF D0E0       338           pop acc
04E1 32         339           reti
04E2            340   
04E2            341   
04E2            342   
04E2            343   
04E2            344   
04E2            345       ;------------------------------
04E2            346       ;---------------------------------;
04E2            347       ; Routine to initialize the CCU.  ;
04E2            348       ; We are using the CCU timer in a ;
04E2            349       ; manner similar to the timer 2   ;
04E2            350       ; available in other 8051s        ;
04E2            351       ;---------------------------------;
04E2            352       CCU_Init:
04E2 75CDFE     353           mov TH2, #high(CCU_RELOAD)
04E5 75CCB2     354           mov TL2, #low(CCU_RELOAD)
04E8 75CFFE     355           mov TOR2H, #high(CCU_RELOAD)
04EB 75CEB2     356           mov TOR2L, #low(CCU_RELOAD)
04EE 75F980     357           mov TCR21, #10000000b ; Latch the reload value
04F1 75C980     358           mov TICR2, #10000000b ; Enable CCU Timer Overflow Interrupt
04F4 D2EC       359           setb ECCU ; Enable CCU interrupt
04F6 D2C8       360           setb TMOD20 ; Start CCU timer
04F8 22         361           ret
04F9            362   
04F9            363       ;---------------------------------;
04F9            364       ; ISR for CCU.  Used to playback  ;
04F9            365       ; the WAV file stored in the SPI  ;
04F9            366       ; flash memory.                   ;
04F9            367       ;---------------------------------;
04F9            368       CCU_ISR:
04F9 75E900     369           mov TIFR2, #0 ; Clear CCU Timer Overflow Interrupt Flag bit. Actually, it clears all the bits!
04FC            370           
04FC            371           ; The registers used in the ISR must be saved in the stack
04FC C0E0       372           push acc
04FE C0D0       373           push psw
0500            374           
0500            375           ; Check if the play counter is zero.  If so, stop playing sound.
0500 E549       376           mov a, w+0
0502 454A       377           orl a, w+1
0504 454B       378           orl a, w+2
0506 6015       379           jz stop_playing
0508            380           
0508            381           ;;yolo this is gonna fuck with the speaker
0508            382           ; Increment the 16-bit one mili second counter
0508            383         ;  inc Count1ms+0    ; Increment the low 8-bits first
0508            384         ;  mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
0508            385         ;  jnz Inc_Done
0508            386         ;  inc Count1ms+1
0508            387           ; Decrement play counter 'w'.  In this implementation 'w' is a 24-bit counter.
0508 74FF       388           mov a, #0xff
050A 1549       389           dec w+0
050C B54907     390           cjne a, w+0, keep_playing
050F 154A       391           dec w+1
0511 B54A02     392           cjne a, w+1, keep_playing
0514 154B       393           dec w+2
0516            394           
0516            395       keep_playing:
0516            396   
0516 120569     397           lcall Send_SPI ; Read the next byte from the SPI Flash...
0519 F5F5       398           mov AD1DAT3, a ; and send it to the DAC
051B            399           
051B 8006       400           sjmp CCU_ISR_Done
051D            401   
051D            402       stop_playing:
051D C2C8       403           clr TMOD20 ; Stop CCU timer
051F D2A4       404           setb FLASH_CE  ; Disable SPI Flash
0521 C2A7       405           clr SOUND ; Turn speaker off
0523            406   
0523            407       CCU_ISR_Done:        
0523 D0D0       408           pop psw
0525 D0E0       409           pop acc
0527 32         410           reti
0528            411   ;----------------;
0528            412   
0528            413   ;---------------------------------;
0528            414   ; Initial configuration of ports. ;
0528            415   ; After reset the default for the ;
0528            416   ; pins is 'Open Drain'.  This     ;
0528            417   ; routine changes them pins to    ;
0528            418   ; Quasi-bidirectional like in the ;
0528            419   ; original 8051.                  ;
0528            420   ; Notice that P1.2 and P1.3 are   ;
0528            421   ; always 'Open Drain'. If those   ;
0528            422   ; pins are to be used as output   ;
0528            423   ; they need a pull-up resistor.   ;
0528            424   ;---------------------------------;
0528            425   Ports_Init:
0528            426       ; Configure all the ports in bidirectional mode:
0528 758400     427       mov P0M1, #00H
052B 758500     428       mov P0M2, #00H
052E 759100     429       mov P1M1, #00H
0531 759200     430       mov P1M2, #00H ; WARNING: P1.2 and P1.3 need 1 kohm pull-up resistors if used as outputs!
0534 75A400     431       mov P2M1, #00H
0537 75A500     432       mov P2M2, #00H
053A 75B100     433       mov P3M1, #00H
053D 75B200     434       mov P3M2, #00H
0540 22         435            ret
0541            436   
0541            437   ;---------------------------------;
0541            438   ; Initialize ADC1/DAC1 as DAC1.   ;
0541            439   ; Warning, the ADC1/DAC1 can work ;
0541            440   ; only as ADC or DAC, not both.   ;
0541            441   ; The P89LPC9351 has two ADC/DAC  ;
0541            442   ; interfaces.  One can be used as ;
0541            443   ; ADC and the other can be used   ;
0541            444   ; as DAC.  Also configures the    ;
0541            445   ; pin associated with the DAC, in ;
0541            446   ; this case P0.4 as 'Open Drain'. ;
0541            447   ;---------------------------------;
0541            448   InitDAC1:
0541            449       ; Configure pin P0.4 (DAC1 output pin) as open drain
0541 438410     450            orl     P0M1,   #00010000B
0544 438510     451            orl     P0M2,   #00010000B
0547 75A128     452       mov ADMODB, #00101000B ; Select main clock/2 for ADC/DAC.  Also enable DAC1 output (Table 25 of reference manual)
054A 759704     453            mov     ADCON1, #00000100B ; Enable the converter
054D 75F580     454            mov AD1DAT3, #0x80     ; Start value is 3.3V/2 (zero reference for AC WAV file)
0550 22         455            ret
0551            456   
0551            457   ;---------------------------------;
0551            458   ; Change the internal RC osc. clk ;
0551            459   ; from 7.373MHz to 14.746MHz.     ;
0551            460   ;---------------------------------;
0551            461   Double_Clk:
0551 90FFDE     462       mov dptr, #CLKCON
0554 E0         463       movx a, @dptr
0555 4408       464       orl a, #00001000B ; double the clock speed to 14.746MHz
0557 F0         465       movx @dptr,a
0558 22         466            ret
0559            467   
0559            468   ;---------------------------------;
0559            469   ; Initialize the SPI interface    ;
0559            470   ; and the pins associated to SPI. ;
0559            471   ;---------------------------------;
0559            472   Init_SPI:
0559            473            ; Configure MOSI (P2.2), CS* (P2.4), and SPICLK (P2.5) as push-pull outputs (see table 42, page 51)
0559 53A4CB     474            anl P2M1, #low(not(00110100B))
055C 43A534     475            orl P2M2, #00110100B
055F            476            ; Configure MISO (P2.3) as input (see table 42, page 51)
055F 43A408     477            orl P2M1, #00001000B
0562 53A5F7     478            anl P2M2, #low(not(00001000B)) 
0565            479            ; Configure SPI
0565 75E2D0     480            mov SPCTL, #11010000B ; Ignore /SS, Enable SPI, DORD=0, Master=1, CPOL=0, CPHA=0, clk/4
0568 22         481            ret
0569            482   
0569            483   ;---------------------------------;
0569            484   ; Sends AND receives a byte via   ;
0569            485   ; SPI.                            ;
0569            486   ;---------------------------------;
0569            487   Send_SPI:
0569 F5E3       488            mov SPDAT, a
056B            489       Send_SPI_1:
056B E5E1       490           mov a, SPSTAT 
056D 30E7FB     491           jnb acc.7, Send_SPI_1 ; Check SPI Transfer Completion Flag
0570 F5E1       492           mov SPSTAT, a ; Clear SPI Transfer Completion Flag
0572 E5E3       493           mov a, SPDAT ; return received byte via accumulator
0574 22         494           ret
0575            495   
0575            496   ;---------------------------------;
0575            497   ; SPI flash 'write enable'        ;
0575            498   ; instruction.                    ;
0575            499   ;---------------------------------;
0575            500   Enable_Write:
0575 C2A4       501            clr FLASH_CE
0577 7406       502            mov a, #WRITE_ENABLE
0579 120569     503            lcall Send_SPI
057C D2A4       504            setb FLASH_CE
057E 22         505            ret
057F            506   
057F            507   ;---------------------------------;
057F            508   ; This function checks the 'write ;
057F            509   ; in progress' bit of the SPI     ;
057F            510   ; flash memory.                   ;
057F            511   ;---------------------------------;
057F            512   Check_WIP:
057F C2A4       513            clr FLASH_CE
0581 7405       514            mov a, #READ_STATUS
0583 120569     515            lcall Send_SPI
0586 7455       516            mov a, #0x55
0588 120569     517            lcall Send_SPI
058B D2A4       518            setb FLASH_CE
058D 20E0EF     519            jb acc.0, Check_WIP ;  Check the Write in Progress bit
0590 22         520            ret
0591            521            
0591            522   ; Display a binary number in the LCD (must be less than 99).  Number to display passed in accumulator.
0591            523   LCD_number:
0591 C0E0       524            push acc
0593 75F00A     525            mov b, #10
0596 84         526            div ab
0597 4430       527            orl a, #'0'
0599 12031C     528            lcall ?WriteData
059C E5F0       529            mov a, b
059E 4430       530            orl a, #'0'
05A0 12031C     531            lcall ?WriteData
05A3 D0E0       532            pop acc
05A5 22         533            ret
05A6            534   ;SPEAKER
05A6            535       ; Sounds we need in the SPI flash: 0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 30; 40; 50; minutes; seconds;
05A6            536       ; Approximate index of sounds in file 'stop_watch.wav'
05A6            537       ; This was generated using: computer_sender -Asw_index.asm -S2000 stop_watch.wav
05A6            538       sound_index:
05A6 00002D     539           db 0x00, 0x00, 0x2d ; 0 
05A9 003107     540           db 0x00, 0x31, 0x07 ; 1 
05AC 007007     541           db 0x00, 0x70, 0x07 ; 2 
05AF 00ADB9     542           db 0x00, 0xad, 0xb9 ; 3 
05B2 00F266     543           db 0x00, 0xf2, 0x66 ; 4 
05B5 0135D5     544           db 0x01, 0x35, 0xd5 ; 5 
05B8 017D33     545           db 0x01, 0x7d, 0x33 ; 6 
05BB 01C761     546           db 0x01, 0xc7, 0x61 ; 7 
05BE 021279     547           db 0x02, 0x12, 0x79 ; 8 
05C1 0249C1     548           db 0x02, 0x49, 0xc1 ; 9 
05C4 028F7A     549           db 0x02, 0x8f, 0x7a ; 10 
05C7 02D063     550           db 0x02, 0xd0, 0x63 ; 11 
05CA 031B87     551           db 0x03, 0x1b, 0x87 ; 12 
05CD 03630E     552           db 0x03, 0x63, 0x0e ; 13 
05D0 03B95F     553           db 0x03, 0xb9, 0x5f ; 14 
05D3 04113A     554           db 0x04, 0x11, 0x3a ; 15 
05D6 0466C4     555           db 0x04, 0x66, 0xc4 ; 16 
05D9 04C012     556           db 0x04, 0xc0, 0x12 ; 17 
05DC 052698     557           db 0x05, 0x26, 0x98 ; 18 
05DF 0574E9     558           db 0x05, 0x74, 0xe9 ; 19 
05E2 05D28E     559           db 0x05, 0xd2, 0x8e ; 20 
05E5 061D83     560           db 0x06, 0x1d, 0x83 ; 21 -> 30 
05E8 066342     561           db 0x06, 0x63, 0x42 ; 22 -> 40 
05EB 06AAB9     562           db 0x06, 0xaa, 0xb9 ; 23 -> 50 
05EE 06F3D6     563           db 0x06, 0xf3, 0xd6 ; 24 -> Minutes 
05F1 073F02     564           db 0x07, 0x3f, 0x02 ; 25 -> Seconds 
05F4            565   
05F4            566       ; Size of each sound in 'sound_index'
05F4            567       ; Generated using: computer_sender -Asw_index.asm -S2000 stop_watch.wav
05F4            568       Size_Length:
05F4 0030DA     569           db 0x00, 0x30, 0xda ; 0 
05F7 003F00     570           db 0x00, 0x3f, 0x00 ; 1 
05FA 003DB2     571           db 0x00, 0x3d, 0xb2 ; 2 
05FD 0044AD     572           db 0x00, 0x44, 0xad ; 3 
0600 00436F     573           db 0x00, 0x43, 0x6f ; 4 
0603 00475E     574           db 0x00, 0x47, 0x5e ; 5 
0606 004A2E     575           db 0x00, 0x4a, 0x2e ; 6 
0609 004B18     576           db 0x00, 0x4b, 0x18 ; 7 
060C 003748     577           db 0x00, 0x37, 0x48 ; 8 
060F 0045B9     578           db 0x00, 0x45, 0xb9 ; 9 
0612 0040E9     579           db 0x00, 0x40, 0xe9 ; 10 
0615 004B24     580           db 0x00, 0x4b, 0x24 ; 11 
0618 004787     581           db 0x00, 0x47, 0x87 ; 12 
061B 005651     582           db 0x00, 0x56, 0x51 ; 13 
061E 0057DB     583           db 0x00, 0x57, 0xdb ; 14 
0621 00558A     584           db 0x00, 0x55, 0x8a ; 15 
0624 00594E     585           db 0x00, 0x59, 0x4e ; 16 
0627 006686     586           db 0x00, 0x66, 0x86 ; 17 
062A 004E51     587           db 0x00, 0x4e, 0x51 ; 18 
062D 005DA5     588           db 0x00, 0x5d, 0xa5 ; 19 
0630 004AF5     589           db 0x00, 0x4a, 0xf5 ; 20 
0633 0045BF     590           db 0x00, 0x45, 0xbf ; 21 -> 30
0636 004777     591           db 0x00, 0x47, 0x77 ; 22 -> 40
0639 00491D     592           db 0x00, 0x49, 0x1d ; 23 -> 50
063C 004B2C     593           db 0x00, 0x4b, 0x2c ; 24 -> minutes
063F 005C87     594           db 0x00, 0x5c, 0x87 ; 25 -> seconds
0642            595   
0642            596       ; The sound and its length from the two tables above is passed in the accumulator.
0642            597       Play_Sound_Using_Index:
0642 D2A7       598           setb SOUND ; Turn speaker on
0644 C2C8       599           clr TMOD20 ; Stop the CCU from playing previous request
0646 D2A4       600           setb FLASH_CE
0648            601           
0648            602           ; There are three bytes per row in our tables, so multiply index by three
0648 75F003     603           mov b, #3
064B A4         604           mul ab
064C F8         605           mov R0, a ; Make a copy of the index*3
064D            606           
064D C2A4       607           clr FLASH_CE ; Enable SPI Flash
064F 7403       608           mov a, #READ_BYTES
0651 120569     609           lcall Send_SPI
0654            610           ; Set the initial position in memory of where to start playing
0654 9005A6     611           mov dptr, #sound_index
0657 E8         612           mov a, R0
0658 93         613           movc a, @a+dptr
0659 120569     614           lcall Send_SPI
065C A3         615           inc dptr
065D E8         616           mov a, R0
065E 93         617           movc a, @a+dptr
065F 120569     618           lcall Send_SPI
0662 A3         619           inc dptr
0663 E8         620           mov a, R0
0664 93         621           movc a, @a+dptr
0665 120569     622           lcall Send_SPI
0668            623           ; Now set how many bytes to play
0668 9005F4     624           mov dptr, #Size_Length
066B E8         625           mov a, R0
066C 93         626           movc a, @a+dptr
066D F54B       627           mov w+2, a
066F A3         628           inc dptr
0670 E8         629           mov a, R0
0671 93         630           movc a, @a+dptr
0672 F54A       631           mov w+1, a
0674 A3         632           inc dptr
0675 E8         633           mov a, R0
0676 93         634           movc a, @a+dptr
0677 F549       635           mov w+0, a
0679            636           
0679 7400       637           mov a, #0x00 ; Request first byte to send to DAC
067B 120569     638           lcall Send_SPI
067E            639           
067E D2C8       640           setb TMOD20 ; Start playback by enabling CCU timer
0680            641   
0680 22         642           ret
0681            643       
0681            644   ;;;;;;/;;;;;;;;----------------------------------- add all the function in this bracee
0681            645   ;;;;;;/;;;;;;;;----------------------------------- add all the function in this bracee
0681            646   ;;;;;;/;;;;;;;;----------------------------------- add all the function in this bracee
0681            647   ;;;;;;/;;;;;;;;----------------------------------- add all the function in this bracee
0681            648   ;;;;;;/;;;;;;;;----------------------------------- add all the function in this bracee
0681            649   ;;;;;;/;;;;;;;;----------------------------------- add all the function in this brace
0681            650   ;;;;;;/;;;;;;;;----------------------------------- add all the function in this bracee
0681            651   ;;;;;;/;;;;;;;;----------------------------------- add all the function in this bracee
0681            652   ;;;;;;/;;;;;;;;----------------------------------- add all the function in this brace
0681            653   
0681            654   InitSerialPort:
0681            655            ;DEBOUNCING??
0681            656            ; Since the reset button bounces, we need to wait a bit before
0681            657       ; sending messages, otherwise we risk displaying gibberish!
0681            658       ;mov R1, #222
0681            659       ;mov R0, #166
0681            660       ;djnz R0, $   ; 3 cycles->3*45.21123ns*166=22.51519us
0681            661       ;djnz R1, $-4 ; 22.51519us*222=4.998ms
0681            662       ; Now we can proceed with the configuration
0681            663            
0681 75BD00     664            mov     BRGCON,#0x00
0684 75BF00     665            mov     BRGR1,#high(BRVAL)
0687 75BE30     666            mov     BRGR0,#low(BRVAL)
068A 75BD03     667            mov     BRGCON,#0x03 ; Turn-on the baud rate generator
068D 759852     668            mov     SCON,#0x52 ; Serial port in mode 1, ren, txrdy, rxempty
0690 759100     669            mov     P1M1,#0x00 ; Enable pins RxD and TXD
0693 759200     670            mov     P1M2,#0x00 ; Enable pins RxD and TXD
0696 22         671            ret
0697            672   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;    
0697            673   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;     
0697            674   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;     
0697            675   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;     
0697            676   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;     
0697            677   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;     
0697            678   ;INIT_SPI:     
0697            679   ;        setb MY_MISO    ; Make MISO an input pin     
0697            680   ;        clr MY_SCLK     ; For mode (0,0) SCLK is zero     
0697            681   ;        ret
0697            682   ;bit-bang SPI
0697            683   
0697            684   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;     
0697            685   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;     
0697            686   ;;;;;;;;;;;;;;;;;;;;;;;;; check here for e;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;    
0697            687   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;     
0697            688   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;     
0697            689   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;     
0697            690   
0697            691   DO_SPI_G:     
0697 C0E0       692            push acc     
0699 7900       693            mov R1, #0      ; Received byte stored in R1     
069B 7A08       694            mov R2, #8      ; Loop counter (8-bits)
069D            695   DO_SPI_G_LOOP:     
069D E8         696            mov a, R0       ; Byte to write is in R0     
069E 33         697            rlc a           ; Carry flag has bit to write     
069F F8         698            mov R0, a     
06A0 92B1       699            mov MY_MOSI, c 
06A2 D282       700            setb MY_SCLK    ; Transmit     
06A4 A283       701            mov c, MY_MISO  ; Read received bit     
06A6 E9         702            mov a, R1       ; Save received bit in R1    
06A7 33         703            rlc a 
06A8 F9         704            mov R1, a     
06A9 C282       705            clr MY_SCLK     
06AB DAF0       706            djnz R2, DO_SPI_G_LOOP     
06AD D0E0       707            pop acc     
06AF 22         708            ret 
06B0            709            
06B0            710   ;;---------------------------------;
06B0            711   ;; Send a BCD number to PuTTY      ;
06B0            712   ;;---------------------------------;
06B0            713   ;Send_BCD mac
06B0            714   ;        push ar0
06B0            715   ;        mov r0, %0
06B0            716   ;        lcall ?Send_BCD
06B0            717   ;        pop ar0
06B0            718   ;endmac
06B0            719   ;
06B0            720   ;?Send_BCD:
06B0            721   ;        push acc
06B0            722   ;        ; Write most significant digit
06B0            723   ;        mov a, r0
06B0            724   ;        swap a
06B0            725   ;        anl a, #0fh
06B0            726   ;        orl a, #30h
06B0            727   ;        lcall putchar
06B0            728   ;        ; write least significant digit
06B0            729   ;        mov a, r0
06B0            730   ;        anl a, #0fh
06B0            731   ;        orl a, #30h
06B0            732   ;        lcall putchar
06B0            733   ;        pop acc
06B0            734   ;        ret      
06B0            735   
06B0            736   ; Send a character using the serial port
06B0            737   putchar:
06B0 109902     738            jbc     TI,putchar_L1
06B3 80FB       739            sjmp putchar
06B5            740   putchar_L1:
06B5 F599       741            mov     SBUF,a
06B7 22         742            ret
06B8            743            
06B8            744   getchar:
06B8 109802     745            jbc     RI,getchar_L1
06BB 80FB       746            sjmp getchar
06BD            747   getchar_L1:
06BD E599       748            mov     a,SBUF
06BF 22         749            ret     
06C0            750       
06C0            751   ;approximate delay of 1s
06C0            752   Delay:
06C0 7AB2       753       mov R2, #89*2
06C2 79FA       754   L4: mov R1, #250
06C4 78A6       755   L5: mov R0, #166
06C6 D8FE       756   L6: djnz R0, L6 ; 3 cycles->3*45.21123ns*166=22.51519us
06C8 D9FA       757       djnz R1, L5 ; 22.51519us*250=5.629ms
06CA DAF6       758       djnz R2, L4 ; 5.629ms*89=0.5s (approximately)
06CC 22         759       ret
06CD            760       
06CD            761   
06CD            762   
06CD            763   SendTemp:
06CD 900454     764            mov dptr, #HexAscii 
06D0            765            
06D0 E562       766            mov a, bcd+1
06D2 C4         767            swap a
06D3 540F       768            anl a, #0xf
06D5 93         769            movc a, @a+dptr
06D6 1206B0     770            lcall putchar
06D9 E562       771            mov a, bcd+1
06DB 540F       772            anl a, #0xf
06DD 93         773            movc a, @a+dptr
06DE 1206B0     774            lcall putchar
06E1            775   
06E1 742E       776            mov a, #'.'
06E3 1206B0     777            lcall putchar
06E6            778   
06E6 E561       779            mov a, bcd+0
06E8 C4         780            swap a
06E9 540F       781            anl a, #0xf
06EB 93         782            movc a, @a+dptr
06EC 1206B0     783            lcall putchar
06EF E561       784            mov a, bcd+0
06F1 540F       785            anl a, #0xf
06F3 93         786            movc a, @a+dptr
06F4 1206B0     787            lcall putchar
06F7            788            
06F7 740D       789            mov a, #'\r'
06F9 1206B0     790            lcall putchar
06FC 740A       791            mov a, #'\n'
06FE 1206B0     792            lcall putchar   
0701 22         793            ret    
0702            794   
0702            795   SendString:
0702 E4         796       clr a
0703 93         797       movc a, @a+dptr
0704 6006       798       jz SendString_L1
0706 1206B0     799       lcall putchar
0709 A3         800       inc dptr
070A 80F6       801       sjmp SendString  
070C            802   SendString_L1:
070C 22         803            ret
070D            804       
070D            805   new_line:
070D 0D0A00     806         DB '\r' ,'\n', 0     
0710            807       
0710            808   Display_putty:
0710 C000       809            push ar0
0712 A862       809            mov r0, bcd+1
0714 120383     809            lcall ?Send_BCD
0717 D000       809            pop ar0
0719 C000       810            push ar0
071B A861       810            mov r0, bcd+0
071D 120383     810            lcall ?Send_BCD
0720 D000       810            pop ar0
0722 22         811            ret   
0723            812   
0723            813   ;;;;;;/;;;;;;;;----------------------------------- add all thr function in this brace
0723            814   ;---------------------------------------------------------------------------------;
0723            815   ; This is the FSM that plays minutes and seconds after the STOP button is pressed ;
0723            816   ; The state diagram of this FSM is available as 'Stop_Watch_FSM.pdf'              ;
0723            817   
0723            818   ;;;;;;/;;;;;;;;----------------------------------- add all thr function in this brace
0723            819   
0723            820   ;;;;;;/;;;;;;;;----------------------------------- add all thr function in this brace
0723            821   
0723            822   ;;;;;;/;;;;;;;;----------------------------------- add all thr function in this brace
0723            823   
0723            824   ;;;;;;/;;;;;;;;----------------------------------- add all thr function in this brace
0723            825   ;;;;;;/;;;;;;;;----------------------------------- add all thr function in this brace
0723            826   
0723            827   ;;;;;;/;;;;;;;;----------------------------------- add all thr function in this brace
0723            828   
0723            829   ;;;;;;/;;;;;;;;----------------------------------- add all thr function in this brace
0723            830   
0723            831   ;;;;;;/;;;;;;;;----------------------------------- add all thr function in this brace
0723            832       T2S_FSM:
0723 E54E       833           mov a, T2S_FSM_state
0725            834   
0725            835       T2S_FSM_State0: ; Checks for the start signal (T2S_FSM_Start==1)
0725 B40013     836           cjne a, #0, T2S_FSM_State1
0728 30000F     837           jnb T2S_FSM_Start, T2S_FSM_State0_Done
072B            838           ; Check if minutes is larger than 19
072B C3         839           clr c
072C E54C       840           mov a, minutes
072E 9414       841           subb a, #20
0730 5005       842           jnc minutes_gt_19
0732 754E01     843           mov T2S_FSM_state, #1
0735 8003       844           sjmp T2S_FSM_State0_Done
0737            845       minutes_gt_19:
0737 754E03     846           mov T2S_FSM_state, #3
073A            847       T2S_FSM_State0_Done:
073A 22         848           ret
073B            849           
073B            850       T2S_FSM_State1: ; Plays minutes when minutes is less than 20
073B B40109     851           cjne a, #1, T2S_FSM_State2
073E E54C       852           mov a, minutes
0740 120642     853           lcall Play_Sound_Using_Index
0743 754E02     854           mov T2S_FSM_State, #2
0746 22         855           ret 
0747            856   
0747            857       T2S_FSM_State2: ; Stay in this state until sound finishes playing
0747 B40207     858           cjne a, #2, T2S_FSM_State3
074A 20C803     859           jb TMOD20, T2S_FSM_State2_Done 
074D 754E06     860           mov T2S_FSM_State, #6
0750            861       T2S_FSM_State2_Done:
0750 22         862           ret
0751            863   
0751            864       T2S_FSM_State3: ; Plays the tens when minutes is larger than 19, for example for 42 minutes, it plays 'forty'
0751 B4030F     865           cjne a, #3, T2S_FSM_State4
0754 E54C       866           mov a, minutes
0756 75F00A     867           mov b, #10
0759 84         868           div ab
075A 2412       869           add a, #18
075C 120642     870           lcall Play_Sound_Using_Index
075F 754E04     871           mov T2S_FSM_State, #4
0762 22         872           ret
0763            873   
0763            874       T2S_FSM_State4: ; Stay in this state until sound finishes playing
0763 B40407     875           cjne a, #4, T2S_FSM_State5
0766 20C803     876           jb TMOD20, T2S_FSM_State4_Done 
0769 754E05     877           mov T2S_FSM_State, #5
076C            878       T2S_FSM_State4_Done:
076C 22         879           ret
076D            880   
076D            881       T2S_FSM_State5: ; Plays the units when minutes is larger than 19, for example for 42 minutes, it plays 'two'
076D B40511     882           cjne a, #5, T2S_FSM_State6
0770 E54C       883           mov a, minutes
0772 75F00A     884           mov b, #10
0775 84         885           div ab
0776 E5F0       886           mov a, b
0778 6003       887           jz T2S_FSM_State5_Done ; Prevents from playing something like 'forty zero'
077A 120642     888           lcall Play_Sound_Using_Index
077D            889       T2S_FSM_State5_Done:
077D 754E02     890           mov T2S_FSM_State, #2
0780 22         891           ret
0781            892   
0781            893       T2S_FSM_State6: ; Plays the word 'minutes'
0781 B40609     894           cjne a, #6, T2S_FSM_State7
0784 7418       895           mov a, #24 ; Index 24 has the word 'minutes'
0786 120642     896           lcall Play_Sound_Using_Index
0789 754E07     897           mov T2S_FSM_State, #7
078C 22         898           ret
078D            899   
078D            900       T2S_FSM_State7: ; Stay in this state until sound finishes playing
078D B40713     901           cjne a, #7, T2S_FSM_State8
0790 20C80F     902           jb TMOD20, T2S_FSM_State7_Done 
0793            903           ; Done playing previous sound, check if seconds is larger than 19
0793 C3         904           clr c
0794 E54D       905           mov a, seconds
0796 9414       906           subb a, #20
0798 5005       907           jnc seconds_gt_19
079A 754E08     908           mov T2S_FSM_state, #8
079D 809B       909           sjmp T2S_FSM_State0_Done
079F            910       seconds_gt_19:
079F 754E0A     911           mov T2S_FSM_state, #10
07A2            912       T2S_FSM_State7_Done:
07A2 22         913           ret
07A3            914   
07A3            915       T2S_FSM_State8: ; Play the seconds when seconds is less than 20.
07A3 B40809     916           cjne a, #8, T2S_FSM_State9
07A6 E54D       917           mov a, seconds
07A8 120642     918           lcall Play_Sound_Using_Index
07AB 754E09     919           mov T2S_FSM_state, #9
07AE 22         920           ret
07AF            921   
07AF            922       T2S_FSM_State9: ; Stay in this state until sound finishes playing
07AF B40907     923           cjne a, #9, T2S_FSM_State10
07B2 20C803     924           jb TMOD20, T2S_FSM_State9_Done 
07B5 754E0D     925           mov T2S_FSM_State, #13
07B8            926       T2S_FSM_State9_Done:
07B8 22         927           ret
07B9            928   
07B9            929       T2S_FSM_State10:  ; Plays the tens when seconds is larger than 19, for example for 35 seconds, it plays 'thirty'
07B9 B40A0F     930           cjne a, #10, T2S_FSM_State11
07BC E54D       931           mov a, seconds
07BE 75F00A     932           mov b, #10
07C1 84         933           div ab
07C2 2412       934           add a, #18
07C4 120642     935           lcall Play_Sound_Using_Index
07C7 754E0B     936           mov T2S_FSM_state, #11
07CA 22         937           ret
07CB            938   
07CB            939       T2S_FSM_State11: ; Stay in this state until sound finishes playing
07CB B40B07     940           cjne a, #11, T2S_FSM_State12
07CE 20C803     941           jb TMOD20, T2S_FSM_State11_Done 
07D1 754E0C     942           mov T2S_FSM_State, #12
07D4            943       T2S_FSM_State11_Done:
07D4 22         944           ret
07D5            945   
07D5            946       T2S_FSM_State12: ; Plays the units when seconds is larger than 19, for example for 35 seconds, it plays 'five'
07D5 B40C11     947           cjne a, #12, T2S_FSM_State13
07D8 E54D       948           mov a, seconds
07DA 75F00A     949           mov b, #10
07DD 84         950           div ab
07DE E5F0       951           mov a, b
07E0 6003       952           jz T2S_FSM_State12_Done ; Prevents from saying something like 'thirty zero'
07E2 120642     953           lcall Play_Sound_Using_Index
07E5            954       T2S_FSM_State12_Done:
07E5 754E09     955           mov T2S_FSM_State, #9
07E8 22         956           ret
07E9            957   
07E9            958       T2S_FSM_State13: ; Plays the word 'seconds'
07E9 B40D09     959           cjne a, #13, T2S_FSM_State14
07EC 7419       960           mov a, #25 ; Index 25 has the word 'seconds'
07EE 120642     961           lcall Play_Sound_Using_Index
07F1 754E0E     962           mov T2S_FSM_State, #14
07F4 22         963           ret
07F5            964   
07F5            965       T2S_FSM_State14: ; Stay in this state until sound finishes playing
07F5 B40E09     966           cjne a, #14, T2S_FSM_Error
07F8 20C805     967           jb TMOD20, T2S_FSM_State14_Done 
07FB C200       968           clr T2S_FSM_Start 
07FD 754E00     969           mov T2S_FSM_State, #0
0800            970       T2S_FSM_State14_Done:
0800 22         971           ret
0801            972   
0801            973       T2S_FSM_Error: ; If we got to this point, there is an error in the finite state machine.  Restart it.
0801 754E00     974           mov T2S_FSM_state, #0
0804 C200       975           clr T2S_FSM_Start
0806 22         976           ret
0807            977   ;---------------------------------------------------------------------------------;       
0807            978   WaitHalfSec:
0807 7AB2       979               mov R2, #178
0809 79FA       980               Lr3: mov R1, #250
080B 78A6       981               Lr2: mov R0, #166
080D D8FE       982               Lr1: djnz R0, Lr1 ; 3 cycles->3*45.21123ns*166=22.51519us
080F D9FA       983               djnz R1, Lr2 ; 22.51519us*250=5.629ms
0811 DAF6       984               djnz R2, Lr3 ; 5.629ms*89=0.5s (approximately)
0813 22         985               ret
0814            986            
0814            987   
0814            988   ;convert:
0814            989       ;    mov x+0, Result
0814            990       ;    mov x+1, Result+1 
0814            991       ;    mov x+2, #0
0814            992       ;    mov x+3, #0
0814            993       ;    ret
0814            994       ;    
0814            995       ;
0814            996   config_adc:
0814            997            ;read channel 0 of the ADC and transmitting this info to the MCU
0814 C297       998            clr CE_ADC ;enable device (active low)
0816            999            ;transmit the info from channel 0
0816 7801      1000            mov R0, #00000001B ;start bit:1
0818 120697    1001            lcall DO_SPI_G
081B           1002            
081B 7880      1003            mov R0, #10000000B ;read channel 0
081D 120697    1004            lcall DO_SPI_G
0820 E9        1005            mov a, R1          ; R1 contains bits 8 and 9 
0821 5403      1006            anl a, #00000011B  ; We need only the two least significant bits
0823 F55C      1007            mov ch0+1, a    ; Save result high
0825           1008            
0825 7855      1009            mov R0, #55H   ; It doesn't matter what we transmit... 
0827 120697    1010            lcall DO_SPI_G  
082A 895B      1011            mov ch0+0, R1     ; R1 contains bits 0 to 7.  Save result low. 
082C D297      1012            setb CE_ADC ;disable device
082E           1013            
082E C297      1014            clr CE_ADC ;enable device
0830           1015            ;transmit from channel 1
0830 7801      1016            mov R0, #00000001B ;start bit:1
0832 120697    1017            lcall DO_SPI_G
0835           1018            
0835 7890      1019            mov R0, #10010000B ;read channel 1
0837 120697    1020            lcall DO_SPI_G
083A E9        1021            mov a, R1          ; R1 contains bits 8 and 9 
083B 5403      1022            anl a, #00000011B  ; We need only the two least significant bits
083D F55E      1023            mov ch1+1, a    ; Save result high
083F           1024            
083F 7855      1025            mov R0, #55H   ; It doesn't matter what we transmit... 
0841 120697    1026            lcall DO_SPI_G  
0844 895D      1027            mov ch1+0, R1     ; R1 contains bits 0 to 7.  Save result low. 
0846 D297      1028            setb CE_ADC ;disable device (active low)
0848 22        1029            ret
0849           1030   Display_temp:
0849           1031       ;    Load_y(410)
0849           1032       ;    lcall mul32
0849           1033       ;    Load_y(1023)
0849           1034       ;    lcall div32
0849           1035       ;    Load_y(273)
0849           1036       ;    lcall sub32
0849           1037       ;    lcall hex2bcd
0849           1038       ;    lcall InitSerialPort
0849           1039       
0849           1040            ;convert the voltage from ch0(LM335) to temperature and display in putty - ch0 correspond to the cold jnc temp
0849 855B51    1041            mov x+0, ch0
084C 855C52    1042            mov x+1, ch0+1
084F 755300    1043            mov x+2, #0
0852 755400    1044            mov x+3, #0
0855           1045            
0855 75559A    1046            mov y+0, #low (410 % 0x10000) 
0858 755601    1046            mov y+1, #high(410 % 0x10000) 
085B 755700    1046            mov y+2, #low (410 / 0x10000) 
085E 755800    1046            mov y+3, #high(410 / 0x10000) 
0861 1201D8    1047            lcall mul32
0864 7555FF    1048            mov y+0, #low (1023 % 0x10000) 
0867 755603    1048            mov y+1, #high(1023 % 0x10000) 
086A 755700    1048            mov y+2, #low (1023 / 0x10000) 
086D 755800    1048            mov y+3, #high(1023 / 0x10000) 
0870 120265    1049            lcall div32
0873 755511    1050            mov y+0, #low (273 % 0x10000) 
0876 755601    1050            mov y+1, #high(273 % 0x10000) 
0879 755700    1050            mov y+2, #low (273 / 0x10000) 
087C 755800    1050            mov y+3, #high(273 / 0x10000) 
087F 120144    1051            lcall sub32 
0882 12005E    1052            lcall hex2bcd
0885           1053            ;lcall Display_putty
0885           1054            
0885           1055            ;do the same for ch1(output voltage of OP AMP) - ch1 corresponds to the hot jnc temp
0885 855D51    1056            mov x+0, ch1
0888 855E52    1057            mov x+1, ch1+1
088B 755300    1058            mov x+2, #0
088E 755400    1059            mov x+3, #0
0891           1060            
0891 755540    1061            mov y+0, #low (1000000 % 0x10000) 
0894 755642    1061            mov y+1, #high(1000000 % 0x10000) 
0897 75570F    1061            mov y+2, #low (1000000 / 0x10000) 
089A 755800    1061            mov y+3, #high(1000000 / 0x10000) 
089D 1201D8    1062            lcall mul32
08A0 755554    1063            mov y+0, #low (OP_AMP_GAIN % 0x10000) 
08A3 755601    1063            mov y+1, #high(OP_AMP_GAIN % 0x10000) 
08A6 755700    1063            mov y+2, #low (OP_AMP_GAIN / 0x10000) 
08A9 755800    1063            mov y+3, #high(OP_AMP_GAIN / 0x10000) 
08AC 120265    1064            lcall div32
08AF 755529    1065            mov y+0, #low (41 % 0x10000) 
08B2 755600    1065            mov y+1, #high(41 % 0x10000) 
08B5 755700    1065            mov y+2, #low (41 / 0x10000) 
08B8 755800    1065            mov y+3, #high(41 / 0x10000) 
08BB 120265    1066            lcall div32 
08BE           1067   
08BE 755540    1068            mov y+0, #low (8000 % 0x10000) 
08C1 75561F    1068            mov y+1, #high(8000 % 0x10000) 
08C4 755700    1068            mov y+2, #low (8000 / 0x10000) 
08C7 755800    1068            mov y+3, #high(8000 / 0x10000) 
08CA 120123    1069       lcall add32
08CD 755502    1070            mov y+0, #low (258 % 0x10000) 
08D0 755601    1070            mov y+1, #high(258 % 0x10000) 
08D3 755700    1070            mov y+2, #low (258 / 0x10000) 
08D6 755800    1070            mov y+3, #high(258 / 0x10000) 
08D9 120265    1071       lcall div32
08DC 12005E    1072       lcall hex2bcd
08DF           1073       
08DF C0E0      1074            push acc
08E1 7401      1074            mov a, #1
08E3 14        1074            dec a
08E4 120368    1074            lcall ?Set_Cursor_1 ; Select column and row
08E7 D0E0      1074            pop acc
08E9 C083      1075            push dph
08EB C082      1075            push dpl
08ED C0E0      1075            push acc
08EF 9003F2    1075            mov dptr, #Temp0
08F2 12035B    1075            lcall ?Send_Constant_String
08F5 D0E0      1075            pop acc
08F7 D082      1075            pop dpl
08F9 D083      1075            pop dph
08FB           1076       ;    lcall SendString
08FB           1077       ;    Set_Cursor(1, 5)    
08FB           1078       ;    Send_BCD(bcd+1) ; send fisrt 2 digits to putty
08FB           1079       ;    Display_BCD(bcd+1); send fisrt 2 digits to lcd
08FB C0E0      1080            push acc
08FD 7407      1080            mov a, #7
08FF 14        1080            dec a
0900 120368    1080            lcall ?Set_Cursor_1 ; Select column and row
0903 D0E0      1080            pop acc 
0905 C000      1081            push ar0
0907 A861      1081            mov r0, bcd
0909 120383    1081            lcall ?Send_BCD
090C D000      1081            pop ar0 ; send last 2 digits to putty
090E C000      1082            push ar0
0910 A861      1082            mov r0, bcd+0
0912 12036D    1082            lcall ?Display_BCD
0915 D000      1082            pop ar0 ; send last 2 digits to lcd
0917           1083       ;    Set_Cursor(1, 5)
0917           1084       ;    Send_Constant_String(#dots)
0917 120702    1085           lcall SendString
091A 900399    1086           mov DPTR, #Newline
091D 120702    1087           lcall SendString
0920 22        1088     ret
0921           1089   
0921           1090   Reset_timer:
0921           1091   
0921 C28E      1092       clr TR1                 ; Stop timer 2
0923 E4        1093       clr a
0924 754700    1094            mov Count10ms, #0x00
0927           1095            ; Now clear the BCD counter and minutes
0927 F541      1096            mov BCD_counter, a
0929 D28E      1097            setb TR1                ; Start timer 2
092B           1098   
092B 22        1099       ret
092C           1100   Display_time:
092C C0E0      1101            push acc
092E 7401      1101            mov a, #1
0930 14        1101            dec a
0931 120366    1101            lcall ?Set_Cursor_2 ; Select column and row
0934 D0E0      1101            pop acc
0936 C083      1102            push dph
0938 C082      1102            push dpl
093A C0E0      1102            push acc
093C 900403    1102            mov dptr, #Time
093F 12035B    1102            lcall ?Send_Constant_String
0942 D0E0      1102            pop acc
0944 D082      1102            pop dpl
0946 D083      1102            pop dph
0948 C203      1103       clr half_seconds_flag ; We clear this flag in the main loop, but it is set in the ISR for timer 2
094A C20C      1104       clr my_flag
094C C0E0      1105            push acc
094E 7409      1105            mov a, #9
0950 14        1105            dec a
0951 120366    1105            lcall ?Set_Cursor_2 ; Select column and row
0954 D0E0      1105            pop acc     ; the place in the LCD where we want the BCD counter value
0956 C000      1106            push ar0
0958 A841      1106            mov r0, BCD_counter
095A 12036D    1106            lcall ?Display_BCD
095D D000      1106            pop ar0 ; This macro is also in 'LCD_4bit.inc'
095F C0E0      1107            push acc
0961 7406      1107            mov a, #6
0963 14        1107            dec a
0964 120366    1107            lcall ?Set_Cursor_2 ; Select column and row
0967 D0E0      1107            pop acc     ; the place in the LCD where we want the BCD counter value
0969 C000      1108            push ar0
096B A84C      1108            mov r0, minutes
096D 12036D    1108            lcall ?Display_BCD
0970 D000      1108            pop ar0 ; This macro is also in 'LCD_4bit.inc'
0972           1109   
0972 22        1110       ret
0973           1111   ;;Timer couter 
0973           1112       sec_counter: 
0973 E541      1113           mov a,BCD_counter
0975 B4600A    1114           cjne a, #0x60, Continue1 ; check if the couter reached 60s
0978 E54C      1115           mov a, minutes
097A 2401      1116           add a, #0x01 ; add one to the minutes
097C D4        1117           da a ; Decimal adjust instruction.  Check datasheet for more details!
097D F54C      1118           mov minutes, a
097F 120921    1119           lcall Reset_timer
0982           1120                Continue1:
0982 22        1121           ret
0983           1122       min_counter:
0983 E54C      1123                    mov a,minutes
0985 B4600A    1124                    cjne a, #0x60, Continue2
0988 C28E      1125                    clr TR1                 ; Stop timer 2
098A E4        1126                    clr a                   
098B 754700    1127                    mov Count10ms, #0x00      ; Now clear the BCD counter
098E F54C      1128                    mov minutes, a              ; Reset minutes
0990 D28E      1129           setb TR1                ; Start timer 2
0992           1130   
0992           1131                    Continue2:
0992 22        1132           ret
0993           1133   home_page:
0993           1134       ; Press Button 2.7 to clean the time
0993 20A71B    1135       jb P2.7, continue20
0996 C002      1136            push AR2
0998 7A32      1136            mov R2, #50
099A 1202D7    1136            lcall ?Wait_Milli_Seconds
099D D002      1136            pop AR2 ; debounce
099F 20A70F    1137       jb P2.7, continue20
09A2 30A7FD    1138       jnb p2.7, $
09A5           1139      ;clr TR1 
09A5 753400    1140       mov state , #0
09A8 754100    1141       mov BCD_counter, #0x00
09AB 754C00    1142       mov minutes, #0x0   
09AE 12092C    1143       lcall Display_time
09B1           1144   
09B1           1145      continue20:
09B1           1146       ;--------Timer----------;
09B1           1147   
09B1 300309    1148       jnb half_seconds_flag, Temp_sensor
09B4 120973    1149       lcall sec_counter
09B7 120983    1150       lcall min_counter
09BA 12092C    1151       lcall Display_time
09BD           1152   
09BD           1153       ;-----------------------;
09BD           1154   
09BD           1155       ;-----TEMP SENSOR-------;
09BD           1156       Temp_sensor:
09BD           1157      ;  lcall config_adc
09BD           1158      ; lcall Display_temp
09BD           1159     ;   lcall  WaitHalfSec 
09BD           1160    ;    ;-----------------------;
09BD           1161   
09BD           1162   
09BD           1163   
09BD           1164   
09BD 22        1165       ret
09BE           1166   
09BE           1167   setup_reflow_page:
09BE 20A011    1168            jb set_BUTTON, continue9
09C1 C002      1168            push AR2
09C3 7A0A      1168            mov R2, #10
09C5 1202D7    1168            lcall ?Wait_Milli_Seconds
09C8 D002      1168            pop AR2
09CA 20A005    1168            jb set_BUTTON, continue9
09CD 30A0FD    1168            jnb set_BUTTON, $
09D0           1168   
09D0 B209      1169       cpl tt_reflow_flag
09D2           1170       continue9:
09D2           1171   
09D2 200906    1172       jb tt_reflow_flag, jump1
09D5           1173       ;jnb tt_reflow_flag, jump1
09D5 120AB7    1174       lcall INC_DEC_Reflow_time
09D8 0209DE    1175       ljmp display_reflow_page
09DB           1176       jump1:
09DB 120AFF    1177       lcall INC_DEC_Reflow_temp
09DE           1178   
09DE           1179   
09DE           1180       display_reflow_page:
09DE C0E0      1181            push acc
09E0 7405      1181            mov a, #5
09E2 14        1181            dec a
09E3 120368    1181            lcall ?Set_Cursor_1 ; Select column and row
09E6 D0E0      1181            pop acc
09E8 C000      1182            push ar0
09EA A83C      1182            mov r0, reflow_temp+0
09EC 12036D    1182            lcall ?Display_BCD
09EF D000      1182            pop ar0
09F1 C0E0      1183            push acc
09F3 7407      1183            mov a, #7
09F5 14        1183            dec a
09F6 120368    1183            lcall ?Set_Cursor_1 ; Select column and row
09F9 D0E0      1183            pop acc
09FB C000      1184            push ar0
09FD A83D      1184            mov r0, reflow_temp+1
09FF 12036D    1184            lcall ?Display_BCD
0A02 D000      1184            pop ar0
0A04           1185          
0A04           1186       
0A04 C0E0      1187            push acc
0A06 7401      1187            mov a, #1
0A08 14        1187            dec a
0A09 120368    1187            lcall ?Set_Cursor_1 ; Select column and row
0A0C D0E0      1187            pop acc
0A0E C083      1188            push dph
0A10 C082      1188            push dpl
0A12 C0E0      1188            push acc
0A14 900425    1188            mov dptr, #reflow_setup
0A17 12035B    1188            lcall ?Send_Constant_String
0A1A D0E0      1188            pop acc
0A1C D082      1188            pop dpl
0A1E D083      1188            pop dph
0A20 C0E0      1189            push acc
0A22 7409      1189            mov a, #9
0A24 14        1189            dec a
0A25 120368    1189            lcall ?Set_Cursor_1 ; Select column and row
0A28 D0E0      1189            pop acc
0A2A C083      1190            push dph
0A2C C082      1190            push dpl
0A2E C0E0      1190            push acc
0A30 90042A    1190            mov dptr, #reflow_setup4
0A33 12035B    1190            lcall ?Send_Constant_String
0A36 D0E0      1190            pop acc
0A38 D082      1190            pop dpl
0A3A D083      1190            pop dph
0A3C           1191   
0A3C C0E0      1192            push acc
0A3E 7401      1192            mov a, #1
0A40 14        1192            dec a
0A41 120366    1192            lcall ?Set_Cursor_2 ; Select column and row
0A44 D0E0      1192            pop acc
0A46 C083      1193            push dph
0A48 C082      1193            push dpl
0A4A C0E0      1193            push acc
0A4C 900433    1193            mov dptr, #reflow_setup2
0A4F 12035B    1193            lcall ?Send_Constant_String
0A52 D0E0      1193            pop acc
0A54 D082      1193            pop dpl
0A56 D083      1193            pop dph
0A58 C0E0      1194            push acc
0A5A 7408      1194            mov a, #8
0A5C 14        1194            dec a
0A5D 120366    1194            lcall ?Set_Cursor_2 ; Select column and row
0A60 D0E0      1194            pop acc
0A62 C083      1195            push dph
0A64 C082      1195            push dpl
0A66 C0E0      1195            push acc
0A68 9003D8    1195            mov dptr, #dots
0A6B 12035B    1195            lcall ?Send_Constant_String
0A6E D0E0      1195            pop acc
0A70 D082      1195            pop dpl
0A72 D083      1195            pop dph
0A74 C0E0      1196            push acc
0A76 740C      1196            mov a, #12
0A78 14        1196            dec a
0A79 120366    1196            lcall ?Set_Cursor_2 ; Select column and row
0A7C D0E0      1196            pop acc
0A7E C083      1197            push dph
0A80 C082      1197            push dpl
0A82 C0E0      1197            push acc
0A84 900438    1197            mov dptr, #reflow_setup3
0A87 12035B    1197            lcall ?Send_Constant_String
0A8A D0E0      1197            pop acc
0A8C D082      1197            pop dpl
0A8E D083      1197            pop dph
0A90 C0E0      1198            push acc
0A92 7409      1198            mov a, #9
0A94 14        1198            dec a
0A95 120366    1198            lcall ?Set_Cursor_2 ; Select column and row
0A98 D0E0      1198            pop acc
0A9A C000      1199            push ar0
0A9C A843      1199            mov r0, reflow_sec
0A9E 12036D    1199            lcall ?Display_BCD
0AA1 D000      1199            pop ar0
0AA3 C0E0      1200            push acc
0AA5 7406      1200            mov a, #6
0AA7 14        1200            dec a
0AA8 120366    1200            lcall ?Set_Cursor_2 ; Select column and row
0AAB D0E0      1200            pop acc
0AAD C000      1201            push ar0
0AAF A844      1201            mov r0, reflow_min
0AB1 12036D    1201            lcall ?Display_BCD
0AB4 D000      1201            pop ar0
0AB6           1202   
0AB6 22        1203       ret
0AB7           1204       INC_DEC_Reflow_time:
0AB7           1205   
0AB7 20A124    1206            jb SETUP_SOAK_Button, check_decrement
0ABA C002      1206            push AR2
0ABC 7A0A      1206            mov R2, #10
0ABE 1202D7    1206            lcall ?Wait_Milli_Seconds
0AC1 D002      1206            pop AR2
0AC3 20A118    1206            jb SETUP_SOAK_Button, check_decrement
0AC6 30A1FD    1206            jnb SETUP_SOAK_Button, $
0AC9           1206    ; setup soak is also used to increment 
0AC9           1207   
0AC9 E543      1208           mov a, reflow_sec
0ACB B4590B    1209           cjne a, #0x59, add_reflow_sec
0ACE E544      1210           mov a, reflow_min
0AD0 2401      1211           add a, #0x01
0AD2 D4        1212           da a
0AD3 F544      1213           mov reflow_min, a
0AD5 E4        1214           clr a 
0AD6 020ADC    1215           ljmp Continue5
0AD9           1216           add_reflow_sec:
0AD9 2401      1217           add a, #0x01
0ADB D4        1218           da a ; Decimal adjust instruction.  Check datasheet for more details!
0ADC           1219           Continue5:
0ADC F543      1220           mov reflow_sec, a
0ADE           1221   
0ADE           1222           check_decrement:
0ADE 20A61D    1223            jb Button_min, continue8
0AE1 C002      1223            push AR2
0AE3 7A0A      1223            mov R2, #10
0AE5 1202D7    1223            lcall ?Wait_Milli_Seconds
0AE8 D002      1223            pop AR2
0AEA 20A611    1223            jb Button_min, continue8
0AED 30A6FD    1223            jnb Button_min, $
0AF0           1223   
0AF0 E543      1224           mov a, reflow_sec
0AF2 B40004    1225           cjne a, #0x00, sub_reflow_sec
0AF5 E4        1226           clr a 
0AF6 020AFC    1227           ljmp Continue6
0AF9           1228           sub_reflow_sec:
0AF9 2499      1229           add a, #0x99 ; add 99 reduces 1
0AFB D4        1230           da a ; Decimal adjust instruction.  Check datasheet for more details!
0AFC           1231           Continue6:
0AFC F543      1232           mov reflow_sec, a
0AFE           1233           continue8:
0AFE 22        1234           ret
0AFF           1235       INC_DEC_Reflow_temp:
0AFF           1236   
0AFF 20A121    1237            jb SETUP_SOAK_Button, check_decrement2
0B02 C002      1237            push AR2
0B04 7A0A      1237            mov R2, #10
0B06 1202D7    1237            lcall ?Wait_Milli_Seconds
0B09 D002      1237            pop AR2
0B0B 20A115    1237            jb SETUP_SOAK_Button, check_decrement2
0B0E 30A1FD    1237            jnb SETUP_SOAK_Button, $
0B11           1237    ; SET UP IS ALSO USED TO INCREMENT 
0B11 E53D      1238               mov a, reflow_temp+1
0B13 2401      1239               add a, #0x01
0B15 D4        1240               da a ; Decimal adjust instruction.  Check datasheet for more details!
0B16 F53D      1241               mov reflow_temp+1, a
0B18 E53D      1242               mov a, reflow_temp+1
0B1A 7007      1243               jnz INC_reflow_temp_done2
0B1C E53C      1244               mov a, reflow_temp+0
0B1E 2401      1245               add a, #0x01
0B20 D4        1246               da a ; Decimal adjust instruction.  Check datasheet for more details!
0B21 F53C      1247               mov reflow_temp+0, a
0B23           1248               INC_reflow_temp_done2:
0B23           1249               
0B23           1250           hold_done:
0B23           1251           
0B23           1252   
0B23           1253   
0B23           1254           check_decrement2:
0B23           1255   
0B23 20A621    1256            jb Button_min, DEC_reflow_temp_done2
0B26 C002      1256            push AR2
0B28 7A0A      1256            mov R2, #10
0B2A 1202D7    1256            lcall ?Wait_Milli_Seconds
0B2D D002      1256            pop AR2
0B2F 20A615    1256            jb Button_min, DEC_reflow_temp_done2
0B32 30A6FD    1256            jnb Button_min, $
0B35           1256   
0B35           1257            ;   jb Button_min, DEC_reflow_temp_done2  
0B35           1258            ;       Wait_Milli_Seconds(#50)         
0B35           1259            ;   jb Button_min, DEC_reflow_temp_done2  
0B35           1260            ;   loop_hold_dec:
0B35           1261   
0B35           1262            ;   jnb Button_min, jump3
0B35           1263            ;   ljmp DEC_reflow_temp_done2
0B35           1264            ;   jump3:
0B35           1265            ;   Set_Cursor(1, 5)
0B35           1266            ;   Display_BCD(reflow_temp+0)
0B35           1267            ;   Set_Cursor(1, 7)
0B35           1268            ;   Display_BCD(reflow_temp+1)
0B35           1269            ;   Wait_Milli_Seconds(#100)    
0B35 E53D      1270               mov a, reflow_temp+1
0B37 2499      1271               add a, #0x99
0B39 D4        1272               da a ; Decimal adjust instruction.  Check datasheet for more details!
0B3A F53D      1273               mov reflow_temp+1, a
0B3C E53D      1274               mov a, reflow_temp+1
0B3E 7007      1275               jnz INC_reflow_temp_done
0B40 E53C      1276               mov a, reflow_temp+0
0B42 2499      1277               add a, #0x99
0B44 D4        1278               da a ; Decimal adjust instruction.  Check datasheet for more details!
0B45 F53C      1279               mov reflow_temp+0, a
0B47           1280             ;  mov a, reflow_temp+1
0B47           1281               INC_reflow_temp_done:
0B47           1282               
0B47           1283             ;  ljmp loop_hold_dec
0B47           1284   
0B47           1285           DEC_reflow_temp_done2:
0B47           1286       
0B47           1287   
0B47 22        1288       ret
0B48           1289   setup_soak_page:
0B48 20A011    1290            jb set_BUTTON, continue11
0B4B C002      1290            push AR2
0B4D 7A0A      1290            mov R2, #10
0B4F 1202D7    1290            lcall ?Wait_Milli_Seconds
0B52 D002      1290            pop AR2
0B54 20A005    1290            jb set_BUTTON, continue11
0B57 30A0FD    1290            jnb set_BUTTON, $
0B5A           1290   
0B5A B20A      1291       cpl tt_flag_soak
0B5C           1292       continue11:
0B5C           1293   
0B5C 200A06    1294       jb tt_flag_soak, jump4
0B5F 120C41    1295       lcall INC_DEC_soak_time
0B62 020B68    1296       ljmp display_soak_page
0B65           1297       jump4:
0B65 120C89    1298       lcall INC_DEC_soak_temp
0B68           1299   
0B68           1300   
0B68           1301       display_soak_page:
0B68 C0E0      1302            push acc
0B6A 7405      1302            mov a, #5
0B6C 14        1302            dec a
0B6D 120368    1302            lcall ?Set_Cursor_1 ; Select column and row
0B70 D0E0      1302            pop acc
0B72 C000      1303            push ar0
0B74 A83E      1303            mov r0, soak_temp+0
0B76 12036D    1303            lcall ?Display_BCD
0B79 D000      1303            pop ar0
0B7B C0E0      1304            push acc
0B7D 7407      1304            mov a, #7
0B7F 14        1304            dec a
0B80 120368    1304            lcall ?Set_Cursor_1 ; Select column and row
0B83 D0E0      1304            pop acc
0B85 C000      1305            push ar0
0B87 A83F      1305            mov r0, soak_temp+1
0B89 12036D    1305            lcall ?Display_BCD
0B8C D000      1305            pop ar0
0B8E           1306          
0B8E           1307       
0B8E C0E0      1308            push acc
0B90 7401      1308            mov a, #1
0B92 14        1308            dec a
0B93 120368    1308            lcall ?Set_Cursor_1 ; Select column and row
0B96 D0E0      1308            pop acc
0B98 C083      1309            push dph
0B9A C082      1309            push dpl
0B9C C0E0      1309            push acc
0B9E 90043D    1309            mov dptr, #soak_setup0
0BA1 12035B    1309            lcall ?Send_Constant_String
0BA4 D0E0      1309            pop acc
0BA6 D082      1309            pop dpl
0BA8 D083      1309            pop dph
0BAA C0E0      1310            push acc
0BAC 7409      1310            mov a, #9
0BAE 14        1310            dec a
0BAF 120368    1310            lcall ?Set_Cursor_1 ; Select column and row
0BB2 D0E0      1310            pop acc
0BB4           1310   
0BB4 C083      1311            push dph
0BB6 C082      1311            push dpl
0BB8 C0E0      1311            push acc
0BBA 900442    1311            mov dptr, #soak_setup1
0BBD 12035B    1311            lcall ?Send_Constant_String
0BC0 D0E0      1311            pop acc
0BC2 D082      1311            pop dpl
0BC4 D083      1311            pop dph
0BC6           1312   
0BC6 C0E0      1313            push acc
0BC8 7401      1313            mov a, #1
0BCA 14        1313            dec a
0BCB 120366    1313            lcall ?Set_Cursor_2 ; Select column and row
0BCE D0E0      1313            pop acc
0BD0           1313   
0BD0 C083      1314            push dph
0BD2 C082      1314            push dpl
0BD4 C0E0      1314            push acc
0BD6 90044A    1314            mov dptr, #soak_setup2
0BD9 12035B    1314            lcall ?Send_Constant_String
0BDC D0E0      1314            pop acc
0BDE D082      1314            pop dpl
0BE0 D083      1314            pop dph
0BE2 C0E0      1315            push acc
0BE4 7408      1315            mov a, #8
0BE6 14        1315            dec a
0BE7 120366    1315            lcall ?Set_Cursor_2 ; Select column and row
0BEA D0E0      1315            pop acc
0BEC           1315   
0BEC C083      1316            push dph
0BEE C082      1316            push dpl
0BF0 C0E0      1316            push acc
0BF2 9003D8    1316            mov dptr, #dots
0BF5 12035B    1316            lcall ?Send_Constant_String
0BF8 D0E0      1316            pop acc
0BFA D082      1316            pop dpl
0BFC D083      1316            pop dph
0BFE C0E0      1317            push acc
0C00 740C      1317            mov a, #12
0C02 14        1317            dec a
0C03 120366    1317            lcall ?Set_Cursor_2 ; Select column and row
0C06 D0E0      1317            pop acc
0C08 C083      1318            push dph
0C0A C082      1318            push dpl
0C0C C0E0      1318            push acc
0C0E 90044F    1318            mov dptr, #soak_setup3
0C11 12035B    1318            lcall ?Send_Constant_String
0C14 D0E0      1318            pop acc
0C16 D082      1318            pop dpl
0C18 D083      1318            pop dph
0C1A C0E0      1319            push acc
0C1C 7409      1319            mov a, #9
0C1E 14        1319            dec a
0C1F 120366    1319            lcall ?Set_Cursor_2 ; Select column and row
0C22 D0E0      1319            pop acc
0C24           1319   
0C24 C000      1320            push ar0
0C26 A845      1320            mov r0, soak_sec
0C28 12036D    1320            lcall ?Display_BCD
0C2B D000      1320            pop ar0
0C2D C0E0      1321            push acc
0C2F 7406      1321            mov a, #6
0C31 14        1321            dec a
0C32 120366    1321            lcall ?Set_Cursor_2 ; Select column and row
0C35 D0E0      1321            pop acc
0C37 C000      1322            push ar0
0C39 A846      1322            mov r0, soak_min
0C3B 12036D    1322            lcall ?Display_BCD
0C3E D000      1322            pop ar0
0C40 22        1323       ret
0C41           1324       INC_DEC_soak_time:
0C41           1325       
0C41 20A124    1326            jb SETUP_SOAK_Button, check_decrement_soak
0C44 C002      1326            push AR2
0C46 7A0A      1326            mov R2, #10
0C48 1202D7    1326            lcall ?Wait_Milli_Seconds
0C4B D002      1326            pop AR2
0C4D 20A118    1326            jb SETUP_SOAK_Button, check_decrement_soak
0C50 30A1FD    1326            jnb SETUP_SOAK_Button, $
0C53           1326    ; setup soak is also used to increment 
0C53           1327   
0C53 E545      1328           mov a, soak_sec
0C55 B4590B    1329           cjne a, #0x59, add_soak_sec
0C58 E546      1330           mov a, soak_min
0C5A 2401      1331           add a, #0x01
0C5C D4        1332           da a
0C5D F546      1333           mov soak_min, a
0C5F E4        1334           clr a 
0C60 020C66    1335           ljmp Continue12
0C63           1336           add_soak_sec:
0C63 2401      1337           add a, #0x01
0C65 D4        1338           da a ; Decimal adjust instruction.  Check datasheet for more details!
0C66           1339           Continue12:
0C66 F545      1340           mov soak_sec, a
0C68           1341   
0C68           1342           check_decrement_soak:
0C68 20A61D    1343            jb Button_min, continue13
0C6B C002      1343            push AR2
0C6D 7A0A      1343            mov R2, #10
0C6F 1202D7    1343            lcall ?Wait_Milli_Seconds
0C72 D002      1343            pop AR2
0C74 20A611    1343            jb Button_min, continue13
0C77 30A6FD    1343            jnb Button_min, $
0C7A           1343   
0C7A E545      1344           mov a, soak_sec
0C7C B40004    1345           cjne a, #0x00, sub_soak_sec
0C7F E4        1346           clr a 
0C80 020C86    1347           ljmp Continue14
0C83           1348           sub_soak_sec:
0C83 2499      1349           add a, #0x99 ; add 99 reduces 1
0C85 D4        1350           da a ; Decimal adjust instruction.  Check datasheet for more details!
0C86           1351           Continue14:
0C86 F545      1352           mov soak_sec, a
0C88           1353           continue13:
0C88           1354           
0C88 22        1355           ret
0C89           1356       INC_DEC_soak_temp:
0C89           1357           
0C89 20A121    1358            jb SETUP_SOAK_Button, check_decrement2_soak
0C8C C002      1358            push AR2
0C8E 7A0A      1358            mov R2, #10
0C90 1202D7    1358            lcall ?Wait_Milli_Seconds
0C93 D002      1358            pop AR2
0C95 20A115    1358            jb SETUP_SOAK_Button, check_decrement2_soak
0C98 30A1FD    1358            jnb SETUP_SOAK_Button, $
0C9B           1358   
0C9B           1359           ;    jb SETUP_SOAK_Button, check_decrement2_soak  
0C9B           1360           ;        Wait_Milli_Seconds(#50)         
0C9B           1361           ;    jb SETUP_SOAK_Button, check_decrement2_soak  
0C9B           1362           ;    loop_hold_inc_soak:
0C9B           1363         ;
0C9B           1364           ;    jnb SETUP_SOAK_Button, jump6
0C9B           1365           ;    Wait_Milli_Seconds(#100)
0C9B           1366           ;    jnb SETUP_SOAK_Button, jump6
0C9B           1367           ;    ljmp hold_done_soak
0C9B           1368           ;    jump6:
0C9B           1369           ;    Set_Cursor(1, 5)
0C9B           1370           ;    Display_BCD(soak_temp+0)
0C9B           1371           ;    Set_Cursor(1, 7)
0C9B           1372           ;    Display_BCD(soak_temp+1)
0C9B           1373           ;    Wait_Milli_Seconds(#200)    
0C9B E53F      1374               mov a, soak_temp+1
0C9D 2401      1375               add a, #0x01
0C9F D4        1376               da a ; Decimal adjust instruction.  Check datasheet for more details!
0CA0 F53F      1377               mov soak_temp+1, a
0CA2 E53F      1378               mov a, soak_temp+1
0CA4 7007      1379               jnz INC_soak_temp_done2
0CA6 E53E      1380               mov a, soak_temp+0
0CA8 2401      1381               add a, #0x01
0CAA D4        1382               da a ; Decimal adjust instruction.  Check datasheet for more details!
0CAB F53E      1383               mov soak_temp+0, a
0CAD           1384              ; mov a, soak_temp+1
0CAD           1385               INC_soak_temp_done2:
0CAD           1386               
0CAD           1387             ;  ljmp loop_hold_inc_soak
0CAD           1388           hold_done_soak:
0CAD           1389           
0CAD           1390   
0CAD           1391   
0CAD           1392           check_decrement2_soak:
0CAD           1393   
0CAD 20A621    1394            jb Button_min, DEC_soak_temp_done2
0CB0 C002      1394            push AR2
0CB2 7A0A      1394            mov R2, #10
0CB4 1202D7    1394            lcall ?Wait_Milli_Seconds
0CB7 D002      1394            pop AR2
0CB9 20A615    1394            jb Button_min, DEC_soak_temp_done2
0CBC 30A6FD    1394            jnb Button_min, $
0CBF           1394   
0CBF           1395              ; 
0CBF           1396              ; jb Button_min, DEC_soak_temp_done2  
0CBF           1397              ;     Wait_Milli_Seconds(#50)         
0CBF           1398              ; jb Button_min, DEC_soak_temp_done2  
0CBF           1399              ; loop_hold_dec_soak:
0CBF           1400                ;
0CBF           1401              ; jnb Button_min, jump7
0CBF           1402              ; Wait_Milli_Seconds(#100)
0CBF           1403              ; jnb Button_min, jump7
0CBF           1404              ; ljmp DEC_soak_temp_done2
0CBF           1405              ; jump7:
0CBF           1406              ; Set_Cursor(1, 5)
0CBF           1407              ; Display_BCD(soak_temp+0)
0CBF           1408              ; Set_Cursor(1, 7)
0CBF           1409              ; Display_BCD(soak_temp+1)
0CBF           1410              ; Wait_Milli_Seconds(#100)    
0CBF E53F      1411               mov a, soak_temp+1
0CC1 2499      1412               add a, #0x99
0CC3 D4        1413               da a ; Decimal adjust instruction.  Check datasheet for more details!
0CC4 F53F      1414               mov soak_temp+1, a
0CC6 E53F      1415               mov a, soak_temp+1
0CC8 7007      1416               jnz INC_soak_temp_done
0CCA E53E      1417               mov a, soak_temp+0
0CCC 2499      1418               add a, #0x99
0CCE D4        1419               da a ; Decimal adjust instruction.  Check datasheet for more details!
0CCF F53E      1420               mov soak_temp+0, a
0CD1           1421             ;  mov a, soak_temp+1
0CD1           1422               INC_soak_temp_done:
0CD1           1423               
0CD1           1424              ; ljmp loop_hold_dec_soak
0CD1           1425   
0CD1           1426           DEC_soak_temp_done2:
0CD1 22        1427           ret
0CD2           1428   second_page:
0CD2 C0E0      1429            push acc
0CD4 7401      1429            mov a, #1
0CD6 14        1429            dec a
0CD7 120368    1429            lcall ?Set_Cursor_1 ; Select column and row
0CDA D0E0      1429            pop acc
0CDC C083      1430            push dph
0CDE C082      1430            push dpl
0CE0 C0E0      1430            push acc
0CE2 900414    1430            mov dptr, #soak_reflw
0CE5 12035B    1430            lcall ?Send_Constant_String
0CE8 D0E0      1430            pop acc
0CEA D082      1430            pop dpl
0CEC D083      1430            pop dph
0CEE C0E0      1431            push acc
0CF0 7401      1431            mov a, #1
0CF2 14        1431            dec a
0CF3 120366    1431            lcall ?Set_Cursor_2 ; Select column and row
0CF6 D0E0      1431            pop acc
0CF8 C083      1432            push dph
0CFA C082      1432            push dpl
0CFC C0E0      1432            push acc
0CFE 9003A5    1432            mov dptr, #nothing
0D01 12035B    1432            lcall ?Send_Constant_String
0D04 D0E0      1432            pop acc
0D06 D082      1432            pop dpl
0D08 D083      1432            pop dph
0D0A 22        1433       ret
0D0B           1434   
0D0B           1435   FSM_LCD:
0D0B E535      1436           mov a, state_lcd
0D0D           1437   
0D0D           1438   
0D0D           1439           ;----------------STATE 0------------------;
0D0D           1440            home_state:
0D0D B4001E    1441               cjne a, #0, soak_reflow_state
0D10 20A015    1442            jb set_BUTTON, done_home2
0D13 C002      1442            push AR2
0D15 7A0A      1442            mov R2, #10
0D17 1202D7    1442            lcall ?Wait_Milli_Seconds
0D1A D002      1442            pop AR2
0D1C 20A009    1442            jb set_BUTTON, done_home2
0D1F 30A0FD    1442            jnb set_BUTTON, $
0D22           1442     
0D22           1443               ; If pushbutton set_Button is pressed it changes to soak_reflow Page otherwise it stays at the home page
0D22 753501    1444               mov state_lcd, #1
0D25 020D2B    1445               ljmp done_home
0D28           1446               done_home2:
0D28 120993    1447               lcall home_page
0D2B           1448               done_home:
0D2B 020DCA    1449               ljmp Forever_done           
0D2E           1450           ;------------------------------------------;
0D2E           1451           
0D2E           1452        ;   ;----------------STATE 1-------------------;
0D2E           1453           soak_reflow_state:
0D2E B4014B    1454               cjne a, #1, setup_soak
0D31 120CD2    1455               lcall second_page
0D34           1456             ;  Wait_Milli_Seconds(#50)
0D34 120973    1457               lcall sec_counter ; prevent the timer to go over 60
0D37 120983    1458               lcall min_counter
0D3A 20A712    1459            jb HOME_BUTTON, next_pushb
0D3D C002      1459            push AR2
0D3F 7A0A      1459            mov R2, #10
0D41 1202D7    1459            lcall ?Wait_Milli_Seconds
0D44 D002      1459            pop AR2
0D46 20A706    1459            jb HOME_BUTTON, next_pushb
0D49 30A7FD    1459            jnb HOME_BUTTON, $
0D4C           1459    ; check if home button is pressed 
0D4C 753500    1460               mov state_lcd, #0
0D4F           1461               next_pushb:
0D4F 20A112    1462            jb SETUP_SOAK_Button, next_pushb2
0D52 C002      1462            push AR2
0D54 7A0A      1462            mov R2, #10
0D56 1202D7    1462            lcall ?Wait_Milli_Seconds
0D59 D002      1462            pop AR2
0D5B 20A106    1462            jb SETUP_SOAK_Button, next_pushb2
0D5E 30A1FD    1462            jnb SETUP_SOAK_Button, $
0D61           1462    ; check if the the button to setup soak is pressed
0D61 753502    1463               mov state_lcd, #2
0D64           1464               next_pushb2:
0D64 20A612    1465            jb Button_min, done_soak
0D67 C002      1465            push AR2
0D69 7A0A      1465            mov R2, #10
0D6B 1202D7    1465            lcall ?Wait_Milli_Seconds
0D6E D002      1465            pop AR2
0D70 20A606    1465            jb Button_min, done_soak
0D73 30A6FD    1465            jnb Button_min, $
0D76           1465    ; check if the buttion to setup the reflow was pressed 
0D76 753503    1466               mov state_lcd, #3
0D79           1467               done_soak:
0D79 020DCA    1468              ljmp Forever_done 
0D7C           1469           ;------------------------------------------;
0D7C           1470   
0D7C           1471        ;   ;-----------------STATE 2------------------;
0D7C           1472           setup_soak: ; its actually set up reflow Im dumb
0D7C B40221    1473               cjne a, #2, setup_reflow
0D7F 1209BE    1474               lcall setup_reflow_page
0D82           1475             ;  Wait_Milli_Seconds(#50)
0D82 120973    1476               lcall sec_counter ; prevent the timer to go over 60
0D85 120983    1477               lcall min_counter
0D88 20A712    1478            jb HOME_BUTTON, done_setup_soak
0D8B C002      1478            push AR2
0D8D 7A0A      1478            mov R2, #10
0D8F 1202D7    1478            lcall ?Wait_Milli_Seconds
0D92 D002      1478            pop AR2
0D94 20A706    1478            jb HOME_BUTTON, done_setup_soak
0D97 30A7FD    1478            jnb HOME_BUTTON, $
0D9A           1478    ; check if home button is pressed 
0D9A 753500    1479               mov state_lcd, #0
0D9D           1480               done_setup_soak:
0D9D 020DCA    1481               ljmp Forever_done 
0DA0           1482           ;------------------------------------------;
0DA0           1483   
0DA0           1484        ;   ;----------------STATE 3-------------------;
0DA0           1485           setup_reflow: ; its actually set up soak Im dumb
0DA0 B40303    1486               cjne a, #3, FDP
0DA3 020DA9    1487               ljmp FDP2
0DA6           1488               FDP:
0DA6 020D0D    1489               ljmp home_state
0DA9           1490               FDP2:
0DA9 120B48    1491               lcall setup_soak_page
0DAC 120973    1492               lcall sec_counter ; prevent the timer to go over 60
0DAF 120983    1493               lcall min_counter
0DB2 20A712    1494            jb HOME_BUTTON, done_setup_reflow
0DB5 C002      1494            push AR2
0DB7 7A0A      1494            mov R2, #10
0DB9 1202D7    1494            lcall ?Wait_Milli_Seconds
0DBC D002      1494            pop AR2
0DBE 20A706    1494            jb HOME_BUTTON, done_setup_reflow
0DC1 30A7FD    1494            jnb HOME_BUTTON, $
0DC4           1494    ; check if home button is pressed 
0DC4 753500    1495               mov state_lcd, #0
0DC7           1496               done_setup_reflow:
0DC7 020DCA    1497               ljmp Forever_done 
0DCA           1498        ;   ;------------------------------------------;
0DCA           1499           Forever_done:
0DCA 22        1500    ret
0DCB           1501   
0DCB           1502   ;---------------------------------;
0DCB           1503   ; Main program. Includes hardware ;
0DCB           1504   ; initialization and 'forever'    ;
0DCB           1505   ; loop.                           ;
0DCB           1506   ;---------------------------------;
0DCB           1507   main:
0DCB           1508            ; Initialization
0DCB 75817F    1509       mov SP, #0x7F
0DCE 120465    1510       lcall Timer0_Init
0DD1 120490    1511       lcall Timer1_Init
0DD4           1512   
0DD4           1513   
0DD4 120326    1514       lcall LCD_4BIT
0DD7 120551    1515       lcall Double_Clk
0DDA 120541    1516            lcall InitDAC1 ; Call after 'Ports_Init'
0DDD 1204E2    1517            lcall CCU_Init
0DE0 120559    1518            lcall Init_SPI
0DE3           1519       ;;;;; TEMP
0DE3 120528    1520            lcall Ports_Init
0DE6 120681    1521       lcall InitSerialPort
0DE9 75A400    1522       mov P2M1, #0
0DEC 75A500    1523       mov P2M2, #0
0DEF           1524            
0DEF D2AF      1525            setb EA ; Enable global interrupts.
0DF1           1526   
0DF1           1527            ; Initialize variables
0DF1 C200      1528            clr T2S_FSM_Start
0DF3 754E00    1529            mov T2S_FSM_state, #0
0DF6           1530       ; Configure all the ports in bidirectional mode:
0DF6           1531   
0DF6           1532   
0DF6           1533       ;mov minutes, #0
0DF6 754D00    1534            mov seconds, #0
0DF9           1535   
0DF9           1536      ; lcall LCD_4BIT
0DF9           1537       ; For convenience a few handy macros are included in 'LCD_4bit_LPC9351.inc':
0DF9           1538    ;       Set_Cursor(1, 1)
0DF9           1539     ;  Display_BCD(BCD_counter)
0DF9           1540   
0DF9 D203      1541       setb half_seconds_flag
0DFB D20C      1542       setb my_flag   
0DFD           1543   
0DFD 754100    1544            mov BCD_counter, #0x00
0E00 753900    1545            mov pwm , #0
0E03 753700    1546            mov sec , #0
0E06 753400    1547            mov state, #0
0E09 753696    1548            mov temp, #150
0E0C 753105    1549       mov time_soak, #5
0E0F 7532DC    1550       mov temp_refl, #220
0E12 753005    1551       mov temp_soak, #5
0E15 755000    1552       mov five_sec_flag,#0
0E18           1553            ; After initialization the program stays in this 'forever' loop
0E18           1554   
0E18 754300    1555       mov reflow_sec, #0x00
0E1B 754400    1556       mov reflow_min, #0x00
0E1E 754C00    1557       mov minutes, #0x00
0E21 753500    1558       mov state_lcd, #0
0E24 C208      1559       clr TR1_flag
0E26 753C01    1560       mov reflow_temp+0, #0x01
0E29 753D50    1561       mov reflow_temp+1, #0x50
0E2C C209      1562       clr tt_reflow_flag
0E2E 754500    1563       mov soak_sec, #0x00
0E31 754600    1564       mov soak_min, #0x00
0E34           1565   
0E34 753E01    1566       mov soak_temp+0, #0x01
0E37 753F50    1567       mov soak_temp+1, #0x50
0E3A C20B      1568       clr stop_flag
0E3C           1569   
0E3C           1570       
0E3C           1571   forever:         
0E3C 120D0B    1572       lcall FSM_LCD
0E3F           1573   
0E3F 120723    1574       lcall T2S_FSM ; Speaker fsm
0E42           1575   
0E42           1576     Check_if_stop_button_is_on:
0E42 20A614    1577       jb P2.6, continue19 
0E45 C002      1578            push AR2
0E47 7A32      1578            mov R2, #50
0E49 1202D7    1578            lcall ?Wait_Milli_Seconds
0E4C D002      1578            pop AR2 ; debounce
0E4E 20A608    1579            jb P2.6, continue19
0E51 30A6FD    1580            jnb P2.6, $
0E54 C28E      1581            clr TR1 
0E56 020E3C    1582            ljmp forever
0E59           1583      continue19:
0E59           1584   
0E59           1585    FSM_PWM:  
0E59 E534      1586       mov a, state
0E5B           1587     state0: 
0E5B B40013    1588         cjne a, #0, state1
0E5E 753900    1589         mov pwm, #0
0E61 C28E      1590         clr TR1
0E63 20B008    1591         jb p3.0, state0_done
0E66 30B0FD    1592         jnb p3.0, $ ;wait for key release
0E69 D28E      1593         setb TR1
0E6B 753401    1594         mov state, #1
0E6E           1595     state0_done:
0E6E 020E3C    1596         ljmp forever
0E71           1597      
0E71           1598      state1:
0E71 B40113    1599         cjne a, #1 , state2
0E74 753964    1600         mov pwm, #100
0E77 753700    1601         mov sec, #0
0E7A E530      1602         mov a, temp_soak
0E7C C3        1603         clr c
0E7D 9536      1604         subb a, temp
0E7F           1605         ;add branches to compare temp with 150
0E7F 5003      1606         jnc state1_done
0E81 753402    1607         mov state, #2
0E84           1608     state1_done:
0E84 020E3C    1609          ljmp forever
0E87           1610          
0E87           1611     state2: ;press p3.0 multiple time plz cos it is stuck
0E87 B40210    1612         cjne a, #2 , state3
0E8A 753914    1613         mov pwm, #20
0E8D E531      1614         mov a, time_soak
0E8F C3        1615         clr c
0E90 9537      1616         subb a, sec
0E92           1617         ;add branches to compare sec with  60
0E92 5003      1618         jnc state2_done
0E94 753403    1619         mov state, #3
0E97           1620     state2_done:
0E97 020E3C    1621          ljmp forever          
0E9A           1622     
0E9A           1623     state3:
0E9A B40313    1624         cjne a, #3 , state4
0E9D 753950    1625         mov pwm, #80
0EA0 753700    1626         mov sec, #0     
0EA3 E532      1627         mov a, temp_refl
0EA5 C3        1628         clr c
0EA6 9536      1629         subb a, temp
0EA8           1630         ;add branches to compare temp with 220
0EA8 5003      1631         jnc state3_done
0EAA 753404    1632         mov state, #4
0EAD           1633     state3_done:
0EAD 020E3C    1634          ljmp forever
0EB0           1635          
0EB0           1636      state4:
0EB0 B40410    1637         cjne a, #4 , state5
0EB3 753914    1638         mov pwm, #20
0EB6 E533      1639         mov a, time_refl
0EB8 C3        1640         clr c
0EB9 9537      1641         subb a, sec
0EBB           1642         ;add branches to compare sec with 45
0EBB 5003      1643         jnc state4_done
0EBD 753405    1644         mov state, #5
0EC0           1645     state4_done:
0EC0 020E3C    1646          ljmp forever    
0EC3           1647          
0EC3           1648      state5:
0EC3 B40595    1649         cjne a, #5 , state0
0EC6 753900    1650         mov pwm, #0
0EC9 C3        1651         clr c
0ECA 9536      1652         subb a, temp
0ECC           1653         ;add branches to compare temp with 60
0ECC 5003      1654         jnc state5_done
0ECE 753400    1655         mov state, #0
0ED1           1656     state5_done:
0ED1 020E3C    1657          ljmp forever 
0ED4           1658          
0ED4           1659   
0ED4           1660   EN
