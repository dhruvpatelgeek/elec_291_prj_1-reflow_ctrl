0000              1   ; ISR_example.asm: a) Increments/decrements a BCD variable every half second using
0000              2   ; an ISR for timer 2; b) Generates a 2kHz square wave at pin P3.7 using
0000              3   ; an ISR for timer 0; and c) in the 'main' loop it displays the variable
0000              4   ; incremented/decremented using the ISR for timer 2 on the LCD.  Also resets it to 
0000              5   ; zero if the 'CLEAR' pushbutton connected to P1.7 is pressed.
0000              6   ; Start/Constants
                  8       $LIST
0000             10   
0000             11       CLK           EQU 7373000  ; Microcontroller system crystal frequency in Hz
0000             12       TIMER0_RATE   EQU 100     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0000             13       TIMER0_RELOAD EQU ((65536-(CLK/(2*TIMER0_RATE))))
0000             14       TIMER1_RATE   EQU 100     ; 100Hz, for a timer tick of 10ms
0000             15       TIMER1_RELOAD EQU ((65536-(CLK/(2*TIMER1_RATE))))
0000             16   
0000             17   
0000             18   
0000             19       CCU_RATE    EQU 11025     ; 22050Hz is the sampling rate of the wav file we are playing
0000             20       CCU_RELOAD  EQU ((65536-((CLK/(2*CCU_RATE)))))
0000             21       BAUD        EQU 115200
0000             22       BRVAL       EQU ((CLK/BAUD)-16)
0000             23   
0000             24   XTAL EQU (14746000/2) 
0000             25   
0000             26   
0000             27   OP_AMP_GAIN EQU 340 ;what is the exact gain?
0000             28   
0000             29       
0000             30   
0000             31       ; Commands supported by the SPI flash memory according to the datasheet
0000             32       WRITE_ENABLE     EQU 0x06  ; Address:0 Dummy:0 Num:0
0000             33       WRITE_DISABLE    EQU 0x04  ; Address:0 Dummy:0 Num:0
0000             34       READ_STATUS      EQU 0x05  ; Address:0 Dummy:0 Num:1 to infinite
0000             35       READ_BYTES       EQU 0x03  ; Address:3 Dummy:0 Num:1 to infinite
0000             36       READ_SILICON_ID  EQU 0xab  ; Address:0 Dummy:3 Num:1 to infinite
0000             37       FAST_READ        EQU 0x0b  ; Address:3 Dummy:1 Num:1 to infinite
0000             38       WRITE_STATUS     EQU 0x01  ; Address:0 Dummy:0 Num:1
0000             39       WRITE_BYTES      EQU 0x02  ; Address:3 Dummy:0 Num:1 to 256
0000             40       ERASE_ALL        EQU 0xc7  ; Address:0 Dummy:0 Num:0
0000             41       ERASE_BLOCK      EQU 0xd8  ; Address:3 Dummy:0 Num:0
0000             42       READ_DEVICE_ID   EQU 0x9f  ; Address:0 Dummy:2 Num:1 to infinite
0000             43   ;Vectors
0000             44       ; Reset vector
0000             45       org 0x0000
0000 020DC9      46           ljmp main
0003             47   
0003             48       ; External interrupt 0 vector (not used in this code)
0003             49       org 0x0003
0003 32          50           reti
0004             51   
0004             52       ; Timer/Counter 0 overflow interrupt vector
000B             53       org 0x000B
000B 020662      54           ljmp Timer0_ISR
000E             55   
000E             56       ; External interrupt 1 vector (not used in this code)
0013             57       org 0x0013
0013 32          58           reti
0014             59   
0014             60       ; Timer/Counter 1 overflow interrupt vector
001B             61       org 0x001B
001B 02068D      62           ljmp Timer1_ISR
001E             63   
001E             64       ; Serial port receive/transmit interrupt vector (not used in this code)
0023             65       org 0x0023 
0023 32          66           reti
0024             67   
005B             68       org 0x005b ; CCU interrupt vector.  Used in this code to replay the wave file.
005B 0206EA      69           ljmp CCU_ISR
005E             70   
005E             71   
005E             72       ;                                                        -                     
005E             73       ;                                                       -  -                    
005E             74       ;                                                      -    -                   
005E             75       ;                              leave it at this temp>>-      -                  
005E             76       ;                                                    -        -                 
005E             77       ;                                                   -          -                 
005E             78       ;                                                  -            -               
005E             79       ;                                                 -              -              
005E             80       ;                                                -                -             
005E             81       ;                                               -                  -            
005E             82       ;                                              -                    -           
005E             83       ;                                             -    reflow>>cool     -          
005E             84       ;               -----------------------------    (temperature only)  -         
005E             85       ;              -     soak (time+temp)                                 -        
005E             86       ;             -                                                        -       
005E             87       ;            -                                                          -       
005E             88       ;          -                                                             -      
005E             89       ;         -                                                               -     
005E             90       ;        -                                                                 -    
005E             91       ;      -                                                                    -    
005E             92       ;     - ramp to soak (temperature)                                           -   
005E             93       ;   -                                                                         -   
005E             94       ;   state 1 ((temp==soak)? ssr_off: ssr_on)
005E             95       ;          state 2 ((time=soak_time)?(pwm_off):(pwn_on)
005E             96       ;                                           state 3 ((temp==soak)? ssr_off: ssr_on)
005E             97       ;                                                        state 4 (cooling ssr_off)
005E             98       ;                                                                             state 5 (done)
005E             99   
005E            100       ; In the 8051 we can define direct access variables starting at location 0x30 up to location 0x7F
005E            101   ;Variables(dseg) 
0030            102      dseg AT 30H
0030            103   ;variables we need
0030            104   x: ds 4
0034            105   y: ds 4
0038            106   Result: ds 2 
003A            107   ch0: ds 2
003C            108   ch1: ds 2
003E            109   oven_temp: ds 2
0040            110   bcd: ds 5
0045            111   
0045            112       
0045            113       ;FSM varialbles
0045            114       temp_soak:       ds 1 ; temp to soak
0046            115       time_soak:       ds 1 ; time to soak
0047            116       temp_refl:       ds 1 ; temp of relfow
0048            117       time_refl:       ds 1 ; time to reflow 
0049            118       state:           ds 1 ; current state 
004A            119       state_lcd:       ds 1
004B            120       temp:            ds 1 ; current temp in degree C
004C            121       sec:             ds 1 ; current time in seconds 
004D            122       product:         ds 1; pwm-currsec
004E            123       pwm:             ds 1 ; 
004F            124   
004F            125       ;Timer variables
004F            126       Count1ms:        ds 2 ; Used to determine when half second has passed
0051            127       reflow_temp:     ds 2
0053            128       soak_temp:       ds 2
0055            129       reflow_time:     ds 2
0057            130       soak_time:       ds 2
0059            131       reflow_temp_var: ds 1
005A            132       BCD_counter:     ds 1 ; The BCD counter incrememted in the ISR and displayed in the main loop
005B            133       hour:            ds 1
005C            134       reflow_sec:      ds 1
005D            135       reflow_min:      ds 1
005E            136       soak_sec:        ds 1
005F            137       soak_min:        ds 1
0060            138       Count10ms:       ds 1 ; Used to determine when half second has passed
0061            139       Count10ms2:      ds 1
0062            140       w:               ds 3 ; 24-bit play counter.  Decremented in CCU ISR.
0065            141       minutes:         ds 1
0066            142       seconds:         ds 1
0067            143       T2S_FSM_state:   ds 1
0068            144       Count5ms:        ds 1
0069            145       five_sec_flag:   ds 1
006A            146   
006A            147   ;flags(bseg)
0000            148       BSEG
0000            149       T2S_FSM_start:     dbit 1
0001            150       seconds_flag:      dbit 1
0002            151       mf:                dbit 1
0003            152       half_seconds_flag: dbit 1 ; Set to one in the ISR every time 500 ms had passed
0004            153       AMPM_flag:         dbit 1
0005            154       alarm_AMPM_flag:   dbit 1
0006            155       on_off_flag:       dbit 1 ; 1 is on
0007            156       alarm_buzzer_flag: dbit 1
0008            157       TR1_flag:          dbit 1
0009            158       tt_reflow_flag:    dbit 1
000A            159       tt_flag_soak:      dbit 1
000B            160       stop_flag:         dbit 1
000C            161       my_flag:           dbit 1
000D            162   
000D            163       ;_ _ _ _ | _ _ _ _ _ _
000D            164       ;
000D            165       ;pwm = 40 (say)
000D            166       ;then output will be 100 
000D            167       ;_________
000D            168       ;         |
000D            169       ;         |_____________
000D            170       ; where period is 1 second 
000D            171       ; In the 8051 we have variables that are 1-bit in size.  We can use the setb, clr, jb, and jnb
000D            172       ; instructions with these variables.  This is how you define a 1-bit variable:
000D            173   
000D            174   ;Pin config(cseg)
000D            175   
005E            176       cseg
005E            177       ; These 'equ' must match the wiring between the microcontroller and the LCD!
005E            178        LCD_RS equ P0.5
005E            179       LCD_RW equ P0.6
005E            180       LCD_E  equ P0.7
005E            181       LCD_D4 equ P1.2
005E            182       LCD_D5 equ P1.3
005E            183       LCD_D6 equ P1.4
005E            184       LCD_D7 equ P1.6
005E            185   
005E            186       CLEAR         equ P0.4
005E            187       FLASH_CE      EQU P1.7
005E            188       SOUND         EQU P3.1
005E            189       stop            equ p0.4
005E            190       
005E            191       SETUP_SOAK_Button equ  P2.1
005E            192       set_BUTTON        equ  P2.0      
005E            193       Button_min        equ  P2.6
005E            194       HOME_BUTTON       equ  P2.7
005E            195   
005E            196       ;define the connections between the ADC and MCU (P89 & MCP3008)
005E            197   CE_ADC    EQU  P2.7;P2.4   ;SS
005E            198   MY_MOSI   EQU  P2.6 ;P2.2  ;MOSI
005E            199   MY_MISO   EQU  P2.5   ;MISO
005E            200   MY_SCLK   EQU  P2.4   ;SPICLK
005E            201   
005E            202   ;include files
                546   $LIST
                205   	    $LIST
0399            207   ;Strings
0399            208     ;                       1234567890123456
0399            209      ;General
0399 0D0A00     210       Newline:          db   '\r', '\n', 0
039C 20202020   211       Space:            db   '      ','\r', '\n', 0
     20200D0A
     00
03A5 20202020   212       nothing:          db '                ',0      
     20202020
     20202020
     20202020
     00
03B6 20202020   213       test2:            db '      Test2     ',0
     20205465
     73743220
     20202020
     00
03C7 20202020   214       hot:                           db '      HOT       ', 0
     2020484F
     54202020
     20202020
     00
03D8 3A00       215       dots:             db ':',0
03DA 74696D65   216       timee:            db 'time', 0
     00
03DF 3100       217       statee:           db '1', 0
03E1            218   
03E1 4243445F   219       Initial_Message:  db 'BCD_counter: xx ', 0
     636F756E
     7465723A
     20787820
     00
03F2            220      ;Home page
03F2 54656D70   221       Temp0:            db 'Temp:           ', 0
     3A202020
     20202020
     20202020
     00
0403 4300       222       the_unit_of_temp:            db 'C', 0
0405 54696D65   223       Time:             db 'Time xx:xx SET  ', 0
     2078783A
     78782053
     45542020
     00
0416            224      ;Second Page
0416 2020534F   225       soak_reflw:       db '  SOAK  REFLOW  ', 0
     414B2020
     5245464C
     4F572020
     00
0427            226      ;Reflow Setup
0427 54656D70   227       reflow_setup:     db 'Temp',0
     00
042C 2A524546   228       reflow_setup4:    db '*REFLOW*',0
     4C4F572A
     00
0435 54696D65   229       reflow_setup2:    db 'Time',0
     00
043A 484F4D45   230       reflow_setup3:    db 'HOME',0
     00
043F            231      ;Soak Setup
043F 54656D70   232       soak_setup0:      db 'Temp',0
     00
0444 202A534F   233       soak_setup1:      db ' *SOAK*',0
     414B2A00
044C 54696D65   234       soak_setup2:      db 'Time            ',0
     20202020
     20202020
     20202020
     00
045D 484F4D45   235       soak_setup3:      db 'HOME',0
     00
0462            236   
0462            237   
0462            238   
0462            239   
0462            240   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0462            241   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0462            242   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0462            243   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0462            244   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0462            245   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0462            246   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0462            247   
0462            248   ; Send a character using the serial port
0462            249   putchar:
0462 109902     250            jbc     TI,putchar_L1
0465 80FB       251            sjmp putchar
0467            252   putchar_L1:
0467 F599       253            mov     SBUF,a
0469 22         254            ret
046A            255            
046A            256   getchar:
046A 109802     257            jbc     RI,getchar_L1
046D 80FB       258            sjmp getchar
046F            259   getchar_L1:
046F E599       260            mov     a,SBUF
0471 22         261            ret     
0472            262       
0472            263   ;approximate delay of 1s
0472            264   Delay:
0472 7AAC       265       mov R2, #86*2
0474 79FA       266   L4: mov R1, #250
0476 78A6       267   L5: mov R0, #166
0478 D8FE       268   L6: djnz R0, L6 ; 3 cycles->3*45.21123ns*166=22.51519us
047A D9FA       269       djnz R1, L5 ; 22.51519us*250=5.629ms
047C DAF6       270       djnz R2, L4 ; 5.629ms*89=0.5s (approximately)
047E 22         271       ret
047F            272   
047F 30313233   273   HexAscii: db '0123456789ABCDEF'
     34353637
     38394142
     43444546
048F            274   
048F            275   
048F            276   SendTemp:
048F 90047F     277            mov dptr, #HexAscii 
0492            278            
0492 E541       279            mov a, bcd+1
0494 C4         280            swap a
0495 540F       281            anl a, #0xf
0497 93         282            movc a, @a+dptr
0498 120462     283            lcall putchar
049B E541       284            mov a, bcd+1
049D 540F       285            anl a, #0xf
049F 93         286            movc a, @a+dptr
04A0 120462     287            lcall putchar
04A3            288   
04A3 742E       289            mov a, #'.'
04A5 120462     290            lcall putchar
04A8            291   
04A8 E540       292            mov a, bcd+0
04AA C4         293            swap a
04AB 540F       294            anl a, #0xf
04AD 93         295            movc a, @a+dptr
04AE 120462     296            lcall putchar
04B1 E540       297            mov a, bcd+0
04B3 540F       298            anl a, #0xf
04B5 93         299            movc a, @a+dptr
04B6 120462     300            lcall putchar
04B9            301            
04B9 740D       302            mov a, #'\r'
04BB 120462     303            lcall putchar
04BE 740A       304            mov a, #'\n'
04C0 120462     305            lcall putchar   
04C3 22         306            ret    
04C4            307   
04C4            308   SendString:
04C4 E4         309       clr a
04C5 93         310       movc a, @a+dptr
04C6 6006       311       jz SendString_L1
04C8 120462     312       lcall putchar
04CB A3         313       inc dptr
04CC 80F6       314       sjmp SendString  
04CE            315   SendString_L1:
04CE 22         316            ret
04CF            317       
04CF            318   new_line:
04CF 0D0A00     319         DB '\r' ,'\n', 0     
04D2            320   
04D2            321   
04D2            322   Display_putty:
04D2 854030     323       mov x, bcd
04D5 12048F     324       lcall SendTemp
04D8            325       
04D8 C0E0       326            push acc
04DA 7405       326            mov a, #5
04DC 14         326            dec a
04DD 120368     326            lcall ?Set_Cursor_1 ; Select column and row
04E0 D0E0       326            pop acc
04E2 C000       327            push ar0
04E4 A841       327            mov r0, bcd+1
04E6 12036D     327            lcall ?Display_BCD
04E9 D000       327            pop ar0
04EB C0E0       328            push acc
04ED 7407       328            mov a, #7
04EF 14         328            dec a
04F0 120368     328            lcall ?Set_Cursor_1 ; Select column and row
04F3 D0E0       328            pop acc
04F5 C000       329            push ar0
04F7 A840       329            mov r0, bcd+0
04F9 12036D     329            lcall ?Display_BCD
04FC D000       329            pop ar0
04FE C0E0       330            push acc
0500 7408       330            mov a, #8
0502 14         330            dec a
0503 120368     330            lcall ?Set_Cursor_1 ; Select column and row
0506 D0E0       330            pop acc
0508            331   
0508 C0E0       332            push acc
050A 740A       332            mov a, #10
050C 14         332            dec a
050D 120368     332            lcall ?Set_Cursor_1 ; Select column and row
0510 D0E0       332            pop acc
0512 C083       333            push dph
0514 C082       333            push dpl
0516 C0E0       333            push acc
0518 900403     333            mov dptr, #the_unit_of_temp
051B 12035B     333            lcall ?Send_Constant_String
051E D0E0       333            pop acc
0520 D082       333            pop dpl
0522 D083       333            pop dph
0524 22         334            ret   
0525            335   
0525            336   Ports_Init:
0525            337       ; Configure all the ports in bidirectional mode:
0525 758400     338       mov P0M1, #00H
0528 758500     339       mov P0M2, #00H
052B 759100     340       mov P1M1, #00H
052E 759200     341       mov P1M2, #00H ; WARNING: P1.2 and P1.3 need 1 kohm pull-up resistors if used as outputs!
0531 75A400     342       mov P2M1, #00H
0534 75A500     343       mov P2M2, #00H
0537 75B100     344       mov P3M1, #00H
053A 75B200     345       mov P3M2, #00H
053D 22         346            ret
053E            347   
053E            348   ;INITIALIZE AND CONFIGURE THE SERIAL PORT OF THE P89
053E            349   InitSerialPort:
053E            350            ;DEBOUNCING??
053E            351            ; Since the reset button bounces, we need to wait a bit before
053E            352       ; sending messages, otherwise we risk displaying gibberish!
053E            353       ;mov R1, #222
053E            354       ;mov R0, #166
053E            355       ;djnz R0, $   ; 3 cycles->3*45.21123ns*166=22.51519us
053E            356       ;djnz R1, $-4 ; 22.51519us*222=4.998ms
053E            357       ; Now we can proceed with the configuration
053E            358            
053E 75BD00     359            mov     BRGCON,#0x00
0541 75BF00     360            mov     BRGR1,#high(BRVAL)
0544 75BE30     361            mov     BRGR0,#low(BRVAL)
0547 75BD03     362            mov     BRGCON,#0x03 ; Turn-on the baud rate generator
054A 759852     363            mov     SCON,#0x52 ; Serial port in mode 1, ren, txrdy, rxempty
054D 759100     364            mov     P1M1,#0x00 ; Enable pins RxD and TXD
0550 759200     365            mov     P1M2,#0x00 ; Enable pins RxD and TXD
0553 22         366            ret
0554            367            
0554            368   
0554            369   DO_SPI_G:
0554 C2AF       370       clr EA
0556 C0E0       371            push acc     
0558 7900       372            mov R1, #0      ; Received byte stored in R1     
055A 7A08       373            mov R2, #8      ; Loop counter (8-bits)
055C            374   DO_SPI_G_LOOP:     
055C E8         375            mov a, R0       ; Byte to write is in R0     
055D 33         376            rlc a           ; Carry flag has bit to write     
055E F8         377            mov R0, a     
055F 92A6       378            mov MY_MOSI, c 
0561 D2A4       379            setb MY_SCLK    ; Transmit     
0563 A2A5       380            mov c, MY_MISO  ; Read received bit     
0565 E9         381            mov a, R1       ; Save received bit in R1    
0566 33         382            rlc a 
0567 F9         383            mov R1, a     
0568 C2A4       384            clr MY_SCLK     
056A DAF0       385            djnz R2, DO_SPI_G_LOOP     
056C D0E0       386            pop acc     
056E D2AF       387       setb EA
0570 22         388            ret 
0571            389            
0571            390   ;---------------------------------;
0571            391   ; Send a BCD number to PuTTY      ;
0571            392   ;---------------------------------;
0571            393   
0571            394   hannah:
0571 C2AF       395   clr EA
0573            396            ;read channel 0 of the ADC and transmitting this info to the MCU
0573 C2A7       397            clr CE_ADC ;enable device (active low)
0575            398            ;transmit the info from channel 0
0575 7801       399            mov R0, #00000001B ;start bit:1
0577 120554     400            lcall DO_SPI_G
057A            401            
057A 7880       402            mov R0, #10000000B ;read channel 0
057C 120554     403            lcall DO_SPI_G
057F E9         404            mov a, R1          ; R1 contains bits 8 and 9 
0580 5403       405            anl a, #00000011B  ; We need only the two least significant bits
0582 F53B       406            mov ch0+1, a    ; Save result high
0584            407            
0584 7855       408            mov R0, #55H   ; It doesn't matter what we transmit... 
0586 120554     409            lcall DO_SPI_G  
0589 893A       410            mov ch0+0, R1     ; R1 contains bits 0 to 7.  Save result low. 
058B D2A7       411            setb CE_ADC ;disable device
058D            412            
058D C2A7       413            clr CE_ADC ;enable device
058F            414            ;transmit from channel 1
058F 7801       415            mov R0, #00000001B ;start bit:1
0591 120554     416            lcall DO_SPI_G
0594            417            
0594 7890       418            mov R0, #10010000B ;read channel 1
0596 120554     419            lcall DO_SPI_G
0599 E9         420            mov a, R1          ; R1 contains bits 8 and 9 
059A 5403       421            anl a, #00000011B  ; We need only the two least significant bits
059C F53D       422            mov ch1+1, a    ; Save result high
059E            423            
059E 7855       424            mov R0, #55H   ; It doesn't matter what we transmit... 
05A0 120554     425            lcall DO_SPI_G  
05A3 893C       426            mov ch1+0, R1     ; R1 contains bits 0 to 7.  Save result low. 
05A5 D2A7       427            setb CE_ADC ;disable device (active low)
05A7            428            
05A7            429    
05A7            430   
05A7            431            
05A7            432            ;convert the voltage from ch0(LM335) to temperature and display in putty - ch0 correspond to the cold jnc temp
05A7 853A30     433            mov x+0, ch0
05AA 853B31     434            mov x+1, ch0+1
05AD 753200     435            mov x+2, #0
05B0 753300     436            mov x+3, #0
05B3            437            
05B3 75349A     438            mov y+0, #low (410 % 0x10000) 
05B6 753501     438            mov y+1, #high(410 % 0x10000) 
05B9 753600     438            mov y+2, #low (410 / 0x10000) 
05BC 753700     438            mov y+3, #high(410 / 0x10000) 
05BF 1201D8     439            lcall mul32
05C2 7534FF     440            mov y+0, #low (1023 % 0x10000) 
05C5 753503     440            mov y+1, #high(1023 % 0x10000) 
05C8 753600     440            mov y+2, #low (1023 / 0x10000) 
05CB 753700     440            mov y+3, #high(1023 / 0x10000) 
05CE 120265     441            lcall div32
05D1 753411     442            mov y+0, #low (273 % 0x10000) 
05D4 753501     442            mov y+1, #high(273 % 0x10000) 
05D7 753600     442            mov y+2, #low (273 / 0x10000) 
05DA 753700     442            mov y+3, #high(273 / 0x10000) 
05DD 120144     443            lcall sub32 
05E0 12005E     444            lcall hex2bcd
05E3            445            ;lcall Display_putty
05E3            446            
05E3            447            ;do the same for ch1(output voltage of OP AMP) - ch1 corresponds to the hot jnc temp
05E3 853C30     448            mov x+0, ch1
05E6 853D31     449            mov x+1, ch1+1
05E9 753200     450            mov x+2, #0
05EC 753300     451            mov x+3, #0
05EF            452            
05EF 753440     453            mov y+0, #low (1000000 % 0x10000) 
05F2 753542     453            mov y+1, #high(1000000 % 0x10000) 
05F5 75360F     453            mov y+2, #low (1000000 / 0x10000) 
05F8 753700     453            mov y+3, #high(1000000 / 0x10000) 
05FB 1201D8     454            lcall mul32
05FE 753454     455            mov y+0, #low (OP_AMP_GAIN % 0x10000) 
0601 753501     455            mov y+1, #high(OP_AMP_GAIN % 0x10000) 
0604 753600     455            mov y+2, #low (OP_AMP_GAIN / 0x10000) 
0607 753700     455            mov y+3, #high(OP_AMP_GAIN / 0x10000) 
060A 120265     456            lcall div32
060D 753429     457            mov y+0, #low (41 % 0x10000) 
0610 753500     457            mov y+1, #high(41 % 0x10000) 
0613 753600     457            mov y+2, #low (41 / 0x10000) 
0616 753700     457            mov y+3, #high(41 / 0x10000) 
0619 120265     458            lcall div32 
061C            459   
061C 753440     460            mov y+0, #low (8000 % 0x10000) 
061F 75351F     460            mov y+1, #high(8000 % 0x10000) 
0622 753600     460            mov y+2, #low (8000 / 0x10000) 
0625 753700     460            mov y+3, #high(8000 / 0x10000) 
0628 120123     461       lcall add32
062B 753402     462            mov y+0, #low (258 % 0x10000) 
062E 753501     462            mov y+1, #high(258 % 0x10000) 
0631 753600     462            mov y+2, #low (258 / 0x10000) 
0634 753700     462            mov y+3, #high(258 / 0x10000) 
0637 120265     463       lcall div32
063A            464       
063A            465       ;load_y(24)
063A            466       ;lcall add32
063A            467       
063A            468       ;load_y(10)
063A            469       ;lcall div32
063A            470   
063A 12005E     471            lcall hex2bcd
063D 120472     472       lcall Delay
0640            473       ;jnb my_flag, continue30
0640            474       ;clr my_flag
0640 853A30     475       mov x+0, ch0
0643 853B31     476            mov x+1, ch0+1
0646 12005E     477       lcall hex2bcd
0649            478            ;lcall Display_putty
0649 D2AF       479       setb EA
064B 12048F     480            lcall SendTemp
064E            481       continue30:
064E            482            ;mov a, #'\r'
064E            483            ;lcall putchar
064E            484            ;mov a, #'\n'
064E            485            ;lcall putchar
064E            486            
064E            487            ;now that we have the cold and hot junction temps in variables ch0 and ch1 respectively, we can add them to get the actual temperature
064E            488            
064E            489   
064E            490      
064E 22         491   ret
064F            492   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
064F            493   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
064F            494   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
064F            495   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
064F            496   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
064F            497   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
064F            498   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
064F            499   
064F            500   ;------ISR-------;
064F            501       ;---------------------------------;
064F            502       ; Routine to initialize the ISR   ;
064F            503       ; for timer 0                     ;
064F            504       ;---------------------------------;
064F            505       Timer0_Init:
064F E589       506           mov a, TMOD
0651 54F0       507           anl a, #0xf0 ; Clear the bits for timer 0
0653 4401       508           orl a, #0x01 ; Configure timer 0 as 16-timer
0655 F589       509           mov TMOD, a
0657 758C6F     510           mov TH0, #high(TIMER0_RELOAD)
065A 758AFF     511           mov TL0, #low(TIMER0_RELOAD)
065D            512           ; Enable the timer and interrupts
065D D2A9       513           setb ET0  ; Enable timer 0 interrupt
065F D28C       514           setb TR0  ; Start timer 0
0661 22         515           ret
0662            516   
0662            517       ;---------------------------------;
0662            518       ; ISR for timer 0.  Set to execute;
0662            519       ; every 1/4096Hz to generate a    ;
0662            520       ; 2048 Hz square wave at pin P3.7 ;
0662            521       ;---------------------------------;
0662            522       Timer0_ISR:
0662 758C6F     523           mov TH0, #high(TIMER0_RELOAD)
0665 758AFF     524           mov TL0, #low(TIMER0_RELOAD)
0668 C0E0       525           push acc
066A C0D0       526           push psw
066C            527           
066C 0561       528           inc Count10ms2
066E E561       529           mov a, Count10ms2
0670 B43202     530           cjne a, #50, Timer0_ISR_done 
0673 D20C       531           setb my_flag  ; used to refresh the page even if timer 1 is disabled 
0675            532   
0675            533           Timer0_ISR_done:
0675 D0D0       534           pop psw
0677 D0E0       535           pop acc
0679 32         536           reti
067A            537   
067A            538       ;---------------------------------;
067A            539       ; Routine to initialize the ISR   ;
067A            540       ; for timer 1                     ;
067A            541       ;---------------------------------;
067A            542       Timer1_Init:
067A E589       543           mov a, TMOD
067C 540F       544           anl a, #0x0f ; Clear the bits for timer 1
067E 4410       545           orl a, #0x10 ; Configure timer 1 as 16-timer
0680 F589       546           mov TMOD, a
0682 758D6F     547           mov TH1, #high(TIMER1_RELOAD)
0685 758BFF     548           mov TL1, #low(TIMER1_RELOAD)
0688            549           ; Enable the timer and interrupts
0688 D2AB       550           setb ET1  ; Enable timer 1 interrupt
068A D28E       551           setb TR1  ; Start timer 1
068C 22         552           ret
068D            553   
068D            554       ;---------------------------------;
068D            555       ; ISR for timer 1                 ;
068D            556       ;---------------------------------;
068D            557       Timer1_ISR:
068D 758D6F     558           mov TH1, #high(TIMER1_RELOAD)
0690 758BFF     559           mov TL1, #low(TIMER1_RELOAD)       
0693            560           ; The two registers used in the ISR must be saved in the stack
0693 C0E0       561           push acc
0695 C0D0       562           push psw 
0697            563           ; Increment the 8-bit 10-mili-second counter
0697 0560       564           inc Count10ms
0699            565           ; Increment the 16-bit one mili second counter
0699            566       Inc_Done:
0699 E560       567           mov a, Count10ms
069B 954E       568           subb a, pwm ; if pwm greater than a pwm is on else off
069D D4         569           da a
069E            570          ; mov a, product
069E 5005       571           jnc off_segment
06A0 D281       572           setb p0.1
06A2 C3         573           clr c
06A3 8005       574           sjmp pass
06A5            575           off_segment:
06A5 C281       576           clr p0.1
06A7 C3         577           clr c
06A8 8000       578           sjmp pass
06AA            579   
06AA            580           ; Check if 1 second has passed
06AA            581           pass:
06AA            582   
06AA            583           ; Check if half second has passed
06AA E560       584           mov a, Count10ms
06AC B4641F     585           cjne a, #100, Timer1_ISR_done ; Warning: this instruction changes the carry flag!
06AF            586           ;----------------------------
06AF 054C       587           inc sec ; one second has passed
06B1 E54C       588           mov a,sec
06B3 D4         589           da a
06B4 F54C       590           mov sec,a
06B6 0569       591           inc five_sec_flag ; one second has passed
06B8 E569       592           mov a,five_sec_flag
06BA D4         593           da a
06BB F569       594           mov five_sec_flag,a
06BD E54C       595           mov a,sec
06BF            596          ; mov minutes, #0
06BF 85E066     597           mov seconds, acc 
06C2            598           ;----------------------------
06C2            599           ; 500 milliseconds have passed.  Set a flag so the main program knows
06C2 D203       600           setb half_seconds_flag ; Let the main program know half second had passed
06C4            601           ; Reset to zero the 10-milli-seconds counter, it is a 8-bit variable
06C4 756000     602           mov Count10ms, #0x00
06C7            603      ;     mov Count1ms, #0x00
06C7            604           ; Increment the BCD counter
06C7 E55A       605           mov a, BCD_counter
06C9 2401       606           add a, #0x01
06CB            607       Timer1_ISR_da:
06CB D4         608           da a ; Decimal adjust instruction.  Check datasheet for more details!
06CC F55A       609           mov BCD_counter, a
06CE            610           
06CE            611       Timer1_ISR_done:
06CE D0D0       612           pop psw
06D0 D0E0       613           pop acc
06D2 32         614           reti
06D3            615   
06D3            616   
06D3            617   
06D3            618   
06D3            619   
06D3            620       ;------------------------------
06D3            621       ;---------------------------------;
06D3            622       ; Routine to initialize the CCU.  ;
06D3            623       ; We are using the CCU timer in a ;
06D3            624       ; manner similar to the timer 2   ;
06D3            625       ; available in other 8051s        ;
06D3            626       ;---------------------------------;
06D3            627       CCU_Init:
06D3 75CDFE     628           mov TH2, #high(CCU_RELOAD)
06D6 75CCB2     629           mov TL2, #low(CCU_RELOAD)
06D9 75CFFE     630           mov TOR2H, #high(CCU_RELOAD)
06DC 75CEB2     631           mov TOR2L, #low(CCU_RELOAD)
06DF 75F980     632           mov TCR21, #10000000b ; Latch the reload value
06E2 75C980     633           mov TICR2, #10000000b ; Enable CCU Timer Overflow Interrupt
06E5 D2EC       634           setb ECCU ; Enable CCU interrupt
06E7 D2C8       635           setb TMOD20 ; Start CCU timer
06E9 22         636           ret
06EA            637   
06EA            638       ;---------------------------------;
06EA            639       ; ISR for CCU.  Used to playback  ;
06EA            640       ; the WAV file stored in the SPI  ;
06EA            641       ; flash memory.                   ;
06EA            642       ;---------------------------------;
06EA            643       CCU_ISR:
06EA 75E900     644           mov TIFR2, #0 ; Clear CCU Timer Overflow Interrupt Flag bit. Actually, it clears all the bits!
06ED            645           
06ED            646           ; The registers used in the ISR must be saved in the stack
06ED C0E0       647           push acc
06EF C0D0       648           push psw
06F1            649           
06F1            650           ; Check if the play counter is zero.  If so, stop playing sound.
06F1 E562       651           mov a, w+0
06F3 4563       652           orl a, w+1
06F5 4564       653           orl a, w+2
06F7 6015       654           jz stop_playing
06F9            655           
06F9            656           ;;yolo this is gonna fuck with the speaker
06F9            657           ; Increment the 16-bit one mili second counter
06F9            658         ;  inc Count1ms+0    ; Increment the low 8-bits first
06F9            659         ;  mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
06F9            660         ;  jnz Inc_Done
06F9            661         ;  inc Count1ms+1
06F9            662           ; Decrement play counter 'w'.  In this implementation 'w' is a 24-bit counter.
06F9 74FF       663           mov a, #0xff
06FB 1562       664           dec w+0
06FD B56207     665           cjne a, w+0, keep_playing
0700 1563       666           dec w+1
0702 B56302     667           cjne a, w+1, keep_playing
0705 1564       668           dec w+2
0707            669           
0707            670       keep_playing:
0707            671   
0707 12073E     672           lcall Send_SPI ; Read the next byte from the SPI Flash...
070A F5F5       673           mov AD1DAT3, a ; and send it to the DAC
070C            674           
070C 8006       675           sjmp CCU_ISR_Done
070E            676   
070E            677       stop_playing:
070E C2C8       678           clr TMOD20 ; Stop CCU timer
0710 D297       679           setb FLASH_CE  ; Disable SPI Flash
0712 C2B1       680           clr SOUND ; Turn speaker off
0714            681   
0714            682       CCU_ISR_Done:        
0714 D0D0       683           pop psw
0716 D0E0       684           pop acc
0718 32         685           reti
0719            686   ;----------------;
0719            687   
0719            688   ;---------------------------------;
0719            689   ; Initial configuration of ports. ;
0719            690   ; After reset the default for the ;
0719            691   ; pins is 'Open Drain'.  This     ;
0719            692   ; routine changes them pins to    ;
0719            693   ; Quasi-bidirectional like in the ;
0719            694   ; original 8051.                  ;
0719            695   ; Notice that P1.2 and P1.3 are   ;
0719            696   ; always 'Open Drain'. If those   ;
0719            697   ; pins are to be used as output   ;
0719            698   ; they need a pull-up resistor.   ;
0719            699   ;---------------------------------;
0719            700   
0719            701   ;---------------------------------;
0719            702   ; Initialize ADC1/DAC1 as DAC1.   ;
0719            703   ; Warning, the ADC1/DAC1 can work ;
0719            704   ; only as ADC or DAC, not both.   ;
0719            705   ; The P89LPC9351 has two ADC/DAC  ;
0719            706   ; interfaces.  One can be used as ;
0719            707   ; ADC and the other can be used   ;
0719            708   ; as DAC.  Also configures the    ;
0719            709   ; pin associated with the DAC, in ;
0719            710   ; this case P0.4 as 'Open Drain'. ;
0719            711   ;---------------------------------;
0719            712   InitDAC1:
0719            713       ; Configure pin P0.4 (DAC1 output pin) as open drain
0719 438410     714            orl     P0M1,   #00010000B
071C 438510     715            orl     P0M2,   #00010000B
071F 75A128     716       mov ADMODB, #00101000B ; Select main clock/2 for ADC/DAC.  Also enable DAC1 output (Table 25 of reference manual)
0722 759704     717            mov     ADCON1, #00000100B ; Enable the converter
0725 75F580     718            mov AD1DAT3, #0x80     ; Start value is 3.3V/2 (zero reference for AC WAV file)
0728 22         719            ret
0729            720   
0729            721   ;---------------------------------;
0729            722   ; Change the internal RC osc. clk ;
0729            723   ; from 7.373MHz to 14.746MHz.     ;
0729            724   ;---------------------------------;
0729            725   Double_Clk:
0729            726       ;mov dptr, #CLKCON
0729            727       ;movx a, @dptr
0729            728       ;orl a, #00001000B ; double the clock speed to 14.746MHz
0729            729       ;movx @dptr,a
0729 22         730            ret
072A            731   
072A            732   ;---------------------------------;
072A            733   ; Initialize the SPI interface    ;
072A            734   ; and the pins associated to SPI. ;
072A            735   ;---------------------------------;
072A            736   Init_SPI:
072A D2A5       737       setb MY_MISO    ; Make MISO an input pin     
072C C2A4       738            clr MY_SCLK     ; For mode (0,0) SCLK is zero  
072E            739            ; Configure MOSI (P2.2), CS* (P2.4), and SPICLK (P2.5) as push-pull outputs (see table 42, page 51)
072E 53A4CB     740            anl P2M1, #low(not(00110100B))
0731 43A534     741            orl P2M2, #00110100B
0734            742            ; Configure MISO (P2.3) as input (see table 42, page 51)
0734 43A408     743            orl P2M1, #00001000B
0737 53A5F7     744            anl P2M2, #low(not(00001000B)) 
073A            745            ; Configure SPI
073A 75E2D0     746            mov SPCTL, #11010000B ; Ignore /SS, Enable SPI, DORD=0, Master=1, CPOL=0, CPHA=0, clk/4
073D 22         747            ret
073E            748   
073E            749   ;---------------------------------;
073E            750   ; Sends AND receives a byte via   ;
073E            751   ; SPI.                            ;
073E            752   ;---------------------------------;
073E            753   Send_SPI:
073E F5E3       754            mov SPDAT, a
0740            755   Send_SPI_1:
0740 E5E1       756            mov a, SPSTAT 
0742 30E7FB     757            jnb acc.7, Send_SPI_1 ; Check SPI Transfer Completion Flag
0745 F5E1       758            mov SPSTAT, a ; Clear SPI Transfer Completion Flag
0747 E5E3       759            mov a, SPDAT ; return received byte via accumulator
0749 22         760            ret
074A            761   
074A            762   ;---------------------------------;
074A            763   ; SPI flash 'write enable'        ;
074A            764   ; instruction.                    ;
074A            765   ;---------------------------------;
074A            766   Enable_Write:
074A C297       767            clr FLASH_CE
074C 7406       768            mov a, #WRITE_ENABLE
074E 12073E     769            lcall Send_SPI
0751 D297       770            setb FLASH_CE
0753 22         771            ret
0754            772   
0754            773   ;---------------------------------;
0754            774   ; This function checks the 'write ;
0754            775   ; in progress' bit of the SPI     ;
0754            776   ; flash memory.                   ;
0754            777   ;---------------------------------;
0754            778   Check_WIP:
0754 C297       779            clr FLASH_CE
0756 7405       780            mov a, #READ_STATUS
0758 12073E     781            lcall Send_SPI
075B 7455       782            mov a, #0x55
075D 12073E     783            lcall Send_SPI
0760 D297       784            setb FLASH_CE
0762 20E0EF     785            jb acc.0, Check_WIP ;  Check the Write in Progress bit
0765 22         786            ret
0766            787            
0766            788   ; Display a binary number in the LCD (must be less than 99).  Number to display passed in accumulator.
0766            789   LCD_number:
0766 C0E0       790            push acc
0768 75F00A     791            mov b, #10
076B 84         792            div ab
076C 4430       793            orl a, #'0'
076E 12031C     794            lcall ?WriteData
0771 E5F0       795            mov a, b
0773 4430       796            orl a, #'0'
0775 12031C     797            lcall ?WriteData
0778 D0E0       798            pop acc
077A 22         799            ret
077B            800   
077B            801   ; Sounds we need in the SPI flash: 0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 30; 40; 50; minutes; seconds;
077B            802   ; Approximate index of sounds in file 'stop_watch.wav'
077B            803   ; This was generated using: computer_sender -Asw_index.asm -S2000 stop_watch.wav
077B            804   sound_index:
077B 00002D     805       db 0x00, 0x00, 0x2d ; 0 
077E 003107     806       db 0x00, 0x31, 0x07 ; 1 
0781 007007     807       db 0x00, 0x70, 0x07 ; 2 
0784 00ADB9     808       db 0x00, 0xad, 0xb9 ; 3 
0787 00F266     809       db 0x00, 0xf2, 0x66 ; 4 
078A 0135D5     810       db 0x01, 0x35, 0xd5 ; 5 
078D 017D33     811       db 0x01, 0x7d, 0x33 ; 6 
0790 01C761     812       db 0x01, 0xc7, 0x61 ; 7 
0793 021279     813       db 0x02, 0x12, 0x79 ; 8 
0796 0249C1     814       db 0x02, 0x49, 0xc1 ; 9 
0799 028F7A     815       db 0x02, 0x8f, 0x7a ; 10 
079C 02D063     816       db 0x02, 0xd0, 0x63 ; 11 
079F 031B87     817       db 0x03, 0x1b, 0x87 ; 12 
07A2 03630E     818       db 0x03, 0x63, 0x0e ; 13 
07A5 03B95F     819       db 0x03, 0xb9, 0x5f ; 14 
07A8 04113A     820       db 0x04, 0x11, 0x3a ; 15 
07AB 0466C4     821       db 0x04, 0x66, 0xc4 ; 16 
07AE 04C012     822       db 0x04, 0xc0, 0x12 ; 17 
07B1 052698     823       db 0x05, 0x26, 0x98 ; 18 
07B4 0574E9     824       db 0x05, 0x74, 0xe9 ; 19 
07B7 05D28E     825       db 0x05, 0xd2, 0x8e ; 20 
07BA 061D83     826       db 0x06, 0x1d, 0x83 ; 21 -> 30 
07BD 066342     827       db 0x06, 0x63, 0x42 ; 22 -> 40 
07C0 06AAB9     828       db 0x06, 0xaa, 0xb9 ; 23 -> 50 
07C3 06F3D6     829       db 0x06, 0xf3, 0xd6 ; 24 -> Minutes 
07C6 073F02     830       db 0x07, 0x3f, 0x02 ; 25 -> Seconds 
07C9            831   
07C9            832   ; Size of each sound in 'sound_index'
07C9            833   ; Generated using: computer_sender -Asw_index.asm -S2000 stop_watch.wav
07C9            834   Size_Length:
07C9 0030DA     835       db 0x00, 0x30, 0xda ; 0 
07CC 003F00     836       db 0x00, 0x3f, 0x00 ; 1 
07CF 003DB2     837       db 0x00, 0x3d, 0xb2 ; 2 
07D2 0044AD     838       db 0x00, 0x44, 0xad ; 3 
07D5 00436F     839       db 0x00, 0x43, 0x6f ; 4 
07D8 00475E     840       db 0x00, 0x47, 0x5e ; 5 
07DB 004A2E     841       db 0x00, 0x4a, 0x2e ; 6 
07DE 004B18     842       db 0x00, 0x4b, 0x18 ; 7 
07E1 003748     843       db 0x00, 0x37, 0x48 ; 8 
07E4 0045B9     844       db 0x00, 0x45, 0xb9 ; 9 
07E7 0040E9     845       db 0x00, 0x40, 0xe9 ; 10 
07EA 004B24     846       db 0x00, 0x4b, 0x24 ; 11 
07ED 004787     847       db 0x00, 0x47, 0x87 ; 12 
07F0 005651     848       db 0x00, 0x56, 0x51 ; 13 
07F3 0057DB     849       db 0x00, 0x57, 0xdb ; 14 
07F6 00558A     850       db 0x00, 0x55, 0x8a ; 15 
07F9 00594E     851       db 0x00, 0x59, 0x4e ; 16 
07FC 006686     852       db 0x00, 0x66, 0x86 ; 17 
07FF 004E51     853       db 0x00, 0x4e, 0x51 ; 18 
0802 005DA5     854       db 0x00, 0x5d, 0xa5 ; 19 
0805 004AF5     855       db 0x00, 0x4a, 0xf5 ; 20 
0808 0045BF     856       db 0x00, 0x45, 0xbf ; 21 -> 30
080B 004777     857       db 0x00, 0x47, 0x77 ; 22 -> 40
080E 00491D     858       db 0x00, 0x49, 0x1d ; 23 -> 50
0811 004B2C     859       db 0x00, 0x4b, 0x2c ; 24 -> minutes
0814 005C87     860       db 0x00, 0x5c, 0x87 ; 25 -> seconds
0817            861   
0817            862   ; The sound and its length from the two tables above is passed in the accumulator.
0817            863   Play_Sound_Using_Index:
0817 D2B1       864            setb SOUND ; Turn speaker on
0819 C2C8       865            clr TMOD20 ; Stop the CCU from playing previous request
081B D297       866            setb FLASH_CE
081D            867            
081D            868            ; There are three bytes per row in our tables, so multiply index by three
081D 75F003     869            mov b, #3
0820 A4         870            mul ab
0821 F8         871            mov R0, a ; Make a copy of the index*3
0822            872            
0822 C297       873            clr FLASH_CE ; Enable SPI Flash
0824 7403       874            mov a, #READ_BYTES
0826 12073E     875            lcall Send_SPI
0829            876            ; Set the initial position in memory of where to start playing
0829 90077B     877            mov dptr, #sound_index
082C E8         878            mov a, R0
082D 93         879            movc a, @a+dptr
082E 12073E     880            lcall Send_SPI
0831 A3         881            inc dptr
0832 E8         882            mov a, R0
0833 93         883            movc a, @a+dptr
0834 12073E     884            lcall Send_SPI
0837 A3         885            inc dptr
0838 E8         886            mov a, R0
0839 93         887            movc a, @a+dptr
083A 12073E     888            lcall Send_SPI
083D            889            ; Now set how many bytes to play
083D 9007C9     890            mov dptr, #Size_Length
0840 E8         891            mov a, R0
0841 93         892            movc a, @a+dptr
0842 F564       893            mov w+2, a
0844 A3         894            inc dptr
0845 E8         895            mov a, R0
0846 93         896            movc a, @a+dptr
0847 F563       897            mov w+1, a
0849 A3         898            inc dptr
084A E8         899            mov a, R0
084B 93         900            movc a, @a+dptr
084C F562       901            mov w+0, a
084E            902            
084E 7400       903            mov a, #0x00 ; Request first byte to send to DAC
0850 12073E     904            lcall Send_SPI
0853            905            
0853 D2C8       906            setb TMOD20 ; Start playback by enabling CCU timer
0855            907   
0855 22         908            ret
0856            909   
0856            910   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0856            911   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0856            912   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0856            913   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0856            914   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0856            915   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0856            916   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0856            917   
0856            918   ;;;;;;; ; Send a character using the serial port
0856            919   ;;;;;;;putchar:
0856            920   ;;;;;;;        jnb TI, putchar 
0856            921   ;;;;;;;        ; TI serial interrupt flag is set and when last bit (stop bit) 
0856            922   ;;;;;;;        ; of receiving data byte is received, RI flag get set. IE register
0856            923   ;;;;;;;        ; is used to enable/disable interrupt sources.
0856            924   ;;;;;;;        clr TI
0856            925   ;;;;;;;        mov SBUF, a
0856            926   ;;;;;;;        ret
0856            927   ;;;;;;;
0856            928   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0856            929   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0856            930   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0856            931   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0856            932   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0856            933   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0856            934   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0856            935   
0856            936   ;---------------------------------------------------------------------------------;
0856            937   ; This is the FSM that plays minutes and seconds after the STOP button is pressed ;
0856            938   ; The state diagram of this FSM is available as 'Stop_Watch_FSM.pdf'              ;
0856            939   ;---------------------------------------------------------------------------------;
0856            940   T2S_FSM:
0856 E567       941            mov a, T2S_FSM_state
0858            942   
0858            943   T2S_FSM_State0: ; Checks for the start signal (T2S_FSM_Start==1)
0858 B40013     944            cjne a, #0, T2S_FSM_State1
085B 30000F     945            jnb T2S_FSM_Start, T2S_FSM_State0_Done
085E            946            ; Check if minutes is larger than 19
085E C3         947            clr c
085F E565       948            mov a, minutes
0861 9414       949            subb a, #20
0863 5005       950            jnc minutes_gt_19
0865 756701     951            mov T2S_FSM_state, #1
0868 8003       952            sjmp T2S_FSM_State0_Done
086A            953   minutes_gt_19:
086A 756703     954            mov T2S_FSM_state, #3
086D            955   T2S_FSM_State0_Done:
086D 22         956            ret
086E            957            
086E            958   T2S_FSM_State1: ; Plays minutes when minutes is less than 20
086E B40109     959            cjne a, #1, T2S_FSM_State2
0871 E565       960            mov a, minutes
0873 120817     961            lcall Play_Sound_Using_Index
0876 756702     962            mov T2S_FSM_State, #2
0879 22         963            ret 
087A            964   
087A            965   T2S_FSM_State2: ; Stay in this state until sound finishes playing
087A B40207     966            cjne a, #2, T2S_FSM_State3
087D 20C803     967            jb TMOD20, T2S_FSM_State2_Done 
0880 756706     968            mov T2S_FSM_State, #6
0883            969   T2S_FSM_State2_Done:
0883 22         970            ret
0884            971   
0884            972   T2S_FSM_State3: ; Plays the tens when minutes is larger than 19, for example for 42 minutes, it plays 'forty'
0884 B4030F     973            cjne a, #3, T2S_FSM_State4
0887 E565       974            mov a, minutes
0889 75F00A     975            mov b, #10
088C 84         976            div ab
088D 2412       977            add a, #18
088F 120817     978            lcall Play_Sound_Using_Index
0892 756704     979            mov T2S_FSM_State, #4
0895 22         980            ret
0896            981   
0896            982   T2S_FSM_State4: ; Stay in this state until sound finishes playing
0896 B40407     983            cjne a, #4, T2S_FSM_State5
0899 20C803     984            jb TMOD20, T2S_FSM_State4_Done 
089C 756705     985            mov T2S_FSM_State, #5
089F            986   T2S_FSM_State4_Done:
089F 22         987       ret
08A0            988   
08A0            989   T2S_FSM_State5: ; Plays the units when minutes is larger than 19, for example for 42 minutes, it plays 'two'
08A0 B40511     990            cjne a, #5, T2S_FSM_State6
08A3 E565       991            mov a, minutes
08A5 75F00A     992            mov b, #10
08A8 84         993            div ab
08A9 E5F0       994            mov a, b
08AB 6003       995            jz T2S_FSM_State5_Done ; Prevents from playing something like 'forty zero'
08AD 120817     996            lcall Play_Sound_Using_Index
08B0            997   T2S_FSM_State5_Done:
08B0 756702     998            mov T2S_FSM_State, #2
08B3 22         999            ret
08B4           1000   
08B4           1001   T2S_FSM_State6: ; Plays the word 'minutes'
08B4 B40609    1002            cjne a, #6, T2S_FSM_State7
08B7 7418      1003            mov a, #24 ; Index 24 has the word 'minutes'
08B9 120817    1004            lcall Play_Sound_Using_Index
08BC 756707    1005            mov T2S_FSM_State, #7
08BF 22        1006            ret
08C0           1007   
08C0           1008   T2S_FSM_State7: ; Stay in this state until sound finishes playing
08C0 B40713    1009            cjne a, #7, T2S_FSM_State8
08C3 20C80F    1010            jb TMOD20, T2S_FSM_State7_Done 
08C6           1011            ; Done playing previous sound, check if seconds is larger than 19
08C6 C3        1012            clr c
08C7 E566      1013            mov a, seconds
08C9 9414      1014            subb a, #20
08CB 5005      1015            jnc seconds_gt_19
08CD 756708    1016            mov T2S_FSM_state, #8
08D0 809B      1017            sjmp T2S_FSM_State0_Done
08D2           1018   seconds_gt_19:
08D2 75670A    1019            mov T2S_FSM_state, #10
08D5           1020   T2S_FSM_State7_Done:
08D5 22        1021       ret
08D6           1022   
08D6           1023   T2S_FSM_State8: ; Play the seconds when seconds is less than 20.
08D6 B40809    1024            cjne a, #8, T2S_FSM_State9
08D9 E566      1025            mov a, seconds
08DB 120817    1026            lcall Play_Sound_Using_Index
08DE 756709    1027            mov T2S_FSM_state, #9
08E1 22        1028            ret
08E2           1029   
08E2           1030   T2S_FSM_State9: ; Stay in this state until sound finishes playing
08E2 B40907    1031            cjne a, #9, T2S_FSM_State10
08E5 20C803    1032            jb TMOD20, T2S_FSM_State9_Done 
08E8 75670D    1033            mov T2S_FSM_State, #13
08EB           1034   T2S_FSM_State9_Done:
08EB 22        1035            ret
08EC           1036   
08EC           1037   T2S_FSM_State10:  ; Plays the tens when seconds is larger than 19, for example for 35 seconds, it plays 'thirty'
08EC B40A0F    1038            cjne a, #10, T2S_FSM_State11
08EF E566      1039            mov a, seconds
08F1 75F00A    1040            mov b, #10
08F4 84        1041            div ab
08F5 2412      1042            add a, #18
08F7 120817    1043            lcall Play_Sound_Using_Index
08FA 75670B    1044            mov T2S_FSM_state, #11
08FD 22        1045            ret
08FE           1046   
08FE           1047   T2S_FSM_State11: ; Stay in this state until sound finishes playing
08FE B40B07    1048            cjne a, #11, T2S_FSM_State12
0901 20C803    1049            jb TMOD20, T2S_FSM_State11_Done 
0904 75670C    1050            mov T2S_FSM_State, #12
0907           1051   T2S_FSM_State11_Done:
0907 22        1052            ret
0908           1053   
0908           1054   T2S_FSM_State12: ; Plays the units when seconds is larger than 19, for example for 35 seconds, it plays 'five'
0908 B40C11    1055            cjne a, #12, T2S_FSM_State13
090B E566      1056            mov a, seconds
090D 75F00A    1057            mov b, #10
0910 84        1058            div ab
0911 E5F0      1059            mov a, b
0913 6003      1060            jz T2S_FSM_State12_Done ; Prevents from saying something like 'thirty zero'
0915 120817    1061            lcall Play_Sound_Using_Index
0918           1062   T2S_FSM_State12_Done:
0918 756709    1063            mov T2S_FSM_State, #9
091B 22        1064            ret
091C           1065   
091C           1066   T2S_FSM_State13: ; Plays the word 'seconds'
091C B40D09    1067            cjne a, #13, T2S_FSM_State14
091F 7419      1068            mov a, #25 ; Index 25 has the word 'seconds'
0921 120817    1069            lcall Play_Sound_Using_Index
0924 75670E    1070            mov T2S_FSM_State, #14
0927 22        1071            ret
0928           1072   
0928           1073   T2S_FSM_State14: ; Stay in this state until sound finishes playing
0928 B40E09    1074            cjne a, #14, T2S_FSM_Error
092B 20C805    1075            jb TMOD20, T2S_FSM_State14_Done 
092E C200      1076            clr T2S_FSM_Start 
0930 756700    1077            mov T2S_FSM_State, #0
0933           1078   T2S_FSM_State14_Done:
0933 22        1079            ret
0934           1080   
0934           1081   T2S_FSM_Error: ; If we got to this point, there is an error in the finite state machine.  Restart it.
0934 756700    1082            mov T2S_FSM_state, #0
0937 C200      1083            clr T2S_FSM_Start
0939 22        1084            ret
093A           1085           
093A           1086   ;WaitHalfSec:
093A           1087       ;        mov R2, #178
093A           1088       ;        Lr3: mov R1, #250
093A           1089       ;        Lr2: mov R0, #166
093A           1090       ;        Lr1: djnz R0, Lr1 ; 3 cycles->3*45.21123ns*166=22.51519us
093A           1091       ;        djnz R1, Lr2 ; 22.51519us*250=5.629ms
093A           1092       ;        djnz R2, Lr3 ; 5.629ms*89=0.5s (approximately)
093A           1093       ;        ret
093A           1094       ;    
093A           1095       ;blink:
093A           1096       ;        mov SP, #7FH
093A           1097       ;        mov P3M1, #0   ; Configure P3 in bidirectional mode
093A           1098       ;    M0:
093A           1099       ;        cpl P3.7
093A           1100       ;        Set_Cursor(1, 1)
093A           1101       ;        Send_Constant_String(#nothing)
093A           1102       ;        Set_Cursor(2, 1)
093A           1103       ;        Send_Constant_String(#nothing)
093A           1104       ;        Set_Cursor(1, 1)
093A           1105       ;        Send_Constant_String(#hot)
093A           1106       ;        Set_Cursor(2, 1)
093A           1107       ;        Send_Constant_String(#hot)
093A           1108       ;
093A           1109       ;        lcall WaitHalfSec
093A           1110       ;
093A           1111       ;        ret
093A           1112       ;
093A           1113       ;convert:
093A           1114       ;    mov x+0, Result
093A           1115       ;    mov x+1, Result+1 
093A           1116       ;    mov x+2, #0
093A           1117       ;    mov x+3, #0
093A           1118       ;    ret
093A           1119       ;    
093A           1120       ;
093A           1121       Display_temp:
093A           1122       ;    Load_y(410)
093A           1123       ;    lcall mul32
093A           1124       ;    Load_y(1023)
093A           1125       ;    lcall div32
093A           1126       ;    Load_y(273)
093A           1127       ;    lcall sub32
093A           1128       ;    lcall hex2bcd
093A           1129       ;    lcall InitSerialPort
093A C0E0      1130            push acc
093C 7401      1130            mov a, #1
093E 14        1130            dec a
093F 120368    1130            lcall ?Set_Cursor_1 ; Select column and row
0942 D0E0      1130            pop acc
0944 C083      1131            push dph
0946 C082      1131            push dpl
0948 C0E0      1131            push acc
094A 9003F2    1131            mov dptr, #Temp0
094D 12035B    1131            lcall ?Send_Constant_String
0950 D0E0      1131            pop acc
0952 D082      1131            pop dpl
0954 D083      1131            pop dph
0956           1132   
0956           1133       ;    lcall SendString
0956           1134       ;    Set_Cursor(1, 5)    
0956           1135       ;    Send_BCD(bcd+1) ; send fisrt 2 digits to putty
0956           1136       ;    Display_BCD(bcd+1); send fisrt 2 digits to lcd
0956           1137       ;    Set_Cursor(1, 7) 
0956           1138       ;    Send_BCD(bcd) ; send last 2 digits to putty
0956           1139       ;    Display_BCD(bcd+0) ; send last 2 digits to lcd
0956           1140       ;    Set_Cursor(1, 5)
0956           1141       ;    Send_Constant_String(#dots)
0956           1142       ;    lcall SendString
0956           1143       ;    mov DPTR, #Newline
0956           1144       ;    lcall SendString
0956 22        1145           ret
0957           1146       ;config_adc:
0957           1147       ;        clr CE_ADC 
0957           1148       ;        mov R0, #00000001B; Start bit:1 
0957           1149       ;        lcall DO_SPI_G
0957           1150       ;
0957           1151       ;        mov R0, #10000000B; Single ended, read channel 0 
0957           1152       ;        lcall DO_SPI_G 
0957           1153       ;        mov a, R1          ; R1 contains bits 8 and 9 
0957           1154       ;        anl a, #00000011B  ; We need only the two least significant bits 
0957           1155       ;        mov Result+1, a    ; Save result high.
0957           1156       ;
0957           1157       ;        mov R0, #55H; It doesn't matter what we transmit... 
0957           1158       ;        lcall DO_SPI_G 
0957           1159       ;        mov Result, R1     ; R1 contains bits 0 to 7.  Save result low. 
0957           1160       ;        setb CE_ADC 
0957           1161       ;        lcall convert  
0957           1162       ;        mov a, bcd ; move temp to accumulator 
0957           1163       ;        ret
0957           1164   Reset_timer:
0957           1165   
0957 C28E      1166       clr TR1                 ; Stop timer 2
0959 E4        1167       clr a
095A 756000    1168            mov Count10ms, #0x00
095D           1169            ; Now clear the BCD counter and minutes
095D F55A      1170            mov BCD_counter, a
095F D28E      1171            setb TR1                ; Start timer 2
0961           1172   
0961 22        1173       ret
0962           1174   Display_time:
0962 C0E0      1175            push acc
0964 7401      1175            mov a, #1
0966 14        1175            dec a
0967 120366    1175            lcall ?Set_Cursor_2 ; Select column and row
096A D0E0      1175            pop acc
096C C083      1176            push dph
096E C082      1176            push dpl
0970 C0E0      1176            push acc
0972 900405    1176            mov dptr, #Time
0975 12035B    1176            lcall ?Send_Constant_String
0978 D0E0      1176            pop acc
097A D082      1176            pop dpl
097C D083      1176            pop dph
097E C203      1177       clr half_seconds_flag ; We clear this flag in the main loop, but it is set in the ISR for timer 2
0980           1178       ;clr my_flag
0980 C0E0      1179            push acc
0982 7409      1179            mov a, #9
0984 14        1179            dec a
0985 120366    1179            lcall ?Set_Cursor_2 ; Select column and row
0988 D0E0      1179            pop acc     ; the place in the LCD where we want the BCD counter value
098A C000      1180            push ar0
098C A85A      1180            mov r0, BCD_counter
098E 12036D    1180            lcall ?Display_BCD
0991 D000      1180            pop ar0 ; This macro is also in 'LCD_4bit.inc'
0993 C0E0      1181            push acc
0995 7406      1181            mov a, #6
0997 14        1181            dec a
0998 120366    1181            lcall ?Set_Cursor_2 ; Select column and row
099B D0E0      1181            pop acc     ; the place in the LCD where we want the BCD counter value
099D C000      1182            push ar0
099F A865      1182            mov r0, minutes
09A1 12036D    1182            lcall ?Display_BCD
09A4 D000      1182            pop ar0 ; This macro is also in 'LCD_4bit.inc'
09A6           1183   
09A6 22        1184       ret
09A7           1185   ;;Timer couter 
09A7           1186       sec_counter: 
09A7 E55A      1187           mov a,BCD_counter
09A9 B4600A    1188           cjne a, #0x60, Continue1 ; check if the couter reached 60s
09AC E565      1189           mov a, minutes
09AE 2401      1190           add a, #0x01 ; add one to the minutes
09B0 D4        1191           da a ; Decimal adjust instruction.  Check datasheet for more details!
09B1 F565      1192           mov minutes, a
09B3 120957    1193           lcall Reset_timer
09B6           1194                Continue1:
09B6 22        1195           ret
09B7           1196       min_counter:
09B7 E565      1197                    mov a,minutes
09B9 B4600A    1198                    cjne a, #0x60, Continue2
09BC C28E      1199                    clr TR1                 ; Stop timer 2
09BE E4        1200                    clr a                   
09BF 756000    1201                    mov Count10ms, #0x00      ; Now clear the BCD counter
09C2 F565      1202                    mov minutes, a              ; Reset minutes
09C4 D28E      1203           setb TR1                ; Start timer 2
09C6           1204   
09C6           1205                    Continue2:
09C6 22        1206           ret
09C7           1207   home_page:
09C7           1208   
09C7 20A718    1209         jb P2.7, continue20
09CA C002      1210            push AR2
09CC 7A32      1210            mov R2, #50
09CE 1202D7    1210            lcall ?Wait_Milli_Seconds
09D1 D002      1210            pop AR2 ; debounce
09D3 20A70C    1211      jb P2.7, continue20
09D6 30A7FD    1212      jnb p2.7, $
09D9           1213      ;clr TR1 
09D9 755A00    1214       mov BCD_counter, #0x00
09DC 756500    1215       mov minutes, #0x0   
09DF 120962    1216       lcall Display_time
09E2           1217   
09E2           1218      continue20:
09E2           1219       ;--------Timer----------;
09E2           1220   
09E2 300309    1221       jnb half_seconds_flag, Temp_sensor
09E5 1209A7    1222       lcall sec_counter
09E8 1209B7    1223       lcall min_counter
09EB 120962    1224       lcall Display_time
09EE           1225       ;-----------------------;
09EE           1226   
09EE           1227       ;-----TEMP SENSOR-------;
09EE           1228       Temp_sensor:
09EE           1229    ;    lcall config_adc
09EE 12093A    1230       lcall Display_temp
09F1           1231    ;    lcall  WaitHalfSec 
09F1           1232    ;    ;-----------------------;
09F1           1233   
09F1           1234   
09F1           1235   
09F1           1236   
09F1 22        1237       ret
09F2           1238   ;
09F2           1239   setup_reflow_page:
09F2 20A011    1240            jb set_BUTTON, continue9
09F5 C002      1240            push AR2
09F7 7A0A      1240            mov R2, #10
09F9 1202D7    1240            lcall ?Wait_Milli_Seconds
09FC D002      1240            pop AR2
09FE 20A005    1240            jb set_BUTTON, continue9
0A01 30A0FD    1240            jnb set_BUTTON, $
0A04           1240   
0A04 B209      1241       cpl tt_reflow_flag
0A06           1242       continue9:
0A06           1243   
0A06 200906    1244       jb tt_reflow_flag, jump1
0A09           1245       ;jnb tt_reflow_flag, jump1
0A09 120ACF    1246       lcall INC_DEC_Reflow_time
0A0C 020A12    1247       ljmp display_reflow_page
0A0F           1248       jump1:
0A0F 120B18    1249       lcall INC_DEC_Reflow_temp
0A12           1250   
0A12           1251   
0A12           1252       display_reflow_page:
0A12 C0E0      1253            push acc
0A14 7405      1253            mov a, #5
0A16 14        1253            dec a
0A17 120368    1253            lcall ?Set_Cursor_1 ; Select column and row
0A1A D0E0      1253            pop acc
0A1C C000      1254            push ar0
0A1E A851      1254            mov r0, reflow_temp+0
0A20 12036D    1254            lcall ?Display_BCD
0A23 D000      1254            pop ar0
0A25 C0E0      1255            push acc
0A27 7407      1255            mov a, #7
0A29 14        1255            dec a
0A2A 120368    1255            lcall ?Set_Cursor_1 ; Select column and row
0A2D D0E0      1255            pop acc
0A2F C000      1256            push ar0
0A31 A852      1256            mov r0, reflow_temp+1
0A33 12036D    1256            lcall ?Display_BCD
0A36 D000      1256            pop ar0
0A38           1257          
0A38           1258       
0A38 C0E0      1259            push acc
0A3A 7401      1259            mov a, #1
0A3C 14        1259            dec a
0A3D 120368    1259            lcall ?Set_Cursor_1 ; Select column and row
0A40 D0E0      1259            pop acc
0A42 C083      1260            push dph
0A44 C082      1260            push dpl
0A46 C0E0      1260            push acc
0A48 900427    1260            mov dptr, #reflow_setup
0A4B 12035B    1260            lcall ?Send_Constant_String
0A4E D0E0      1260            pop acc
0A50 D082      1260            pop dpl
0A52 D083      1260            pop dph
0A54 C0E0      1261            push acc
0A56 7409      1261            mov a, #9
0A58 14        1261            dec a
0A59 120368    1261            lcall ?Set_Cursor_1 ; Select column and row
0A5C D0E0      1261            pop acc
0A5E C083      1262            push dph
0A60 C082      1262            push dpl
0A62 C0E0      1262            push acc
0A64 90042C    1262            mov dptr, #reflow_setup4
0A67 12035B    1262            lcall ?Send_Constant_String
0A6A D0E0      1262            pop acc
0A6C D082      1262            pop dpl
0A6E D083      1262            pop dph
0A70           1263   
0A70 C0E0      1264            push acc
0A72 7401      1264            mov a, #1
0A74 14        1264            dec a
0A75 120366    1264            lcall ?Set_Cursor_2 ; Select column and row
0A78 D0E0      1264            pop acc
0A7A C083      1265            push dph
0A7C C082      1265            push dpl
0A7E C0E0      1265            push acc
0A80 900435    1265            mov dptr, #reflow_setup2
0A83 12035B    1265            lcall ?Send_Constant_String
0A86 D0E0      1265            pop acc
0A88 D082      1265            pop dpl
0A8A D083      1265            pop dph
0A8C           1266       ;Set_Cursor(2, 8)
0A8C           1267       ;Send_Constant_String(#dots)
0A8C C0E0      1268            push acc
0A8E 740C      1268            mov a, #12
0A90 14        1268            dec a
0A91 120366    1268            lcall ?Set_Cursor_2 ; Select column and row
0A94 D0E0      1268            pop acc
0A96 C083      1269            push dph
0A98 C082      1269            push dpl
0A9A C0E0      1269            push acc
0A9C 90043A    1269            mov dptr, #reflow_setup3
0A9F 12035B    1269            lcall ?Send_Constant_String
0AA2 D0E0      1269            pop acc
0AA4 D082      1269            pop dpl
0AA6 D083      1269            pop dph
0AA8 C0E0      1270            push acc
0AAA 7409      1270            mov a, #9
0AAC 14        1270            dec a
0AAD 120366    1270            lcall ?Set_Cursor_2 ; Select column and row
0AB0 D0E0      1270            pop acc
0AB2 C000      1271            push ar0
0AB4 A856      1271            mov r0, reflow_time+1
0AB6 12036D    1271            lcall ?Display_BCD
0AB9 D000      1271            pop ar0
0ABB C0E0      1272            push acc
0ABD 7407      1272            mov a, #7
0ABF 14        1272            dec a
0AC0 120366    1272            lcall ?Set_Cursor_2 ; Select column and row
0AC3 D0E0      1272            pop acc
0AC5 C000      1273            push ar0
0AC7 A855      1273            mov r0, reflow_time
0AC9 12036D    1273            lcall ?Display_BCD
0ACC D000      1273            pop ar0
0ACE           1274   
0ACE 22        1275       ret
0ACF           1276       INC_DEC_Reflow_time:
0ACF           1277   
0ACF 20A121    1278            jb SETUP_SOAK_Button, check_decrement
0AD2 C002      1278            push AR2
0AD4 7A0A      1278            mov R2, #10
0AD6 1202D7    1278            lcall ?Wait_Milli_Seconds
0AD9 D002      1278            pop AR2
0ADB 20A115    1278            jb SETUP_SOAK_Button, check_decrement
0ADE 30A1FD    1278            jnb SETUP_SOAK_Button, $
0AE1           1278    ; setup soak is also used to increment 
0AE1           1279   
0AE1 E556      1280             mov a, reflow_time+1
0AE3 2401      1281               add a, #0x01
0AE5 D4        1282               da a ; Decimal adjust instruction.  Check datasheet for more details!
0AE6 F556      1283               mov reflow_time+1, a
0AE8 E556      1284               mov a, reflow_time+1
0AEA 7007      1285               jnz INC_reflow_time_done2
0AEC E555      1286               mov a, reflow_time+0
0AEE 2401      1287               add a, #0x01
0AF0 D4        1288               da a ; Decimal adjust instruction.  Check datasheet for more details!
0AF1 F555      1289               mov reflow_time+0, a
0AF3           1290              ; mov a, reflow_temp+1
0AF3           1291               INC_reflow_time_done2:
0AF3           1292   
0AF3           1293           check_decrement:
0AF3           1294           
0AF3 20A621    1295            jb Button_min, INC_reflow_time_done
0AF6 C002      1295            push AR2
0AF8 7A0A      1295            mov R2, #10
0AFA 1202D7    1295            lcall ?Wait_Milli_Seconds
0AFD D002      1295            pop AR2
0AFF           1295   
0AFF 20A615    1295            jb Button_min, INC_reflow_time_done
0B02 30A6FD    1295            jnb Button_min, $
0B05           1295   
0B05 E556      1296               mov a, reflow_time+1
0B07 2499      1297               add a, #0x99
0B09 D4        1298               da a ; Decimal adjust instruction.  Check datasheet for more details!
0B0A F556      1299               mov reflow_time+1, a
0B0C E556      1300               mov a, reflow_time+1
0B0E 7007      1301               jnz INC_reflow_time_done
0B10 E555      1302               mov a, reflow_time+0
0B12 2499      1303               add a, #0x99
0B14 D4        1304               da a ; Decimal adjust instruction.  Check datasheet for more details!
0B15 F555      1305               mov reflow_time+0, a
0B17           1306             ;  mov a, reflow_temp+1
0B17           1307               INC_reflow_time_done:
0B17 22        1308           ret
0B18           1309       INC_DEC_Reflow_temp:
0B18           1310           ;PushButton(SETUP_SOAK_Button,check_decrement2) ; setup soak is also used to increment 
0B18           1311   
0B18 20A121    1312            jb SETUP_SOAK_Button, check_decrement2
0B1B C002      1312            push AR2
0B1D 7A0A      1312            mov R2, #10
0B1F 1202D7    1312            lcall ?Wait_Milli_Seconds
0B22 D002      1312            pop AR2
0B24 20A115    1312            jb SETUP_SOAK_Button, check_decrement2
0B27 30A1FD    1312            jnb SETUP_SOAK_Button, $
0B2A           1312   
0B2A           1313             ;  jb SETUP_SOAK_Button, check_decrement2  
0B2A           1314             ;      Wait_Milli_Seconds(#50)         
0B2A           1315             ;  jb SETUP_SOAK_Button, check_decrement2  
0B2A           1316             ;  loop_hold_inc:
0B2A           1317   
0B2A           1318             ;  jnb SETUP_SOAK_Button, jump2
0B2A           1319             ;  ;Wait_Milli_Seconds(#50)
0B2A           1320             ;  jnb SETUP_SOAK_Button, jump2
0B2A           1321             ;  ljmp hold_done
0B2A           1322             ;  jump2:
0B2A           1323             ;  Set_Cursor(1, 5)
0B2A           1324             ;  Display_BCD(reflow_temp+0)
0B2A           1325             ;  Set_Cursor(1, 7)
0B2A           1326             ;  Display_BCD(reflow_temp+1)
0B2A           1327             ;  Wait_Milli_Seconds(#100)    
0B2A E552      1328               mov a, reflow_temp+1
0B2C 2401      1329               add a, #0x01
0B2E D4        1330               da a ; Decimal adjust instruction.  Check datasheet for more details!
0B2F F552      1331               mov reflow_temp+1, a
0B31 E552      1332               mov a, reflow_temp+1
0B33 7007      1333               jnz INC_reflow_temp_done2
0B35 E551      1334               mov a, reflow_temp+0
0B37 2401      1335               add a, #0x01
0B39 D4        1336               da a ; Decimal adjust instruction.  Check datasheet for more details!
0B3A F551      1337               mov reflow_temp+0, a
0B3C           1338              ; mov a, reflow_temp+1
0B3C           1339               INC_reflow_temp_done2:
0B3C           1340               
0B3C           1341             ;  ljmp loop_hold_inc
0B3C           1342           hold_done:
0B3C           1343           
0B3C           1344   
0B3C           1345   
0B3C           1346           check_decrement2:
0B3C           1347   
0B3C 20A621    1348            jb Button_min, DEC_reflow_temp_done2
0B3F C002      1348            push AR2
0B41 7A0A      1348            mov R2, #10
0B43 1202D7    1348            lcall ?Wait_Milli_Seconds
0B46 D002      1348            pop AR2
0B48 20A615    1348            jb Button_min, DEC_reflow_temp_done2
0B4B 30A6FD    1348            jnb Button_min, $
0B4E           1348   
0B4E           1349            ;   jb Button_min, DEC_reflow_temp_done2  
0B4E           1350            ;       Wait_Milli_Seconds(#50)         
0B4E           1351            ;   jb Button_min, DEC_reflow_temp_done2  
0B4E           1352            ;   loop_hold_dec:
0B4E           1353   
0B4E           1354            ;   jnb Button_min, jump3
0B4E           1355            ;   ljmp DEC_reflow_temp_done2
0B4E           1356            ;   jump3:
0B4E           1357            ;   Set_Cursor(1, 5)
0B4E           1358            ;   Display_BCD(reflow_temp+0)
0B4E           1359            ;   Set_Cursor(1, 7)
0B4E           1360            ;   Display_BCD(reflow_temp+1)
0B4E           1361            ;   Wait_Milli_Seconds(#100)    
0B4E E552      1362               mov a, reflow_temp+1
0B50 2499      1363               add a, #0x99
0B52 D4        1364               da a ; Decimal adjust instruction.  Check datasheet for more details!
0B53 F552      1365               mov reflow_temp+1, a
0B55 E552      1366               mov a, reflow_temp+1
0B57 7007      1367               jnz INC_reflow_temp_done
0B59 E551      1368               mov a, reflow_temp+0
0B5B 2499      1369               add a, #0x99
0B5D D4        1370               da a ; Decimal adjust instruction.  Check datasheet for more details!
0B5E F551      1371               mov reflow_temp+0, a
0B60           1372             ;  mov a, reflow_temp+1
0B60           1373               INC_reflow_temp_done:
0B60           1374               
0B60           1375             ;  ljmp loop_hold_dec
0B60           1376   
0B60           1377           DEC_reflow_temp_done2:
0B60           1378       
0B60           1379   
0B60 22        1380       ret
0B61           1381   setup_soak_page:
0B61 20A011    1382            jb set_BUTTON, continue11
0B64 C002      1382            push AR2
0B66 7A0A      1382            mov R2, #10
0B68 1202D7    1382            lcall ?Wait_Milli_Seconds
0B6B D002      1382            pop AR2
0B6D 20A005    1382            jb set_BUTTON, continue11
0B70 30A0FD    1382            jnb set_BUTTON, $
0B73           1382   
0B73 B20A      1383       cpl tt_flag_soak
0B75           1384       continue11:
0B75           1385   
0B75 200A06    1386       jb tt_flag_soak, jump4
0B78 120C3E    1387       lcall INC_DEC_soak_time
0B7B 020B81    1388       ljmp display_soak_page
0B7E           1389       jump4:
0B7E 120C87    1390       lcall INC_DEC_soak_temp
0B81           1391   
0B81           1392   
0B81           1393       display_soak_page:
0B81 C0E0      1394            push acc
0B83 7405      1394            mov a, #5
0B85 14        1394            dec a
0B86 120368    1394            lcall ?Set_Cursor_1 ; Select column and row
0B89 D0E0      1394            pop acc
0B8B C000      1395            push ar0
0B8D A853      1395            mov r0, soak_temp+0
0B8F 12036D    1395            lcall ?Display_BCD
0B92 D000      1395            pop ar0
0B94 C0E0      1396            push acc
0B96 7407      1396            mov a, #7
0B98 14        1396            dec a
0B99 120368    1396            lcall ?Set_Cursor_1 ; Select column and row
0B9C D0E0      1396            pop acc
0B9E C000      1397            push ar0
0BA0 A854      1397            mov r0, soak_temp+1
0BA2 12036D    1397            lcall ?Display_BCD
0BA5 D000      1397            pop ar0
0BA7           1398          
0BA7           1399       
0BA7 C0E0      1400            push acc
0BA9 7401      1400            mov a, #1
0BAB 14        1400            dec a
0BAC 120368    1400            lcall ?Set_Cursor_1 ; Select column and row
0BAF D0E0      1400            pop acc
0BB1 C083      1401            push dph
0BB3 C082      1401            push dpl
0BB5 C0E0      1401            push acc
0BB7 90043F    1401            mov dptr, #soak_setup0
0BBA 12035B    1401            lcall ?Send_Constant_String
0BBD D0E0      1401            pop acc
0BBF D082      1401            pop dpl
0BC1 D083      1401            pop dph
0BC3 C0E0      1402            push acc
0BC5 7409      1402            mov a, #9
0BC7 14        1402            dec a
0BC8 120368    1402            lcall ?Set_Cursor_1 ; Select column and row
0BCB D0E0      1402            pop acc
0BCD           1402   
0BCD C083      1403            push dph
0BCF C082      1403            push dpl
0BD1 C0E0      1403            push acc
0BD3 900444    1403            mov dptr, #soak_setup1
0BD6 12035B    1403            lcall ?Send_Constant_String
0BD9 D0E0      1403            pop acc
0BDB D082      1403            pop dpl
0BDD D083      1403            pop dph
0BDF           1404   
0BDF C0E0      1405            push acc
0BE1 7401      1405            mov a, #1
0BE3 14        1405            dec a
0BE4 120366    1405            lcall ?Set_Cursor_2 ; Select column and row
0BE7 D0E0      1405            pop acc
0BE9           1405   
0BE9 C083      1406            push dph
0BEB C082      1406            push dpl
0BED C0E0      1406            push acc
0BEF 90044C    1406            mov dptr, #soak_setup2
0BF2 12035B    1406            lcall ?Send_Constant_String
0BF5 D0E0      1406            pop acc
0BF7 D082      1406            pop dpl
0BF9 D083      1406            pop dph
0BFB           1407       ;Set_Cursor(2, 8)
0BFB           1408      ; Send_Constant_String(#dots)
0BFB C0E0      1409            push acc
0BFD 740C      1409            mov a, #12
0BFF 14        1409            dec a
0C00 120366    1409            lcall ?Set_Cursor_2 ; Select column and row
0C03 D0E0      1409            pop acc
0C05 C083      1410            push dph
0C07 C082      1410            push dpl
0C09 C0E0      1410            push acc
0C0B 90045D    1410            mov dptr, #soak_setup3
0C0E 12035B    1410            lcall ?Send_Constant_String
0C11 D0E0      1410            pop acc
0C13 D082      1410            pop dpl
0C15 D083      1410            pop dph
0C17 C0E0      1411            push acc
0C19 7409      1411            mov a, #9
0C1B 14        1411            dec a
0C1C 120366    1411            lcall ?Set_Cursor_2 ; Select column and row
0C1F D0E0      1411            pop acc
0C21           1411   
0C21 C000      1412            push ar0
0C23 A858      1412            mov r0, soak_time+1
0C25 12036D    1412            lcall ?Display_BCD
0C28 D000      1412            pop ar0
0C2A C0E0      1413            push acc
0C2C 7407      1413            mov a, #7
0C2E 14        1413            dec a
0C2F 120366    1413            lcall ?Set_Cursor_2 ; Select column and row
0C32 D0E0      1413            pop acc
0C34 C000      1414            push ar0
0C36 A857      1414            mov r0, soak_time
0C38 12036D    1414            lcall ?Display_BCD
0C3B D000      1414            pop ar0
0C3D 22        1415   ret
0C3E           1416       INC_DEC_soak_time:
0C3E           1417       
0C3E 20A121    1418            jb SETUP_SOAK_Button, check_decrement_soak
0C41 C002      1418            push AR2
0C43 7A0A      1418            mov R2, #10
0C45 1202D7    1418            lcall ?Wait_Milli_Seconds
0C48 D002      1418            pop AR2
0C4A 20A115    1418            jb SETUP_SOAK_Button, check_decrement_soak
0C4D 30A1FD    1418            jnb SETUP_SOAK_Button, $
0C50           1418    ; setup soak is also used to increment 
0C50           1419   
0C50 E558      1420               mov a, soak_time+1
0C52 2401      1421               add a, #0x01
0C54 D4        1422               da a ; Decimal adjust instruction.  Check datasheet for more details!
0C55 F558      1423               mov soak_time+1, a
0C57 E558      1424               mov a, soak_time+1
0C59 7007      1425               jnz INC_soak_time_done2
0C5B E557      1426               mov a, soak_time+0
0C5D 2401      1427               add a, #0x01
0C5F D4        1428               da a ; Decimal adjust instruction.  Check datasheet for more details!
0C60 F557      1429               mov soak_time+0, a
0C62           1430              ; mov a, soak_temp+1
0C62           1431               INC_soak_time_done2:
0C62           1432   
0C62           1433           check_decrement_soak:
0C62 20A621    1434            jb Button_min, continue13
0C65 C002      1434            push AR2
0C67 7A0A      1434            mov R2, #10
0C69 1202D7    1434            lcall ?Wait_Milli_Seconds
0C6C D002      1434            pop AR2
0C6E 20A615    1434            jb Button_min, continue13
0C71 30A6FD    1434            jnb Button_min, $
0C74           1434   
0C74 E558      1435               mov a, soak_time+1
0C76 2499      1436               add a, #0x99
0C78 D4        1437               da a ; Decimal adjust instruction.  Check datasheet for more details!
0C79 F558      1438               mov soak_time+1, a
0C7B E558      1439               mov a, soak_time+1
0C7D 7007      1440               jnz DEC_soak_time_done
0C7F E557      1441               mov a, soak_time+0
0C81 2499      1442               add a, #0x99
0C83 D4        1443               da a ; Decimal adjust instruction.  Check datasheet for more details!
0C84 F557      1444               mov soak_time+0, a
0C86           1445             ;  mov a, soak_temp+1
0C86           1446               DEC_soak_time_done:
0C86           1447           continue13:
0C86           1448           
0C86 22        1449           ret
0C87           1450       INC_DEC_soak_temp:
0C87           1451           
0C87 20A121    1452            jb SETUP_SOAK_Button, check_decrement2_soak
0C8A C002      1452            push AR2
0C8C 7A0A      1452            mov R2, #10
0C8E 1202D7    1452            lcall ?Wait_Milli_Seconds
0C91 D002      1452            pop AR2
0C93 20A115    1452            jb SETUP_SOAK_Button, check_decrement2_soak
0C96 30A1FD    1452            jnb SETUP_SOAK_Button, $
0C99           1452   
0C99           1453           ;    jb SETUP_SOAK_Button, check_decrement2_soak  
0C99           1454           ;        Wait_Milli_Seconds(#50)         
0C99           1455           ;    jb SETUP_SOAK_Button, check_decrement2_soak  
0C99           1456           ;    loop_hold_inc_soak:
0C99           1457         ;
0C99           1458           ;    jnb SETUP_SOAK_Button, jump6
0C99           1459           ;    Wait_Milli_Seconds(#100)
0C99           1460           ;    jnb SETUP_SOAK_Button, jump6
0C99           1461           ;    ljmp hold_done_soak
0C99           1462           ;    jump6:
0C99           1463           ;    Set_Cursor(1, 5)
0C99           1464           ;    Display_BCD(soak_temp+0)
0C99           1465           ;    Set_Cursor(1, 7)
0C99           1466           ;    Display_BCD(soak_temp+1)
0C99           1467           ;    Wait_Milli_Seconds(#200)    
0C99 E554      1468               mov a, soak_temp+1
0C9B 2401      1469               add a, #0x01
0C9D D4        1470               da a ; Decimal adjust instruction.  Check datasheet for more details!
0C9E F554      1471               mov soak_temp+1, a
0CA0 E554      1472               mov a, soak_temp+1
0CA2 7007      1473               jnz INC_soak_temp_done2
0CA4 E553      1474               mov a, soak_temp+0
0CA6 2401      1475               add a, #0x01
0CA8 D4        1476               da a ; Decimal adjust instruction.  Check datasheet for more details!
0CA9 F553      1477               mov soak_temp+0, a
0CAB           1478              ; mov a, soak_temp+1
0CAB           1479               INC_soak_temp_done2:
0CAB           1480               
0CAB           1481             ;  ljmp loop_hold_inc_soak
0CAB           1482           hold_done_soak:
0CAB           1483           
0CAB           1484   
0CAB           1485   
0CAB           1486           check_decrement2_soak:
0CAB           1487   
0CAB 20A621    1488            jb Button_min, DEC_soak_temp_done2
0CAE C002      1488            push AR2
0CB0 7A0A      1488            mov R2, #10
0CB2 1202D7    1488            lcall ?Wait_Milli_Seconds
0CB5 D002      1488            pop AR2
0CB7 20A615    1488            jb Button_min, DEC_soak_temp_done2
0CBA 30A6FD    1488            jnb Button_min, $
0CBD           1488   
0CBD           1489              ; 
0CBD           1490              ; jb Button_min, DEC_soak_temp_done2  
0CBD           1491              ;     Wait_Milli_Seconds(#50)         
0CBD           1492              ; jb Button_min, DEC_soak_temp_done2  
0CBD           1493              ; loop_hold_dec_soak:
0CBD           1494                ;
0CBD           1495              ; jnb Button_min, jump7
0CBD           1496              ; Wait_Milli_Seconds(#100)
0CBD           1497              ; jnb Button_min, jump7
0CBD           1498              ; ljmp DEC_soak_temp_done2
0CBD           1499              ; jump7:
0CBD           1500              ; Set_Cursor(1, 5)
0CBD           1501              ; Display_BCD(soak_temp+0)
0CBD           1502              ; Set_Cursor(1, 7)
0CBD           1503              ; Display_BCD(soak_temp+1)
0CBD           1504              ; Wait_Milli_Seconds(#100)    
0CBD E554      1505               mov a, soak_temp+1
0CBF 2499      1506               add a, #0x99
0CC1 D4        1507               da a ; Decimal adjust instruction.  Check datasheet for more details!
0CC2 F554      1508               mov soak_temp+1, a
0CC4 E554      1509               mov a, soak_temp+1
0CC6 7007      1510               jnz INC_soak_temp_done
0CC8 E553      1511               mov a, soak_temp+0
0CCA 2499      1512               add a, #0x99
0CCC D4        1513               da a ; Decimal adjust instruction.  Check datasheet for more details!
0CCD F553      1514               mov soak_temp+0, a
0CCF           1515             ;  mov a, soak_temp+1
0CCF           1516               INC_soak_temp_done:
0CCF           1517               
0CCF           1518              ; ljmp loop_hold_dec_soak
0CCF           1519   
0CCF           1520           DEC_soak_temp_done2:
0CCF 22        1521           ret
0CD0           1522   second_page:
0CD0 C0E0      1523            push acc
0CD2 7401      1523            mov a, #1
0CD4 14        1523            dec a
0CD5 120368    1523            lcall ?Set_Cursor_1 ; Select column and row
0CD8 D0E0      1523            pop acc
0CDA C083      1524            push dph
0CDC C082      1524            push dpl
0CDE C0E0      1524            push acc
0CE0 900416    1524            mov dptr, #soak_reflw
0CE3 12035B    1524            lcall ?Send_Constant_String
0CE6 D0E0      1524            pop acc
0CE8 D082      1524            pop dpl
0CEA D083      1524            pop dph
0CEC C0E0      1525            push acc
0CEE 7401      1525            mov a, #1
0CF0 14        1525            dec a
0CF1 120366    1525            lcall ?Set_Cursor_2 ; Select column and row
0CF4 D0E0      1525            pop acc
0CF6 C083      1526            push dph
0CF8 C082      1526            push dpl
0CFA C0E0      1526            push acc
0CFC 9003A5    1526            mov dptr, #nothing
0CFF 12035B    1526            lcall ?Send_Constant_String
0D02 D0E0      1526            pop acc
0D04 D082      1526            pop dpl
0D06 D083      1526            pop dph
0D08 22        1527       ret
0D09           1528   
0D09           1529   FSM_LCD:
0D09 E54A      1530           mov a, state_lcd
0D0B           1531   
0D0B           1532   
0D0B           1533           ;----------------STATE 0------------------;
0D0B           1534            home_state:
0D0B B4001E    1535               cjne a, #0, soak_reflow_state
0D0E 20A015    1536            jb set_BUTTON, done_home2
0D11 C002      1536            push AR2
0D13 7A0A      1536            mov R2, #10
0D15 1202D7    1536            lcall ?Wait_Milli_Seconds
0D18 D002      1536            pop AR2
0D1A 20A009    1536            jb set_BUTTON, done_home2
0D1D 30A0FD    1536            jnb set_BUTTON, $
0D20           1536    
0D20           1537               ;setb set_flag  
0D20 754A01    1538               mov state_lcd, #1
0D23 020D29    1539               ljmp done_home
0D26           1540               done_home2:
0D26           1541               ;clr set_flag
0D26 1209C7    1542               lcall home_page
0D29           1543               done_home:
0D29 020DC8    1544               ljmp Forever_done           
0D2C           1545           ;------------------------------------------;
0D2C           1546           
0D2C           1547        ;   ;----------------STATE 1-------------------;
0D2C           1548           soak_reflow_state:
0D2C B4014B    1549               cjne a, #1, setup_soak
0D2F 120CD0    1550               lcall second_page
0D32           1551             ;  Wait_Milli_Seconds(#50)
0D32 1209A7    1552               lcall sec_counter ; prevent the timer to go over 60
0D35 1209B7    1553               lcall min_counter
0D38 20A712    1554            jb HOME_BUTTON, next_pushb
0D3B C002      1554            push AR2
0D3D 7A0A      1554            mov R2, #10
0D3F 1202D7    1554            lcall ?Wait_Milli_Seconds
0D42 D002      1554            pop AR2
0D44 20A706    1554            jb HOME_BUTTON, next_pushb
0D47 30A7FD    1554            jnb HOME_BUTTON, $
0D4A           1554    ; check if home button is pressed 
0D4A 754A00    1555               mov state_lcd, #0
0D4D           1556               next_pushb:
0D4D 20A112    1557            jb SETUP_SOAK_Button, next_pushb2
0D50 C002      1557            push AR2
0D52 7A0A      1557            mov R2, #10
0D54 1202D7    1557            lcall ?Wait_Milli_Seconds
0D57 D002      1557            pop AR2
0D59 20A106    1557            jb SETUP_SOAK_Button, next_pushb2
0D5C 30A1FD    1557            jnb SETUP_SOAK_Button, $
0D5F           1557    ; check if the the button to setup soak is pressed
0D5F 754A02    1558               mov state_lcd, #2
0D62           1559               next_pushb2:
0D62 20A612    1560            jb Button_min, done_soak
0D65 C002      1560            push AR2
0D67 7A0A      1560            mov R2, #10
0D69 1202D7    1560            lcall ?Wait_Milli_Seconds
0D6C D002      1560            pop AR2
0D6E 20A606    1560            jb Button_min, done_soak
0D71 30A6FD    1560            jnb Button_min, $
0D74           1560    ; check if the buttion to setup the reflow was pressed 
0D74 754A03    1561               mov state_lcd, #3
0D77           1562               done_soak:
0D77 020DC8    1563              ljmp Forever_done 
0D7A           1564           ;------------------------------------------;
0D7A           1565   ;
0D7A           1566        ;   ;-----------------STATE 2------------------;
0D7A           1567           setup_soak: ; its actually set up reflow Im dumb
0D7A B40221    1568               cjne a, #2, setup_reflow
0D7D 1209F2    1569               lcall setup_reflow_page
0D80           1570             ;  Wait_Milli_Seconds(#50)
0D80 1209A7    1571               lcall sec_counter ; prevent the timer to go over 60
0D83 1209B7    1572               lcall min_counter
0D86 20A712    1573            jb HOME_BUTTON, done_setup_soak
0D89 C002      1573            push AR2
0D8B 7A0A      1573            mov R2, #10
0D8D 1202D7    1573            lcall ?Wait_Milli_Seconds
0D90 D002      1573            pop AR2
0D92 20A706    1573            jb HOME_BUTTON, done_setup_soak
0D95 30A7FD    1573            jnb HOME_BUTTON, $
0D98           1573    ; check if home button is pressed 
0D98 754A00    1574               mov state_lcd, #0
0D9B           1575               done_setup_soak:
0D9B 020DC8    1576               ljmp Forever_done 
0D9E           1577           ;------------------------------------------;
0D9E           1578   ;
0D9E           1579        ;   ;----------------STATE 3-------------------;
0D9E           1580           setup_reflow: ; its actually set up soak Im dumb
0D9E B40303    1581               cjne a, #3, FDP
0DA1 020DA7    1582               ljmp FDP2
0DA4           1583               FDP:
0DA4 020D0B    1584               ljmp home_state
0DA7           1585               FDP2:
0DA7 120B61    1586               lcall setup_soak_page
0DAA 1209A7    1587               lcall sec_counter ; prevent the timer to go over 60
0DAD 1209B7    1588               lcall min_counter
0DB0 20A712    1589            jb HOME_BUTTON, done_setup_reflow
0DB3 C002      1589            push AR2
0DB5 7A0A      1589            mov R2, #10
0DB7 1202D7    1589            lcall ?Wait_Milli_Seconds
0DBA D002      1589            pop AR2
0DBC 20A706    1589            jb HOME_BUTTON, done_setup_reflow
0DBF 30A7FD    1589            jnb HOME_BUTTON, $
0DC2           1589    ; check if home button is pressed 
0DC2 754A00    1590               mov state_lcd, #0
0DC5           1591               done_setup_reflow:
0DC5 020DC8    1592               ljmp Forever_done 
0DC8           1593        ;   ;------------------------------------------;
0DC8           1594           Forever_done:
0DC8 22        1595   ret
0DC9           1596   
0DC9           1597   ;------------------------------
0DC9           1598   ;---------------------------------;
0DC9           1599   ; Main program. Includes hardware ;
0DC9           1600   ; initialization and 'forever'    ;
0DC9           1601   ; loop.                           ;
0DC9           1602   ;---------------------------------;
0DC9           1603   main:
0DC9           1604            ; Initialization
0DC9 75817F    1605       mov SP, #0x7F
0DCC           1606   
0DCC 12064F    1607       lcall Timer0_Init
0DCF 12067A    1608       lcall Timer1_Init
0DD2           1609   
0DD2 120525    1610       lcall Ports_Init ; Default all pins as bidirectional I/O. See Table 42.
0DD5 120326    1611       lcall LCD_4BIT
0DD8 120729    1612       lcall Double_Clk
0DDB 120719    1613            lcall InitDAC1 ; Call after 'Ports_Init'
0DDE 1206D3    1614            lcall CCU_Init
0DE1 12072A    1615            lcall Init_SPI
0DE4           1616            
0DE4           1617            
0DE4 D2AF      1618            setb EA ; Enable global interrupts.
0DE6           1619   
0DE6           1620            ; Initialize variables
0DE6 C200      1621            clr T2S_FSM_Start
0DE8 756700    1622            mov T2S_FSM_state, #0
0DEB           1623       ; Configure all the ports in bidirectional mode:
0DEB           1624   
0DEB 758400    1625       mov P0M1, #00H
0DEE 758500    1626       mov P0M2, #00H
0DF1 759100    1627       mov P1M1, #00H
0DF4 759200    1628       mov P1M2, #00H ; WARNING: P1.2 and P1.3 need 1kohm pull-up resistors!
0DF7 75A400    1629       mov P2M1, #00H
0DFA 75A500    1630       mov P2M2, #00H
0DFD 75B100    1631       mov P3M1, #00H
0E00 75B200    1632       mov P3M2, #00H
0E03           1633       
0E03           1634       ;mov minutes, #0
0E03 756600    1635            mov seconds, #0
0E06           1636   
0E06           1637      ; lcall LCD_4BIT
0E06           1638       ; For convenience a few handy macros are included in 'LCD_4bit_LPC9351.inc':
0E06           1639   ;        Set_Cursor(1, 1)
0E06           1640     ;  Display_BCD(BCD_counter)
0E06           1641   
0E06 D203      1642       setb half_seconds_flag
0E08 C20C      1643       clr my_flag   
0E0A           1644   
0E0A 755A00    1645            mov BCD_counter, #0x00
0E0D 754E00    1646            mov pwm , #0
0E10 754C00    1647            mov sec , #0
0E13 754900    1648            mov state, #0
0E16 754B96    1649            mov temp, #150
0E19 754605    1650       mov time_soak, #5
0E1C 7547DC    1651       mov temp_refl, #220
0E1F 754505    1652       mov temp_soak, #5
0E22 756900    1653       mov five_sec_flag,#0
0E25           1654            ; After initialization the program stays in this 'forever' loop
0E25           1655   
0E25 755C00    1656       mov reflow_sec, #0x00
0E28 755D00    1657       mov reflow_min, #0x00
0E2B 756500    1658       mov minutes, #0x00
0E2E 754A00    1659       mov state_lcd, #0
0E31 C208      1660       clr TR1_flag
0E33 755101    1661       mov reflow_temp+0, #0x01
0E36 755250    1662       mov reflow_temp+1, #0x50
0E39 C209      1663       clr tt_reflow_flag
0E3B 755700    1664       mov soak_time, #0x00
0E3E 755850    1665       mov soak_time+1, #0x50
0E41 755500    1666       mov reflow_time, #0x00
0E44 755650    1667       mov reflow_time+1, #0x50
0E47 755301    1668       mov soak_temp, #0x01
0E4A 755101    1669       mov reflow_temp+0, #0x01
0E4D 755250    1670       mov reflow_temp+1, #0x50
0E50 C209      1671       clr tt_reflow_flag
0E52 755700    1672       mov soak_time, #0x00
0E55 755850    1673       mov soak_time+1, #0x50
0E58 755500    1674       mov reflow_time, #0x00
0E5B 755650    1675       mov reflow_time+1, #0x50
0E5E 755301    1676       mov soak_temp, #0x01
0E61 755101    1677       mov reflow_temp+0, #0x01
0E64 755250    1678       mov reflow_temp+1, #0x50
0E67 C209      1679       clr tt_reflow_flag
0E69 755700    1680       mov soak_time, #0x00
0E6C 755850    1681       mov soak_time+1, #0x50
0E6F 755500    1682       mov reflow_time, #0x00
0E72 755650    1683       mov reflow_time+1, #0x50
0E75 755301    1684       mov soak_temp, #0x01
0E78 755101    1685       mov reflow_temp+0, #0x01
0E7B 755250    1686       mov reflow_temp+1, #0x50
0E7E C209      1687       clr tt_reflow_flag
0E80 755700    1688       mov soak_time, #0x00
0E83 755850    1689       mov soak_time+1, #0x50
0E86 755500    1690       mov reflow_time, #0x00
0E89 755650    1691       mov reflow_time+1, #0x50
0E8C 755301    1692       mov soak_temp, #0x01
0E8F 755101    1693       mov reflow_temp+0, #0x01
0E92 755250    1694       mov reflow_temp+1, #0x50
0E95 C209      1695       clr tt_reflow_flag
0E97 755700    1696       mov soak_time, #0x00
0E9A 755850    1697       mov soak_time+1, #0x50
0E9D 755500    1698       mov reflow_time, #0x00
0EA0 755650    1699       mov reflow_time+1, #0x50
0EA3 755301    1700       mov soak_temp, #0x01
0EA6 755101    1701       mov reflow_temp+0, #0x01
0EA9 755250    1702       mov reflow_temp+1, #0x50
0EAC C209      1703       clr tt_reflow_flag
0EAE 755700    1704       mov soak_time, #0x00
0EB1 755850    1705       mov soak_time+1, #0x50
0EB4 755500    1706       mov reflow_time, #0x00
0EB7 755650    1707       mov reflow_time+1, #0x50
0EBA 755301    1708       mov soak_temp, #0x01
0EBD 755101    1709       mov reflow_temp+0, #0x01
0EC0 755250    1710       mov reflow_temp+1, #0x50
0EC3 C209      1711       clr tt_reflow_flag
0EC5 755700    1712       mov soak_time, #0x00
0EC8 755850    1713       mov soak_time+1, #0x50
0ECB 755500    1714       mov reflow_time, #0x00
0ECE 755650    1715       mov reflow_time+1, #0x50
0ED1 755301    1716       mov soak_temp, #0x01
0ED4 755450    1717       mov soak_temp+1, #0x50
0ED7 C20B      1718       clr stop_flag
0ED9 120525    1719       lcall Ports_Init
0EDC 12053E    1720       lcall InitSerialPort
0EDF 75A400    1721       mov P2M1, #0
0EE2 75A500    1722       mov P2M2, #0
0EE5           1723   
0EE5           1724       
0EE5           1725   forever:         
0EE5 120D09    1726       lcall FSM_LCD
0EE8           1727   
0EE8           1728      ; lcall T2S_FSM
0EE8           1729            ; One second has passed, refresh the LCD with new time
0EE8           1730   ;        Set_Cursor(1, 1)
0EE8           1731   ;    Send_Constant_String(#timee)
0EE8           1732   ;    Set_Cursor(1, 5)
0EE8           1733   ;    Display_BCD(sec)
0EE8           1734   ;    Set_Cursor(2, 1)
0EE8           1735   ;    Send_Constant_String(#statee)
0EE8           1736    ;   Set_Cursor(2, 5)
0EE8           1737     ;  Display_BCD(BCD_counter)
0EE8           1738   
0EE8           1739       
0EE8           1740           
0EE8           1741     ;  jb P2.6, continue19
0EE8           1742   ;        Wait_Milli_Seconds(#50) ; debounce
0EE8           1743   ;        jb P2.6, continue19
0EE8           1744   ;        jnb P2.6, $
0EE8           1745   ;        clr TR1 
0EE8           1746   ;        ljmp forever
0EE8           1747     ; continue19:
0EE8           1748   
0EE8           1749   
0EE8           1750   
0EE8           1751     ;  mov a, five_sec_flag
0EE8           1752     ;  cjne a,#5, pass_quack
0EE8           1753     ;  quack_like_a_duck:
0EE8           1754     ;  clr TR1 ; Stop timer 1.
0EE8           1755     ;  mov a,#0
0EE8           1756     ;  mov five_sec_flag,a
0EE8           1757     ;  clr TR1 ; Stop timer 1.
0EE8           1758   ;        setb T2S_FSM_Start ; This plays the current minutes:seconds by making the state machine get out of state zero.
0EE8           1759     ;  pass_hash:
0EE8           1760     ;  pass_quack:ssss
0EE8           1761     ;  setb TR1 ; en timer 1.
0EE8           1762   
0EE8           1763     ;  lcall hannah
0EE8           1764      
0EE8           1765   
0EE8 E549      1766       mov a, state
0EEA           1767     state0: 
0EEA B40013    1768         cjne a, #0, state1
0EED 754E00    1769         mov pwm, #0
0EF0 C28E      1770         clr TR1
0EF2 20B008    1771         jb p3.0, state0_done
0EF5 30B0FD    1772         jnb p3.0, $ ;wait for key release
0EF8 D28E      1773         setb TR1
0EFA 754901    1774         mov state, #1
0EFD           1775     state0_done:
0EFD 020EE5    1776         ljmp forever
0F00           1777      
0F00           1778      state1:
0F00 B4011A    1779         cjne a, #1 , state2
0F03 754E64    1780         mov pwm, #100
0F06 754C00    1781         mov sec, #0
0F09           1782   
0F09 C3        1783         clr c
0F0A E554      1784         mov a, soak_temp+1
0F0C 9541      1785         subb a, bcd+1
0F0E           1786         ;add branches to compare temp with 150
0F0E 500A      1787         jnc state1_done
0F10           1788   
0F10 C3        1789         clr c
0F11 E553      1790         mov a, soak_temp+0
0F13 9540      1791         subb a, bcd+0
0F15 5003      1792         jnc state1_done
0F17           1793       
0F17 754902    1794         mov state, #2
0F1A           1795     state1_done:
0F1A 020EE5    1796           ljmp forever
0F1D           1797          
0F1D           1798     state2: ;press p3.0 multiple time plz cos it is stuck
0F1D B40210    1799         cjne a, #2 , state3
0F20 754E14    1800         mov pwm, #20
0F23           1801         
0F23           1802   
0F23 C3        1803         clr c
0F24 E557      1804         mov a, soak_time+0
0F26 954C      1805         subb a, sec
0F28 5003      1806         jnc state2_done
0F2A 754903    1807         mov state, #3
0F2D           1808     state2_done:
0F2D 020EE5    1809          ljmp forever          
0F30           1810     
0F30           1811     state3:
0F30 B4031C    1812         cjne a, #3 , state4
0F33 754E00    1813         mov pwm, #0
0F36 754C00    1814         mov sec, #0     
0F39           1815         
0F39 C3        1816         clr c
0F3A E552      1817         mov a, reflow_temp+1
0F3C 9541      1818         subb a, bcd+1
0F3E 500C      1819         jnc state3_done
0F40           1820   
0F40 C3        1821         clr c
0F41 E551      1822         mov a, reflow_temp+0
0F43 9540      1823         subb a, bcd+0
0F45 5005      1824         jnc state3_done
0F47           1825   
0F47           1826         ;add branches to compare temp with 220
0F47 5003      1827         jnc state3_done
0F49 754904    1828         mov state, #4
0F4C           1829     state3_done:
0F4C 020EE5    1830          ljmp forever
0F4F           1831          
0F4F           1832      state4:
0F4F B40410    1833         cjne a, #4 , state5
0F52 754E28    1834         mov pwm, #40
0F55           1835   
0F55 E548      1836         mov a, time_refl+0
0F57 C3        1837         clr c
0F58 954C      1838         subb a, sec
0F5A           1839         ;add branches to compare sec with 45
0F5A 5003      1840         jnc state4_done
0F5C 754905    1841         mov state, #5
0F5F           1842     state4_done:
0F5F 020EE5    1843          ljmp forever    
0F62           1844          
0F62           1845      state5:
0F62 B40585    1846         cjne a, #5 , state0
0F65 754E64    1847         mov pwm, #100
0F68 C3        1848         clr c
0F69 954B      1849         subb a, temp
0F6B           1850         ;add branches to compare temp with 60
0F6B 5003      1851         jnc state5_done
0F6D 754900    1852         mov state, #0
0F70           1853     state5_done:
0F70 020EE5    1854          ljmp forever 
0F73           1855          
0F73           1856   
0F73           1857   EN
