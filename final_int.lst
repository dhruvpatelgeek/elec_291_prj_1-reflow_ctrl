0000              1   ; ISR_example.asm: a) Increments/decrements a BCD variable every half second using
0000              2   ; an ISR for timer 2; b) Generates a 2kHz square wave at pin P3.7 using
0000              3   ; an ISR for timer 0; and c) in the 'main' loop it displays the variable
0000              4   ; incremented/decremented using the ISR for timer 2 on the LCD.  Also resets it to 
0000              5   ; zero if the 'CLEAR' pushbutton connected to P1.7 is pressed.
0000              6   ; Start/Constants 
0000              7   
0000              8   ;your mother is a nice person :) jjjggg gvgggggggggggggggg
0000              9   
                 11       $LIST
0000             13   
0000             14       CLK           EQU 7373000  ; Microcontroller system crystal frequency in Hz
0000             15       TIMER0_RATE   EQU 100     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0000             16       TIMER0_RELOAD EQU ((65536-(CLK/(2*TIMER0_RATE))))
0000             17       TIMER1_RATE   EQU 100     ; 100Hz, for a timer tick of 10ms
0000             18       TIMER1_RELOAD EQU ((65536-(CLK/(2*TIMER1_RATE))))
0000             19   
0000             20   
0000             21   
0000             22       CCU_RATE    EQU 11025     ; 22050Hz is the sampling rate of the wav file we are playing
0000             23       CCU_RELOAD  EQU ((65536-((CLK/(2*CCU_RATE)))))
0000             24       BAUD        EQU 115200
0000             25       BRVAL       EQU ((CLK/BAUD)-16)
0000             26   
0000             27   XTAL EQU (14746000/2) 
0000             28   
0000             29   OP_AMP_GAIN EQU 340 ;what is the exact gain?
0000             30   
0000             31   
0000             32       ; Commands supported by the SPI flash memory according to the datasheet
0000             33       WRITE_ENABLE     EQU 0x06  ; Address:0 Dummy:0 Num:0
0000             34       WRITE_DISABLE    EQU 0x04  ; Address:0 Dummy:0 Num:0
0000             35       READ_STATUS      EQU 0x05  ; Address:0 Dummy:0 Num:1 to infinite
0000             36       READ_BYTES       EQU 0x03  ; Address:3 Dummy:0 Num:1 to infinite
0000             37       READ_SILICON_ID  EQU 0xab  ; Address:0 Dummy:3 Num:1 to infinite
0000             38       FAST_READ        EQU 0x0b  ; Address:3 Dummy:1 Num:1 to infinite
0000             39       WRITE_STATUS     EQU 0x01  ; Address:0 Dummy:0 Num:1
0000             40       WRITE_BYTES      EQU 0x02  ; Address:3 Dummy:0 Num:1 to 256
0000             41       ERASE_ALL        EQU 0xc7  ; Address:0 Dummy:0 Num:0
0000             42       ERASE_BLOCK      EQU 0xd8  ; Address:3 Dummy:0 Num:0
0000             43       READ_DEVICE_ID   EQU 0x9f  ; Address:0 Dummy:2 Num:1 to infinite
0000             44   ;Vectors
0000             45       ; Reset vector
0000             46       org 0x0000
0000 020D6D      47           ljmp main
0003             48   
0003             49       ; External interrupt 0 vector (not used in this code)
0003             50       org 0x0003
0003 32          51           reti
0004             52   
0004             53       ; Timer/Counter 0 overflow interrupt vector
000B             54       org 0x000B
000B 020467      55           ljmp Timer0_ISR
000E             56   
000E             57       ; External interrupt 1 vector (not used in this code)
0013             58       org 0x0013
0013 32          59           reti
0014             60   
0014             61       ; Timer/Counter 1 overflow interrupt vector
001B             62       org 0x001B
001B 020492      63           ljmp Timer1_ISR
001E             64   
001E             65       ; Serial port receive/transmit interrupt vector (not used in this code)
0023             66       org 0x0023 
0023 32          67           reti
0024             68   
005B             69       org 0x005b ; CCU interrupt vector.  Used in this code to replay the wave file.
005B 0204EF      70           ljmp CCU_ISR
005E             71   
005E             72   
005E             73       ;                                                        -                     
005E             74       ;                                                       -  -                    
005E             75       ;                                                      -    -                   
005E             76       ;                              leave it at this temp>>-      -                  
005E             77       ;                                                    -        -                 
005E             78       ;                                                   -          -                 
005E             79       ;                                                  -            -               
005E             80       ;                                                 -              -              
005E             81       ;                                                -                -             
005E             82       ;                                               -                  -            
005E             83       ;                                              -                    -           
005E             84       ;                                             -    reflow>>cool     -          
005E             85       ;               -----------------------------    (temperature only)  -         
005E             86       ;              -     soak (time+temp)                                 -        
005E             87       ;             -                                                        -       
005E             88       ;            -                                                          -       
005E             89       ;          -                                                             -      
005E             90       ;         -                                                               -     
005E             91       ;        -                                                                 -    
005E             92       ;      -                                                                    -    
005E             93       ;     - ramp to soak (temperature)                                           -   
005E             94       ;   -                                                                         -   
005E             95       ;   state 1 ((temp==soak)? ssr_off: ssr_on)
005E             96       ;          state 2 ((time=soak_time)?(pwm_off):(pwn_on)
005E             97       ;                                           state 3 ((temp==soak)? ssr_off: ssr_on)
005E             98       ;                                                        state 4 (cooling ssr_off)
005E             99       ;                                                                             state 5 (done)
005E            100   
005E            101       ; In the 8051 we can define direct access variables starting at location 0x30 up to location 0x7F
005E            102   ;Variables(dseg) 
0030            103       dseg at 0x30
0030            104   
0030            105       Result:          ds 4
0034            106       x:               ds 4
0038            107       y:               ds 4
003C            108       bcd:             ds 5
0041            109       ;FSM varialbles
0041            110       temp_soak:       ds 1 ; temp to soak
0042            111       time_soak:       ds 1 ; time to soak
0043            112       temp_refl:       ds 1 ; temp of relfow
0044            113       time_refl:       ds 1 ; time to reflow 
0045            114       state:           ds 1 ; current state 
0046            115       state_lcd:       ds 1
0047            116       temp:            ds 1 ; current temp in degree C
0048            117       sec:             ds 1 ; current time in seconds 
0049            118       product:         ds 1; pwm-currsec
004A            119       pwm:             ds 1 ; 
004B            120   
004B            121      
004B            122   
004B            123   
004B            124   ch0: ds 2
004D            125   ch1: ds 2
004F            126   oven_temp: ds 2
0051            127   
0051            128       ;Timer variables
0051            129       Count1ms:        ds 2 ; Used to determine when half second has passed
0053            130       reflow_temp:     ds 2
0055            131       soak_temp:       ds 2
0057            132       reflow_temp_var: ds 1
0058            133       BCD_counter:     ds 1 ; The BCD counter incrememted in the ISR and displayed in the main loop
0059            134       hour:            ds 1
005A            135       reflow_sec:      ds 1
005B            136       reflow_min:      ds 1
005C            137       soak_sec:        ds 1
005D            138       soak_min:        ds 1
005E            139       Count10ms:       ds 1 ; Used to determine when half second has passed
005F            140       Count10ms2:      ds 1
0060            141       w:               ds 3 ; 24-bit play counter.  Decremented in CCU ISR.
0063            142       minutes:         ds 1
0064            143       seconds:         ds 1
0065            144       T2S_FSM_state:   ds 1
0066            145       Count5ms:        ds 1
0067            146       five_sec_flag:   ds 1
0068            147   
0068            148   ;flags(bseg)
0000            149       BSEG
0000            150       T2S_FSM_start:     dbit 1
0001            151       seconds_flag:      dbit 1
0002            152       mf:                dbit 1
0003            153       half_seconds_flag: dbit 1 ; Set to one in the ISR every time 500 ms had passed
0004            154       AMPM_flag:         dbit 1
0005            155       alarm_AMPM_flag:   dbit 1
0006            156       on_off_flag:       dbit 1 ; 1 is on
0007            157       alarm_buzzer_flag: dbit 1
0008            158       TR1_flag:          dbit 1
0009            159       tt_reflow_flag:    dbit 1
000A            160       tt_flag_soak:      dbit 1
000B            161       stop_flag:         dbit 1
000C            162       my_flag:           dbit 1
000D            163   
000D            164       ;_ _ _ _ | _ _ _ _ _ _
000D            165       ;
000D            166       ;pwm = 40 (say)
000D            167       ;then output will be 100 
000D            168       ;_________
000D            169       ;         |
000D            170       ;         |_____________
000D            171       ; where period is 1 second 
000D            172       ; In the 8051 we have variables that are 1-bit in size.  We can use the setb, clr, jb, and jnb
000D            173       ; instructions with these variables.  This is how you define a 1-bit variable:
000D            174   
000D            175   ;Pin config(cseg)
000D            176   
005E            177       cseg
005E            178       ; These 'equ' must match the wiring between the microcontroller and the LCD!
005E            179       LCD_RS equ P0.5
005E            180       LCD_RW equ P0.6
005E            181       LCD_E  equ P0.7
005E            182       LCD_D4 equ P1.2
005E            183       LCD_D5 equ P1.3
005E            184       LCD_D6 equ P1.4
005E            185       LCD_D7 equ P1.6
005E            186   
005E            187       CLEAR         equ P3.0
005E            188       FLASH_CE      EQU P2.4
005E            189       SOUND         EQU P2.7
005E            190       
005E            191       SETUP_SOAK_Button equ  P0.3
005E            192       set_BUTTON        equ  P2.1
005E            193       Button_min        equ  P2.0
005E            194       HOME_BUTTON       equ  P0.2
005E            195       button_4          equ  P0.4
005E            196   
005E            197   
005E            198   CE_ADC    EQU  P2.7;P2.4   ;SS
005E            199   MY_MOSI   EQU  P2.6 ;P2.2  ;MOSI
005E            200   MY_MISO   EQU  P2.5   ;MISO
005E            201   MY_SCLK   EQU  P2.4   ;SPICLK
005E            202   
005E            203   ;include files
                546   $LIST
                206   	    $LIST
0399            208   ;Strings
0399            209     ;                       1234567890123456
0399            210      ;General
0399 0D0A00     211       Newline:          db   '\r', '\n', 0
039C 20202020   212       Space:            db   '      ','\r', '\n', 0
     20200D0A
     00
03A5 20202020   213       nothing:          db '                ',0      
     20202020
     20202020
     20202020
     00
03B6 20202020   214       test2:            db '      Test2     ',0
     20205465
     73743220
     20202020
     00
03C7 20202020   215       hot:                           db '      HOT       ', 0
     2020484F
     54202020
     20202020
     00
03D8 3A00       216       dots:             db ':',0
03DA 74696D65   217       timee:            db 'time', 0
     00
03DF 3100       218       statee:           db '1', 0
03E1            219   
03E1 4243445F   220       Initial_Message:  db 'BCD_counter: xx ', 0
     636F756E
     7465723A
     20787820
     00
03F2            221      ;Home page
03F2 54656D70   222       Temp0:            db 'Temp:xxxC       ', 0
     3A787878
     43202020
     20202020
     00
0403 54696D65   223       Time:             db 'Time xx:xx SET  ', 0
     2078783A
     78782053
     45542020
     00
0414            224      ;Second Page
0414 2020534F   225       soak_reflw:       db '  SOAK  REFLOW  ', 0
     414B2020
     5245464C
     4F572020
     00
0425            226      ;Reflow Setup
0425 54656D70   227       reflow_setup:     db 'Temp',0
     00
042A 2A524546   228       reflow_setup4:    db '*REFLOW*',0
     4C4F572A
     00
0433 54696D65   229       reflow_setup2:    db 'Time',0
     00
0438 484F4D45   230       reflow_setup3:    db 'HOME',0
     00
043D            231      ;Soak Setup
043D 54656D70   232       soak_setup0:      db 'Temp',0
     00
0442 202A534F   233       soak_setup1:      db ' *SOAK*',0
     414B2A00
044A 54696D65   234       soak_setup2:      db 'Time',0
     00
044F 484F4D45   235       soak_setup3:      db 'HOME',0
     00
0454            236   
0454            237   ;------ISR-------;
0454            238       ;---------------------------------;
0454            239       ; Routine to initialize the ISR   ;
0454            240       ; for timer 0                     ;
0454            241       ;---------------------------------;
0454            242       Timer0_Init:
0454 E589       243           mov a, TMOD
0456 54F0       244           anl a, #0xf0 ; Clear the bits for timer 0
0458 4401       245           orl a, #0x01 ; Configure timer 0 as 16-timer
045A F589       246           mov TMOD, a
045C 758C6F     247           mov TH0, #high(TIMER0_RELOAD)
045F 758AFF     248           mov TL0, #low(TIMER0_RELOAD)
0462            249           ; Enable the timer and interrupts
0462 D2A9       250           setb ET0  ; Enable timer 0 interrupt
0464 D28C       251           setb TR0  ; Start timer 0
0466 22         252           ret
0467            253   
0467            254       ;---------------------------------;
0467            255       ; ISR for timer 0.  Set to execute;
0467            256       ; every 1/4096Hz to generate a    ;
0467            257       ; 2048 Hz square wave at pin P3.7 ;
0467            258       ;---------------------------------;
0467            259       Timer0_ISR:
0467 758C6F     260           mov TH0, #high(TIMER0_RELOAD)
046A 758AFF     261           mov TL0, #low(TIMER0_RELOAD)
046D C0E0       262           push acc
046F C0D0       263           push psw
0471            264           
0471 055F       265           inc Count10ms2
0473 E55F       266           mov a, Count10ms2
0475 B43202     267           cjne a, #50, Timer0_ISR_done 
0478 D20C       268           setb my_flag  ; used to refresh the page even if timer 1 is disabled 
047A            269   
047A            270           Timer0_ISR_done:
047A D0D0       271           pop psw
047C D0E0       272           pop acc
047E 32         273           reti
047F            274   
047F            275       ;---------------------------------;
047F            276       ; Routine to initialize the ISR   ;
047F            277       ; for timer 1                     ;
047F            278       ;---------------------------------;
047F            279       Timer1_Init:
047F E589       280           mov a, TMOD
0481 540F       281           anl a, #0x0f ; Clear the bits for timer 1
0483 4410       282           orl a, #0x10 ; Configure timer 1 as 16-timer
0485 F589       283           mov TMOD, a
0487 758D6F     284           mov TH1, #high(TIMER1_RELOAD)
048A 758BFF     285           mov TL1, #low(TIMER1_RELOAD)
048D            286           ; Enable the timer and interrupts
048D D2AB       287           setb ET1  ; Enable timer 1 interrupt
048F D28E       288           setb TR1  ; Start timer 1
0491 22         289           ret
0492            290   
0492            291       ;---------------------------------;
0492            292       ; ISR for timer 1                 ;
0492            293       ;---------------------------------;
0492            294       Timer1_ISR:
0492 758D6F     295           mov TH1, #high(TIMER1_RELOAD)
0495 758BFF     296           mov TL1, #low(TIMER1_RELOAD)       
0498            297           ; The two registers used in the ISR must be saved in the stack
0498 C0E0       298           push acc
049A C0D0       299           push psw 
049C            300           ; Increment the 8-bit 10-mili-second counter
049C 055E       301           inc Count10ms
049E            302           ; Increment the 16-bit one mili second counter
049E            303       Inc_Done:
049E E55E       304           mov a, Count10ms
04A0 954A       305           subb a, pwm ; if pwm greater than a pwm is on else off
04A2 D4         306           da a
04A3            307          ; mov a, product
04A3 5005       308           jnc off_segment
04A5 D281       309           setb p0.1
04A7 C3         310           clr c
04A8 8005       311           sjmp pass
04AA            312           off_segment:
04AA C281       313           clr p0.1
04AC C3         314           clr c
04AD 8000       315           sjmp pass
04AF            316   
04AF            317           ; Check if 1 second has passed
04AF            318           pass:
04AF            319   
04AF            320           ; Check if half second has passed
04AF E55E       321           mov a, Count10ms
04B1 B4C81F     322           cjne a, #200, Timer1_ISR_done ; Warning: this instruction changes the carry flag!
04B4            323           ;----------------------------
04B4 0548       324           inc sec ; one second has passed
04B6 E548       325           mov a,sec
04B8 D4         326           da a
04B9 F548       327           mov sec,a
04BB 0567       328           inc five_sec_flag ; one second has passed
04BD E567       329           mov a,five_sec_flag
04BF D4         330           da a
04C0 F567       331           mov five_sec_flag,a
04C2 E548       332           mov a,sec
04C4            333          ; mov minutes, #0
04C4 85E064     334           mov seconds, acc 
04C7            335           ;----------------------------
04C7            336           ; 500 milliseconds have passed.  Set a flag so the main program knows
04C7 D203       337           setb half_seconds_flag ; Let the main program know half second had passed
04C9            338           ; Reset to zero the 10-milli-seconds counter, it is a 8-bit variable
04C9 755E00     339           mov Count10ms, #0x00
04CC            340      ;     mov Count1ms, #0x00
04CC            341           ; Increment the BCD counter
04CC E558       342           mov a, BCD_counter
04CE 2401       343           add a, #0x01
04D0            344       Timer1_ISR_da:
04D0 D4         345           da a ; Decimal adjust instruction.  Check datasheet for more details!
04D1 F558       346           mov BCD_counter, a
04D3            347           
04D3            348       Timer1_ISR_done:
04D3 D0D0       349           pop psw
04D5 D0E0       350           pop acc
04D7 32         351           reti
04D8            352   
04D8            353   
04D8            354   
04D8            355   
04D8            356   
04D8            357       ;------------------------------
04D8            358       ;---------------------------------;
04D8            359       ; Routine to initialize the CCU.  ;
04D8            360       ; We are using the CCU timer in a ;
04D8            361       ; manner similar to the timer 2   ;
04D8            362       ; available in other 8051s        ;
04D8            363       ;---------------------------------;
04D8            364       CCU_Init:
04D8 75CDFE     365           mov TH2, #high(CCU_RELOAD)
04DB 75CCB2     366           mov TL2, #low(CCU_RELOAD)
04DE 75CFFE     367           mov TOR2H, #high(CCU_RELOAD)
04E1 75CEB2     368           mov TOR2L, #low(CCU_RELOAD)
04E4 75F980     369           mov TCR21, #10000000b ; Latch the reload value
04E7 75C980     370           mov TICR2, #10000000b ; Enable CCU Timer Overflow Interrupt
04EA D2EC       371           setb ECCU ; Enable CCU interrupt
04EC D2C8       372           setb TMOD20 ; Start CCU timer
04EE 22         373           ret
04EF            374   
04EF            375       ;---------------------------------;
04EF            376       ; ISR for CCU.  Used to playback  ;
04EF            377       ; the WAV file stored in the SPI  ;
04EF            378       ; flash memory.                   ;
04EF            379       ;---------------------------------;
04EF            380       CCU_ISR:
04EF 75E900     381           mov TIFR2, #0 ; Clear CCU Timer Overflow Interrupt Flag bit. Actually, it clears all the bits!
04F2            382           
04F2            383           ; The registers used in the ISR must be saved in the stack
04F2 C0E0       384           push acc
04F4 C0D0       385           push psw
04F6            386           
04F6            387           ; Check if the play counter is zero.  If so, stop playing sound.
04F6 E560       388           mov a, w+0
04F8 4561       389           orl a, w+1
04FA 4562       390           orl a, w+2
04FC 6015       391           jz stop_playing
04FE            392           
04FE            393           ;;yolo this is gonna fuck with the speaker
04FE            394           ; Increment the 16-bit one mili second counter
04FE            395         ;  inc Count1ms+0    ; Increment the low 8-bits first
04FE            396         ;  mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
04FE            397         ;  jnz Inc_Done
04FE            398         ;  inc Count1ms+1
04FE            399           ; Decrement play counter 'w'.  In this implementation 'w' is a 24-bit counter.
04FE 74FF       400           mov a, #0xff
0500 1560       401           dec w+0
0502 B56007     402           cjne a, w+0, keep_playing
0505 1561       403           dec w+1
0507 B56102     404           cjne a, w+1, keep_playing
050A 1562       405           dec w+2
050C            406           
050C            407       keep_playing:
050C            408   
050C 12061A     409           lcall Send_SPI ; Read the next byte from the SPI Flash...
050F F5F5       410           mov AD1DAT3, a ; and send it to the DAC
0511            411           
0511 8006       412           sjmp CCU_ISR_Done
0513            413   
0513            414       stop_playing:
0513 C2C8       415           clr TMOD20 ; Stop CCU timer
0515 D2A4       416           setb FLASH_CE  ; Disable SPI Flash
0517 C2A7       417           clr SOUND ; Turn speaker off
0519            418   
0519            419       CCU_ISR_Done:        
0519 D0D0       420           pop psw
051B D0E0       421           pop acc
051D 32         422           reti
051E            423   ;----------------;
051E            424   
051E            425   ;---------------------------------;
051E            426   ; Initial configuration of ports. ;
051E            427   ; After reset the default for the ;
051E            428   ; pins is 'Open Drain'.  This     ;
051E            429   ; routine changes them pins to    ;
051E            430   ; Quasi-bidirectional like in the ;
051E            431   ; original 8051.                  ;
051E            432   ; Notice that P1.2 and P1.3 are   ;
051E            433   ; always 'Open Drain'. If those   ;
051E            434   ; pins are to be used as output   ;
051E            435   ; they need a pull-up resistor.   ;
051E            436   ;---------------------------------;
051E            437   InitSerialPort:
051E            438            ;DEBOUNCING??
051E            439            ; Since the reset button bounces, we need to wait a bit before
051E            440       ; sending messages, otherwise we risk displaying gibberish!
051E            441       ;mov R1, #222
051E            442       ;mov R0, #166
051E            443       ;djnz R0, $   ; 3 cycles->3*45.21123ns*166=22.51519us
051E            444       ;djnz R1, $-4 ; 22.51519us*222=4.998ms
051E            445       ; Now we can proceed with the configuration
051E            446            
051E 75BD00     447            mov     BRGCON,#0x00
0521 75BF00     448            mov     BRGR1,#high(BRVAL)
0524 75BE30     449            mov     BRGR0,#low(BRVAL)
0527 75BD03     450            mov     BRGCON,#0x03 ; Turn-on the baud rate generator
052A 759852     451            mov     SCON,#0x52 ; Serial port in mode 1, ren, txrdy, rxempty
052D 759100     452            mov     P1M1,#0x00 ; Enable pins RxD and TXD
0530 759200     453            mov     P1M2,#0x00 ; Enable pins RxD and TXD
0533 22         454            ret
0534            455            
0534            456   INIT_SPI:     
0534 D2A5       457            setb MY_MISO    ; Make MISO an input pin     
0536 C2A4       458            clr MY_SCLK     ; For mode (0,0) SCLK is zero     
0538 22         459            ret
0539            460   ;bit-bang SPI
0539            461   DO_SPI_G:     
0539 C0E0       462            push acc     
053B 7900       463            mov R1, #0      ; Received byte stored in R1     
053D 7A08       464            mov R2, #8      ; Loop counter (8-bits)
053F            465   DO_SPI_G_LOOP:     
053F E8         466            mov a, R0       ; Byte to write is in R0     
0540 33         467            rlc a           ; Carry flag has bit to write     
0541 F8         468            mov R0, a     
0542 92A6       469            mov MY_MOSI, c 
0544 D2A4       470            setb MY_SCLK    ; Transmit     
0546 A2A5       471            mov c, MY_MISO  ; Read received bit     
0548 E9         472            mov a, R1       ; Save received bit in R1    
0549 33         473            rlc a 
054A F9         474            mov R1, a     
054B C2A4       475            clr MY_SCLK     
054D DAF0       476            djnz R2, DO_SPI_G_LOOP     
054F D0E0       477            pop acc     
0551 22         478            ret 
0552            479            
0552            480   
0552            481   ; Send a character using the serial port
0552            482   putchar:
0552 109902     483            jbc     TI,putchar_L1
0555 80FB       484            sjmp putchar
0557            485   putchar_L1:
0557 F599       486            mov     SBUF,a
0559 22         487            ret
055A            488            
055A            489   getchar:
055A 109802     490            jbc     RI,getchar_L1
055D 80FB       491            sjmp getchar
055F            492   getchar_L1:
055F E599       493            mov     a,SBUF
0561 22         494            ret     
0562            495       
0562            496   ;approximate delay of 1s
0562            497   Delay:
0562 7A14       498       mov R2, #20
0564 79FA       499   L4: mov R1, #250
0566 78A6       500   L5: mov R0, #166
0568 D8FE       501   L6: djnz R0, L6 ; 3 cycles->3*45.21123ns*166=22.51519us
056A D9FA       502       djnz R1, L5 ; 22.51519us*250=5.629ms
056C DAF6       503       djnz R2, L4 ; 5.629ms*89=0.5s (approximately)
056E 22         504       ret
056F            505       
056F 30313233   506   HexAscii: db '0123456789ABCDEF'
     34353637
     38394142
     43444546
057F            507   
057F            508   SendTemp:
057F 90056F     509            mov dptr, #HexAscii 
0582            510            
0582 E53D       511            mov a, bcd+1
0584 C4         512            swap a
0585 540F       513            anl a, #0xf
0587 93         514            movc a, @a+dptr
0588 120552     515            lcall putchar
058B E53D       516            mov a, bcd+1
058D 540F       517            anl a, #0xf
058F 93         518            movc a, @a+dptr
0590 120552     519            lcall putchar
0593            520   
0593 742E       521            mov a, #'.'
0595 120552     522            lcall putchar
0598            523   
0598 E53C       524            mov a, bcd+0
059A C4         525            swap a
059B 540F       526            anl a, #0xf
059D 93         527            movc a, @a+dptr
059E 120552     528            lcall putchar
05A1 E53C       529            mov a, bcd+0
05A3 540F       530            anl a, #0xf
05A5 93         531            movc a, @a+dptr
05A6 120552     532            lcall putchar
05A9            533            
05A9 740D       534            mov a, #'\r'
05AB 120552     535            lcall putchar
05AE 740A       536            mov a, #'\n'
05B0 120552     537            lcall putchar   
05B3 22         538            ret    
05B4            539   
05B4            540   SendString:
05B4 E4         541       clr a
05B5 93         542       movc a, @a+dptr
05B6 6006       543       jz SendString_L1
05B8 120552     544       lcall putchar
05BB A3         545       inc dptr
05BC 80F6       546       sjmp SendString  
05BE            547   SendString_L1:
05BE 22         548            ret
05BF            549       
05BF            550   new_line:
05BF 0D0A00     551         DB '\r' ,'\n', 0     
05C2            552       
05C2            553   Display_putty:
05C2 C000       554            push ar0
05C4 A840       554            mov r0, bcd+4
05C6 120383     554            lcall ?Send_BCD
05C9 D000       554            pop ar0
05CB C000       555            push ar0
05CD A83F       555            mov r0, bcd+3
05CF 120383     555            lcall ?Send_BCD
05D2 D000       555            pop ar0
05D4 C000       556            push ar0
05D6 A83E       556            mov r0, bcd+2
05D8 120383     556            lcall ?Send_BCD
05DB D000       556            pop ar0
05DD C000       557            push ar0
05DF A83D       557            mov r0, bcd+1
05E1 120383     557            lcall ?Send_BCD
05E4 D000       557            pop ar0
05E6 C000       558            push ar0
05E8 A83C       558            mov r0, bcd+0
05EA 120383     558            lcall ?Send_BCD
05ED D000       558            pop ar0
05EF 22         559            ret   
05F0            560   
05F0            561   Ports_Init:
05F0            562       ; Configure all the ports in bidirectional mode:
05F0 758400     563       mov P0M1, #00H
05F3 758500     564       mov P0M2, #00H
05F6 759100     565       mov P1M1, #00H
05F9 759200     566       mov P1M2, #00H ; WARNING: P1.2 and P1.3 need 1 kohm pull-up resistors if used as outputs!
05FC 75A400     567       mov P2M1, #00H
05FF 75A500     568       mov P2M2, #00H
0602 75B100     569       mov P3M1, #00H
0605 75B200     570       mov P3M2, #00H
0608 22         571            ret
0609            572   
0609            573   ;---------------------------------;
0609            574   ; Initialize ADC1/DAC1 as DAC1.   ;
0609            575   ; Warning, the ADC1/DAC1 can work ;
0609            576   ; only as ADC or DAC, not both.   ;
0609            577   ; The P89LPC9351 has two ADC/DAC  ;
0609            578   ; interfaces.  One can be used as ;
0609            579   ; ADC and the other can be used   ;
0609            580   ; as DAC.  Also configures the    ;
0609            581   ; pin associated with the DAC, in ;
0609            582   ; this case P0.4 as 'Open Drain'. ;
0609            583   ;---------------------------------;
0609            584   InitDAC1:
0609            585       ; Configure pin P0.4 (DAC1 output pin) as open drain
0609 438410     586            orl     P0M1,   #00010000B
060C 438510     587            orl     P0M2,   #00010000B
060F 75A128     588       mov ADMODB, #00101000B ; Select main clock/2 for ADC/DAC.  Also enable DAC1 output (Table 25 of reference manual)
0612 759704     589            mov     ADCON1, #00000100B ; Enable the converter
0615 75F580     590            mov AD1DAT3, #0x80     ; Start value is 3.3V/2 (zero reference for AC WAV file)
0618 22         591            ret
0619            592   
0619            593   ;---------------------------------;
0619            594   ; Change the internal RC osc. clk ;
0619            595   ; from 7.373MHz to 14.746MHz.     ;
0619            596   ;---------------------------------;
0619            597   Double_Clk:
0619            598       ;mov dptr, #CLKCON
0619            599       ;movx a, @dptr
0619            600       ;orl a, #00001000B ; double the clock speed to 14.746MHz
0619            601       ;movx @dptr,a
0619 22         602            ret
061A            603   
061A            604   ;---------------------------------;
061A            605   ; Initialize the SPI interface    ;
061A            606   ; and the pins associated to SPI. ;
061A            607   ;---------------------------------;
061A            608   ;Init_SPI:
061A            609            ; Configure MOSI (P2.2), CS* (P2.4), and SPICLK (P2.5) as push-pull outputs (see table 42, page 51)
061A            610   ;        anl P2M1, #low(not(00110100B))
061A            611   ;        orl P2M2, #00110100B
061A            612            ; Configure MISO (P2.3) as input (see table 42, page 51)
061A            613   ;        orl P2M1, #00001000B
061A            614   ;        anl P2M2, #low(not(00001000B)) 
061A            615            ; Configure SPI
061A            616   ;        mov SPCTL, #11010000B ; Ignore /SS, Enable SPI, DORD=0, Master=1, CPOL=0, CPHA=0, clk/4
061A            617   ;        ret
061A            618   
061A            619   ;---------------------------------;
061A            620   ; Sends AND receives a byte via   ;
061A            621   ; SPI.                            ;
061A            622   ;---------------------------------;
061A            623   Send_SPI:
061A F5E3       624            mov SPDAT, a
061C            625   Send_SPI_1:
061C E5E1       626            mov a, SPSTAT 
061E 30E7FB     627            jnb acc.7, Send_SPI_1 ; Check SPI Transfer Completion Flag
0621 F5E1       628            mov SPSTAT, a ; Clear SPI Transfer Completion Flag
0623 E5E3       629            mov a, SPDAT ; return received byte via accumulator
0625 22         630            ret
0626            631   
0626            632   ;---------------------------------;
0626            633   ; SPI flash 'write enable'        ;
0626            634   ; instruction.                    ;
0626            635   ;---------------------------------;
0626            636   Enable_Write:
0626 C2A4       637            clr FLASH_CE
0628 7406       638            mov a, #WRITE_ENABLE
062A 12061A     639            lcall Send_SPI
062D D2A4       640            setb FLASH_CE
062F 22         641            ret
0630            642   
0630            643   ;---------------------------------;
0630            644   ; This function checks the 'write ;
0630            645   ; in progress' bit of the SPI     ;
0630            646   ; flash memory.                   ;
0630            647   ;---------------------------------;
0630            648   Check_WIP:
0630 C2A4       649            clr FLASH_CE
0632 7405       650            mov a, #READ_STATUS
0634 12061A     651            lcall Send_SPI
0637 7455       652            mov a, #0x55
0639 12061A     653            lcall Send_SPI
063C D2A4       654            setb FLASH_CE
063E 20E0EF     655            jb acc.0, Check_WIP ;  Check the Write in Progress bit
0641 22         656            ret
0642            657            
0642            658   ; Display a binary number in the LCD (must be less than 99).  Number to display passed in accumulator.
0642            659   LCD_number:
0642 C0E0       660            push acc
0644 75F00A     661            mov b, #10
0647 84         662            div ab
0648 4430       663            orl a, #'0'
064A 12031C     664            lcall ?WriteData
064D E5F0       665            mov a, b
064F 4430       666            orl a, #'0'
0651 12031C     667            lcall ?WriteData
0654 D0E0       668            pop acc
0656 22         669            ret
0657            670   
0657            671   ; Sounds we need in the SPI flash: 0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 30; 40; 50; minutes; seconds;
0657            672   ; Approximate index of sounds in file 'stop_watch.wav'
0657            673   ; This was generated using: computer_sender -Asw_index.asm -S2000 stop_watch.wav
0657            674   sound_index:
0657 00002D     675       db 0x00, 0x00, 0x2d ; 0 
065A 003107     676       db 0x00, 0x31, 0x07 ; 1 
065D 007007     677       db 0x00, 0x70, 0x07 ; 2 
0660 00ADB9     678       db 0x00, 0xad, 0xb9 ; 3 
0663 00F266     679       db 0x00, 0xf2, 0x66 ; 4 
0666 0135D5     680       db 0x01, 0x35, 0xd5 ; 5 
0669 017D33     681       db 0x01, 0x7d, 0x33 ; 6 
066C 01C761     682       db 0x01, 0xc7, 0x61 ; 7 
066F 021279     683       db 0x02, 0x12, 0x79 ; 8 
0672 0249C1     684       db 0x02, 0x49, 0xc1 ; 9 
0675 028F7A     685       db 0x02, 0x8f, 0x7a ; 10 
0678 02D063     686       db 0x02, 0xd0, 0x63 ; 11 
067B 031B87     687       db 0x03, 0x1b, 0x87 ; 12 
067E 03630E     688       db 0x03, 0x63, 0x0e ; 13 
0681 03B95F     689       db 0x03, 0xb9, 0x5f ; 14 
0684 04113A     690       db 0x04, 0x11, 0x3a ; 15 
0687 0466C4     691       db 0x04, 0x66, 0xc4 ; 16 
068A 04C012     692       db 0x04, 0xc0, 0x12 ; 17 
068D 052698     693       db 0x05, 0x26, 0x98 ; 18 
0690 0574E9     694       db 0x05, 0x74, 0xe9 ; 19 
0693 05D28E     695       db 0x05, 0xd2, 0x8e ; 20 
0696 061D83     696       db 0x06, 0x1d, 0x83 ; 21 -> 30 
0699 066342     697       db 0x06, 0x63, 0x42 ; 22 -> 40 
069C 06AAB9     698       db 0x06, 0xaa, 0xb9 ; 23 -> 50 
069F 06F3D6     699       db 0x06, 0xf3, 0xd6 ; 24 -> Minutes 
06A2 073F02     700       db 0x07, 0x3f, 0x02 ; 25 -> Seconds 
06A5            701   
06A5            702   ; Size of each sound in 'sound_index'
06A5            703   ; Generated using: computer_sender -Asw_index.asm -S2000 stop_watch.wav
06A5            704   Size_Length:
06A5 0030DA     705       db 0x00, 0x30, 0xda ; 0 
06A8 003F00     706       db 0x00, 0x3f, 0x00 ; 1 
06AB 003DB2     707       db 0x00, 0x3d, 0xb2 ; 2 
06AE 0044AD     708       db 0x00, 0x44, 0xad ; 3 
06B1 00436F     709       db 0x00, 0x43, 0x6f ; 4 
06B4 00475E     710       db 0x00, 0x47, 0x5e ; 5 
06B7 004A2E     711       db 0x00, 0x4a, 0x2e ; 6 
06BA 004B18     712       db 0x00, 0x4b, 0x18 ; 7 
06BD 003748     713       db 0x00, 0x37, 0x48 ; 8 
06C0 0045B9     714       db 0x00, 0x45, 0xb9 ; 9 
06C3 0040E9     715       db 0x00, 0x40, 0xe9 ; 10 
06C6 004B24     716       db 0x00, 0x4b, 0x24 ; 11 
06C9 004787     717       db 0x00, 0x47, 0x87 ; 12 
06CC 005651     718       db 0x00, 0x56, 0x51 ; 13 
06CF 0057DB     719       db 0x00, 0x57, 0xdb ; 14 
06D2 00558A     720       db 0x00, 0x55, 0x8a ; 15 
06D5 00594E     721       db 0x00, 0x59, 0x4e ; 16 
06D8 006686     722       db 0x00, 0x66, 0x86 ; 17 
06DB 004E51     723       db 0x00, 0x4e, 0x51 ; 18 
06DE 005DA5     724       db 0x00, 0x5d, 0xa5 ; 19 
06E1 004AF5     725       db 0x00, 0x4a, 0xf5 ; 20 
06E4 0045BF     726       db 0x00, 0x45, 0xbf ; 21 -> 30
06E7 004777     727       db 0x00, 0x47, 0x77 ; 22 -> 40
06EA 00491D     728       db 0x00, 0x49, 0x1d ; 23 -> 50
06ED 004B2C     729       db 0x00, 0x4b, 0x2c ; 24 -> minutes
06F0 005C87     730       db 0x00, 0x5c, 0x87 ; 25 -> seconds
06F3            731   
06F3            732   ; The sound and its length from the two tables above is passed in the accumulator.
06F3            733   Play_Sound_Using_Index:
06F3 D2A7       734            setb SOUND ; Turn speaker on
06F5 C2C8       735            clr TMOD20 ; Stop the CCU from playing previous request
06F7 D2A4       736            setb FLASH_CE
06F9            737            
06F9            738            ; There are three bytes per row in our tables, so multiply index by three
06F9 75F003     739            mov b, #3
06FC A4         740            mul ab
06FD F8         741            mov R0, a ; Make a copy of the index*3
06FE            742            
06FE C2A4       743            clr FLASH_CE ; Enable SPI Flash
0700 7403       744            mov a, #READ_BYTES
0702 12061A     745            lcall Send_SPI
0705            746            ; Set the initial position in memory of where to start playing
0705 900657     747            mov dptr, #sound_index
0708 E8         748            mov a, R0
0709 93         749            movc a, @a+dptr
070A 12061A     750            lcall Send_SPI
070D A3         751            inc dptr
070E E8         752            mov a, R0
070F 93         753            movc a, @a+dptr
0710 12061A     754            lcall Send_SPI
0713 A3         755            inc dptr
0714 E8         756            mov a, R0
0715 93         757            movc a, @a+dptr
0716 12061A     758            lcall Send_SPI
0719            759            ; Now set how many bytes to play
0719 9006A5     760            mov dptr, #Size_Length
071C E8         761            mov a, R0
071D 93         762            movc a, @a+dptr
071E F562       763            mov w+2, a
0720 A3         764            inc dptr
0721 E8         765            mov a, R0
0722 93         766            movc a, @a+dptr
0723 F561       767            mov w+1, a
0725 A3         768            inc dptr
0726 E8         769            mov a, R0
0727 93         770            movc a, @a+dptr
0728 F560       771            mov w+0, a
072A            772            
072A 7400       773            mov a, #0x00 ; Request first byte to send to DAC
072C 12061A     774            lcall Send_SPI
072F            775            
072F D2C8       776            setb TMOD20 ; Start playback by enabling CCU timer
0731            777   
0731 22         778            ret
0732            779    ; Send a character using the serial port
0732            780   
0732            781   
0732            782   ;---------------------------------------------------------------------------------;
0732            783   ; This is the FSM that plays minutes and seconds after the STOP button is pressed ;
0732            784   ; The state diagram of this FSM is available as 'Stop_Watch_FSM.pdf'              ;
0732            785   ;---------------------------------------------------------------------------------;
0732            786   T2S_FSM:
0732 E565       787            mov a, T2S_FSM_state
0734            788   
0734            789   T2S_FSM_State0: ; Checks for the start signal (T2S_FSM_Start==1)
0734 B40013     790            cjne a, #0, T2S_FSM_State1
0737 30000F     791            jnb T2S_FSM_Start, T2S_FSM_State0_Done
073A            792            ; Check if minutes is larger than 19
073A C3         793            clr c
073B E563       794            mov a, minutes
073D 9414       795            subb a, #20
073F 5005       796            jnc minutes_gt_19
0741 756501     797            mov T2S_FSM_state, #1
0744 8003       798            sjmp T2S_FSM_State0_Done
0746            799   minutes_gt_19:
0746 756503     800            mov T2S_FSM_state, #3
0749            801   T2S_FSM_State0_Done:
0749 22         802            ret
074A            803            
074A            804   T2S_FSM_State1: ; Plays minutes when minutes is less than 20
074A B40109     805            cjne a, #1, T2S_FSM_State2
074D E563       806            mov a, minutes
074F 1206F3     807            lcall Play_Sound_Using_Index
0752 756502     808            mov T2S_FSM_State, #2
0755 22         809            ret 
0756            810   
0756            811   T2S_FSM_State2: ; Stay in this state until sound finishes playing
0756 B40207     812            cjne a, #2, T2S_FSM_State3
0759 20C803     813            jb TMOD20, T2S_FSM_State2_Done 
075C 756506     814            mov T2S_FSM_State, #6
075F            815   T2S_FSM_State2_Done:
075F 22         816            ret
0760            817   
0760            818   T2S_FSM_State3: ; Plays the tens when minutes is larger than 19, for example for 42 minutes, it plays 'forty'
0760 B4030F     819            cjne a, #3, T2S_FSM_State4
0763 E563       820            mov a, minutes
0765 75F00A     821            mov b, #10
0768 84         822            div ab
0769 2412       823            add a, #18
076B 1206F3     824            lcall Play_Sound_Using_Index
076E 756504     825            mov T2S_FSM_State, #4
0771 22         826            ret
0772            827   
0772            828   T2S_FSM_State4: ; Stay in this state until sound finishes playing
0772 B40407     829            cjne a, #4, T2S_FSM_State5
0775 20C803     830            jb TMOD20, T2S_FSM_State4_Done 
0778 756505     831            mov T2S_FSM_State, #5
077B            832   T2S_FSM_State4_Done:
077B 22         833       ret
077C            834   
077C            835   T2S_FSM_State5: ; Plays the units when minutes is larger than 19, for example for 42 minutes, it plays 'two'
077C B40511     836            cjne a, #5, T2S_FSM_State6
077F E563       837            mov a, minutes
0781 75F00A     838            mov b, #10
0784 84         839            div ab
0785 E5F0       840            mov a, b
0787 6003       841            jz T2S_FSM_State5_Done ; Prevents from playing something like 'forty zero'
0789 1206F3     842            lcall Play_Sound_Using_Index
078C            843   T2S_FSM_State5_Done:
078C 756502     844            mov T2S_FSM_State, #2
078F 22         845            ret
0790            846   
0790            847   T2S_FSM_State6: ; Plays the word 'minutes'
0790 B40609     848            cjne a, #6, T2S_FSM_State7
0793 7418       849            mov a, #24 ; Index 24 has the word 'minutes'
0795 1206F3     850            lcall Play_Sound_Using_Index
0798 756507     851            mov T2S_FSM_State, #7
079B 22         852            ret
079C            853   
079C            854   T2S_FSM_State7: ; Stay in this state until sound finishes playing
079C B40713     855            cjne a, #7, T2S_FSM_State8
079F 20C80F     856            jb TMOD20, T2S_FSM_State7_Done 
07A2            857            ; Done playing previous sound, check if seconds is larger than 19
07A2 C3         858            clr c
07A3 E564       859            mov a, seconds
07A5 9414       860            subb a, #20
07A7 5005       861            jnc seconds_gt_19
07A9 756508     862            mov T2S_FSM_state, #8
07AC 809B       863            sjmp T2S_FSM_State0_Done
07AE            864   seconds_gt_19:
07AE 75650A     865            mov T2S_FSM_state, #10
07B1            866   T2S_FSM_State7_Done:
07B1 22         867       ret
07B2            868   
07B2            869   T2S_FSM_State8: ; Play the seconds when seconds is less than 20.
07B2 B40809     870            cjne a, #8, T2S_FSM_State9
07B5 E564       871            mov a, seconds
07B7 1206F3     872            lcall Play_Sound_Using_Index
07BA 756509     873            mov T2S_FSM_state, #9
07BD 22         874            ret
07BE            875   
07BE            876   T2S_FSM_State9: ; Stay in this state until sound finishes playing
07BE B40907     877            cjne a, #9, T2S_FSM_State10
07C1 20C803     878            jb TMOD20, T2S_FSM_State9_Done 
07C4 75650D     879            mov T2S_FSM_State, #13
07C7            880   T2S_FSM_State9_Done:
07C7 22         881            ret
07C8            882   
07C8            883   T2S_FSM_State10:  ; Plays the tens when seconds is larger than 19, for example for 35 seconds, it plays 'thirty'
07C8 B40A0F     884            cjne a, #10, T2S_FSM_State11
07CB E564       885            mov a, seconds
07CD 75F00A     886            mov b, #10
07D0 84         887            div ab
07D1 2412       888            add a, #18
07D3 1206F3     889            lcall Play_Sound_Using_Index
07D6 75650B     890            mov T2S_FSM_state, #11
07D9 22         891            ret
07DA            892   
07DA            893   T2S_FSM_State11: ; Stay in this state until sound finishes playing
07DA B40B07     894            cjne a, #11, T2S_FSM_State12
07DD 20C803     895            jb TMOD20, T2S_FSM_State11_Done 
07E0 75650C     896            mov T2S_FSM_State, #12
07E3            897   T2S_FSM_State11_Done:
07E3 22         898            ret
07E4            899   
07E4            900   T2S_FSM_State12: ; Plays the units when seconds is larger than 19, for example for 35 seconds, it plays 'five'
07E4 B40C11     901            cjne a, #12, T2S_FSM_State13
07E7 E564       902            mov a, seconds
07E9 75F00A     903            mov b, #10
07EC 84         904            div ab
07ED E5F0       905            mov a, b
07EF 6003       906            jz T2S_FSM_State12_Done ; Prevents from saying something like 'thirty zero'
07F1 1206F3     907            lcall Play_Sound_Using_Index
07F4            908   T2S_FSM_State12_Done:
07F4 756509     909            mov T2S_FSM_State, #9
07F7 22         910            ret
07F8            911   
07F8            912   T2S_FSM_State13: ; Plays the word 'seconds'
07F8 B40D09     913            cjne a, #13, T2S_FSM_State14
07FB 7419       914            mov a, #25 ; Index 25 has the word 'seconds'
07FD 1206F3     915            lcall Play_Sound_Using_Index
0800 75650E     916            mov T2S_FSM_State, #14
0803 22         917            ret
0804            918   
0804            919   T2S_FSM_State14: ; Stay in this state until sound finishes playing
0804 B40E09     920            cjne a, #14, T2S_FSM_Error
0807 20C805     921            jb TMOD20, T2S_FSM_State14_Done 
080A C200       922            clr T2S_FSM_Start 
080C 756500     923            mov T2S_FSM_State, #0
080F            924   T2S_FSM_State14_Done:
080F 22         925            ret
0810            926   
0810            927   T2S_FSM_Error: ; If we got to this point, there is an error in the finite state machine.  Restart it.
0810 756500     928            mov T2S_FSM_state, #0
0813 C200       929            clr T2S_FSM_Start
0815 22         930            ret
0816            931           
0816            932   ;WaitHalfSec:
0816            933       ;        mov R2, #178
0816            934       ;        Lr3: mov R1, #250
0816            935       ;        Lr2: mov R0, #166
0816            936       ;        Lr1: djnz R0, Lr1 ; 3 cycles->3*45.21123ns*166=22.51519us
0816            937       ;        djnz R1, Lr2 ; 22.51519us*250=5.629ms
0816            938       ;        djnz R2, Lr3 ; 5.629ms*89=0.5s (approximately)
0816            939       ;        ret
0816            940       ;    
0816            941       ;blink:
0816            942       ;        mov SP, #7FH
0816            943       ;        mov P3M1, #0   ; Configure P3 in bidirectional mode
0816            944       ;    M0:
0816            945       ;        cpl P3.7
0816            946       ;        Set_Cursor(1, 1)
0816            947       ;        Send_Constant_String(#nothing)
0816            948       ;        Set_Cursor(2, 1)
0816            949       ;        Send_Constant_String(#nothing)
0816            950       ;        Set_Cursor(1, 1)
0816            951       ;        Send_Constant_String(#hot)
0816            952       ;        Set_Cursor(2, 1)
0816            953       ;        Send_Constant_String(#hot)
0816            954       ;
0816            955       ;        lcall WaitHalfSec
0816            956       ;
0816            957       ;        ret
0816            958       ;
0816            959       ;convert:
0816            960       ;    mov x+0, Result
0816            961       ;    mov x+1, Result+1 
0816            962       ;    mov x+2, #0
0816            963       ;    mov x+3, #0
0816            964       ;    ret
0816            965       ;    
0816            966       ;
0816            967       Display_temp:
0816            968       ;    Load_y(410)
0816            969       ;    lcall mul32
0816            970       ;    Load_y(1023)
0816            971       ;    lcall div32
0816            972       ;    Load_y(273)
0816            973       ;    lcall sub32
0816            974       ;    lcall hex2bcd
0816            975       ;    lcall InitSerialPort
0816 C0E0       976            push acc
0818 7401       976            mov a, #1
081A 14         976            dec a
081B 120368     976            lcall ?Set_Cursor_1 ; Select column and row
081E D0E0       976            pop acc
0820 C083       977            push dph
0822 C082       977            push dpl
0824 C0E0       977            push acc
0826 9003F2     977            mov dptr, #Temp0
0829 12035B     977            lcall ?Send_Constant_String
082C D0E0       977            pop acc
082E D082       977            pop dpl
0830 D083       977            pop dph
0832            978       ;    lcall SendString
0832            979       ;    Set_Cursor(1, 5)    
0832            980       ;    Send_BCD(bcd+1) ; send fisrt 2 digits to putty
0832            981       ;    Display_BCD(bcd+1); send fisrt 2 digits to lcd
0832            982       ;    Set_Cursor(1, 7) 
0832            983       ;    Send_BCD(bcd) ; send last 2 digits to putty
0832            984       ;    Display_BCD(bcd+0) ; send last 2 digits to lcd
0832            985       ;    Set_Cursor(1, 5)
0832            986       ;    Send_Constant_String(#dots)
0832            987       ;    lcall SendString
0832            988       ;    mov DPTR, #Newline
0832            989       ;    lcall SendString
0832 22         990           ret
0833            991       ;config_adc:
0833            992       ;        clr CE_ADC 
0833            993       ;        mov R0, #00000001B; Start bit:1 
0833            994       ;        lcall DO_SPI_G
0833            995       ;
0833            996       ;        mov R0, #10000000B; Single ended, read channel 0 
0833            997       ;        lcall DO_SPI_G 
0833            998       ;        mov a, R1          ; R1 contains bits 8 and 9 
0833            999       ;        anl a, #00000011B  ; We need only the two least significant bits 
0833           1000       ;        mov Result+1, a    ; Save result high.
0833           1001       ;
0833           1002       ;        mov R0, #55H; It doesn't matter what we transmit... 
0833           1003       ;        lcall DO_SPI_G 
0833           1004       ;        mov Result, R1     ; R1 contains bits 0 to 7.  Save result low. 
0833           1005       ;        setb CE_ADC 
0833           1006       ;        lcall convert  
0833           1007       ;        mov a, bcd ; move temp to accumulator 
0833           1008       ;        ret
0833           1009   Reset_timer:
0833           1010   
0833 C28E      1011       clr TR1                 ; Stop timer 2
0835 E4        1012       clr a
0836 755E00    1013            mov Count10ms, #0x00
0839           1014            ; Now clear the BCD counter and minutes
0839 F558      1015            mov BCD_counter, a
083B D28E      1016            setb TR1                ; Start timer 2
083D           1017   
083D 22        1018       ret
083E           1019   Display_time:
083E C0E0      1020            push acc
0840 7401      1020            mov a, #1
0842 14        1020            dec a
0843 120366    1020            lcall ?Set_Cursor_2 ; Select column and row
0846 D0E0      1020            pop acc
0848 C083      1021            push dph
084A C082      1021            push dpl
084C C0E0      1021            push acc
084E 900403    1021            mov dptr, #Time
0851 12035B    1021            lcall ?Send_Constant_String
0854 D0E0      1021            pop acc
0856 D082      1021            pop dpl
0858 D083      1021            pop dph
085A C203      1022       clr half_seconds_flag ; We clear this flag in the main loop, but it is set in the ISR for timer 2
085C C20C      1023       clr my_flag
085E C0E0      1024            push acc
0860 7409      1024            mov a, #9
0862 14        1024            dec a
0863 120366    1024            lcall ?Set_Cursor_2 ; Select column and row
0866 D0E0      1024            pop acc     ; the place in the LCD where we want the BCD counter value
0868 C000      1025            push ar0
086A A858      1025            mov r0, BCD_counter
086C 12036D    1025            lcall ?Display_BCD
086F D000      1025            pop ar0 ; This macro is also in 'LCD_4bit.inc'
0871 C0E0      1026            push acc
0873 7406      1026            mov a, #6
0875 14        1026            dec a
0876 120366    1026            lcall ?Set_Cursor_2 ; Select column and row
0879 D0E0      1026            pop acc     ; the place in the LCD where we want the BCD counter value
087B C000      1027            push ar0
087D A863      1027            mov r0, minutes
087F 12036D    1027            lcall ?Display_BCD
0882 D000      1027            pop ar0 ; This macro is also in 'LCD_4bit.inc'
0884           1028   
0884 22        1029       ret
0885           1030   ;;Timer couter 
0885           1031       sec_counter: 
0885 E558      1032           mov a,BCD_counter
0887 B4600A    1033           cjne a, #0x60, Continue1 ; check if the couter reached 60s
088A E563      1034           mov a, minutes
088C 2401      1035           add a, #0x01 ; add one to the minutes
088E D4        1036           da a ; Decimal adjust instruction.  Check datasheet for more details!
088F F563      1037           mov minutes, a
0891 120833    1038           lcall Reset_timer
0894           1039                Continue1:
0894 22        1040           ret
0895           1041       min_counter:
0895 E563      1042                    mov a,minutes
0897 B4600A    1043                    cjne a, #0x60, Continue2
089A C28E      1044                    clr TR1                 ; Stop timer 2
089C E4        1045                    clr a                   
089D 755E00    1046                    mov Count10ms, #0x00      ; Now clear the BCD counter
08A0 F563      1047                    mov minutes, a              ; Reset minutes
08A2 D28E      1048           setb TR1                ; Start timer 2
08A4           1049   
08A4           1050                    Continue2:
08A4 22        1051           ret
08A5           1052   home_page:
08A5           1053   
08A5 20A718    1054         jb P2.7, continue20
08A8 C002      1055            push AR2
08AA 7A32      1055            mov R2, #50
08AC 1202D7    1055            lcall ?Wait_Milli_Seconds
08AF D002      1055            pop AR2 ; debounce
08B1 20A70C    1056      jb P2.7, continue20
08B4 30A7FD    1057      jnb p2.7, $
08B7           1058      ;clr TR1 
08B7 755800    1059       mov BCD_counter, #0x00
08BA 756300    1060       mov minutes, #0x0   
08BD 12083E    1061       lcall Display_time
08C0           1062   
08C0           1063      continue20:
08C0           1064       ;--------Timer----------;
08C0           1065   
08C0 300C09    1066       jnb my_flag, Temp_sensor
08C3 120885    1067       lcall sec_counter
08C6 120895    1068       lcall min_counter
08C9 12083E    1069       lcall Display_time
08CC           1070       ;-----------------------;
08CC           1071   
08CC           1072       ;-----TEMP SENSOR-------;
08CC           1073       Temp_sensor:
08CC           1074    ;    lcall config_adc
08CC 120816    1075       lcall Display_temp
08CF           1076    ;    lcall  WaitHalfSec 
08CF           1077    ;    ;-----------------------;
08CF           1078   
08CF           1079   
08CF           1080   
08CF           1081   
08CF 22        1082       ret
08D0           1083   ;
08D0           1084   setup_reflow_page:
08D0 20A111    1085            jb set_BUTTON, continue9
08D3 C002      1085            push AR2
08D5 7A0A      1085            mov R2, #10
08D7 1202D7    1085            lcall ?Wait_Milli_Seconds
08DA D002      1085            pop AR2
08DC 20A105    1085            jb set_BUTTON, continue9
08DF 30A1FD    1085            jnb set_BUTTON, $
08E2           1085   
08E2 B209      1086       cpl tt_reflow_flag
08E4           1087       continue9:
08E4           1088   
08E4 200906    1089       jb tt_reflow_flag, jump1
08E7           1090       ;jnb tt_reflow_flag, jump1
08E7 1209C9    1091       lcall INC_DEC_Reflow_time
08EA 0208F0    1092       ljmp display_reflow_page
08ED           1093       jump1:
08ED 120A11    1094       lcall INC_DEC_Reflow_temp
08F0           1095   
08F0           1096   
08F0           1097       display_reflow_page:
08F0 C0E0      1098            push acc
08F2 7405      1098            mov a, #5
08F4 14        1098            dec a
08F5 120368    1098            lcall ?Set_Cursor_1 ; Select column and row
08F8 D0E0      1098            pop acc
08FA C000      1099            push ar0
08FC A853      1099            mov r0, reflow_temp+0
08FE 12036D    1099            lcall ?Display_BCD
0901 D000      1099            pop ar0
0903 C0E0      1100            push acc
0905 7407      1100            mov a, #7
0907 14        1100            dec a
0908 120368    1100            lcall ?Set_Cursor_1 ; Select column and row
090B D0E0      1100            pop acc
090D C000      1101            push ar0
090F A854      1101            mov r0, reflow_temp+1
0911 12036D    1101            lcall ?Display_BCD
0914 D000      1101            pop ar0
0916           1102          
0916           1103       
0916 C0E0      1104            push acc
0918 7401      1104            mov a, #1
091A 14        1104            dec a
091B 120368    1104            lcall ?Set_Cursor_1 ; Select column and row
091E D0E0      1104            pop acc
0920 C083      1105            push dph
0922 C082      1105            push dpl
0924 C0E0      1105            push acc
0926 900425    1105            mov dptr, #reflow_setup
0929 12035B    1105            lcall ?Send_Constant_String
092C D0E0      1105            pop acc
092E D082      1105            pop dpl
0930 D083      1105            pop dph
0932 C0E0      1106            push acc
0934 7409      1106            mov a, #9
0936 14        1106            dec a
0937 120368    1106            lcall ?Set_Cursor_1 ; Select column and row
093A D0E0      1106            pop acc
093C C083      1107            push dph
093E C082      1107            push dpl
0940 C0E0      1107            push acc
0942 90042A    1107            mov dptr, #reflow_setup4
0945 12035B    1107            lcall ?Send_Constant_String
0948 D0E0      1107            pop acc
094A D082      1107            pop dpl
094C D083      1107            pop dph
094E           1108   
094E C0E0      1109            push acc
0950 7401      1109            mov a, #1
0952 14        1109            dec a
0953 120366    1109            lcall ?Set_Cursor_2 ; Select column and row
0956 D0E0      1109            pop acc
0958 C083      1110            push dph
095A C082      1110            push dpl
095C C0E0      1110            push acc
095E 900433    1110            mov dptr, #reflow_setup2
0961 12035B    1110            lcall ?Send_Constant_String
0964 D0E0      1110            pop acc
0966 D082      1110            pop dpl
0968 D083      1110            pop dph
096A C0E0      1111            push acc
096C 7408      1111            mov a, #8
096E 14        1111            dec a
096F 120366    1111            lcall ?Set_Cursor_2 ; Select column and row
0972 D0E0      1111            pop acc
0974 C083      1112            push dph
0976 C082      1112            push dpl
0978 C0E0      1112            push acc
097A 9003D8    1112            mov dptr, #dots
097D 12035B    1112            lcall ?Send_Constant_String
0980 D0E0      1112            pop acc
0982 D082      1112            pop dpl
0984 D083      1112            pop dph
0986 C0E0      1113            push acc
0988 740C      1113            mov a, #12
098A 14        1113            dec a
098B 120366    1113            lcall ?Set_Cursor_2 ; Select column and row
098E D0E0      1113            pop acc
0990 C083      1114            push dph
0992 C082      1114            push dpl
0994 C0E0      1114            push acc
0996 900438    1114            mov dptr, #reflow_setup3
0999 12035B    1114            lcall ?Send_Constant_String
099C D0E0      1114            pop acc
099E D082      1114            pop dpl
09A0 D083      1114            pop dph
09A2 C0E0      1115            push acc
09A4 7409      1115            mov a, #9
09A6 14        1115            dec a
09A7 120366    1115            lcall ?Set_Cursor_2 ; Select column and row
09AA D0E0      1115            pop acc
09AC C000      1116            push ar0
09AE A85A      1116            mov r0, reflow_sec
09B0 12036D    1116            lcall ?Display_BCD
09B3 D000      1116            pop ar0
09B5 C0E0      1117            push acc
09B7 7406      1117            mov a, #6
09B9 14        1117            dec a
09BA 120366    1117            lcall ?Set_Cursor_2 ; Select column and row
09BD D0E0      1117            pop acc
09BF C000      1118            push ar0
09C1 A85B      1118            mov r0, reflow_min
09C3 12036D    1118            lcall ?Display_BCD
09C6 D000      1118            pop ar0
09C8           1119   
09C8 22        1120       ret
09C9           1121       INC_DEC_Reflow_time:
09C9           1122   
09C9 208324    1123            jb SETUP_SOAK_Button, check_decrement
09CC C002      1123            push AR2
09CE 7A0A      1123            mov R2, #10
09D0 1202D7    1123            lcall ?Wait_Milli_Seconds
09D3 D002      1123            pop AR2
09D5 208318    1123            jb SETUP_SOAK_Button, check_decrement
09D8 3083FD    1123            jnb SETUP_SOAK_Button, $
09DB           1123    ; setup soak is also used to increment 
09DB           1124   
09DB E55A      1125           mov a, reflow_sec
09DD B4590B    1126           cjne a, #0x59, add_reflow_sec
09E0 E55B      1127           mov a, reflow_min
09E2 2401      1128           add a, #0x01
09E4 D4        1129           da a
09E5 F55B      1130           mov reflow_min, a
09E7 E4        1131           clr a 
09E8 0209EE    1132           ljmp Continue5
09EB           1133           add_reflow_sec:
09EB 2401      1134           add a, #0x01
09ED D4        1135           da a ; Decimal adjust instruction.  Check datasheet for more details!
09EE           1136           Continue5:
09EE F55A      1137           mov reflow_sec, a
09F0           1138   
09F0           1139           check_decrement:
09F0 20A01D    1140            jb Button_min, continue8
09F3 C002      1140            push AR2
09F5 7A0A      1140            mov R2, #10
09F7 1202D7    1140            lcall ?Wait_Milli_Seconds
09FA D002      1140            pop AR2
09FC 20A011    1140            jb Button_min, continue8
09FF 30A0FD    1140            jnb Button_min, $
0A02           1140   
0A02 E55A      1141           mov a, reflow_sec
0A04 B40004    1142           cjne a, #0x00, sub_reflow_sec
0A07 E4        1143           clr a 
0A08 020A0E    1144           ljmp Continue6
0A0B           1145           sub_reflow_sec:
0A0B 2499      1146           add a, #0x99 ; add 99 reduces 1
0A0D D4        1147           da a ; Decimal adjust instruction.  Check datasheet for more details!
0A0E           1148           Continue6:
0A0E F55A      1149           mov reflow_sec, a
0A10           1150           continue8:
0A10 22        1151           ret
0A11           1152       INC_DEC_Reflow_temp:
0A11           1153           ;PushButton(SETUP_SOAK_Button,check_decrement2) ; setup soak is also used to increment 
0A11           1154   
0A11 208321    1155            jb SETUP_SOAK_Button, check_decrement2
0A14 C002      1155            push AR2
0A16 7A0A      1155            mov R2, #10
0A18 1202D7    1155            lcall ?Wait_Milli_Seconds
0A1B D002      1155            pop AR2
0A1D 208315    1155            jb SETUP_SOAK_Button, check_decrement2
0A20 3083FD    1155            jnb SETUP_SOAK_Button, $
0A23           1155   
0A23           1156             ;  jb SETUP_SOAK_Button, check_decrement2  
0A23           1157             ;      Wait_Milli_Seconds(#50)         
0A23           1158             ;  jb SETUP_SOAK_Button, check_decrement2  
0A23           1159             ;  loop_hold_inc:
0A23           1160   ;
0A23           1161             ;  jnb SETUP_SOAK_Button, jump2
0A23           1162             ;  ;Wait_Milli_Seconds(#50)
0A23           1163             ;  jnb SETUP_SOAK_Button, jump2
0A23           1164             ;  ljmp hold_done
0A23           1165             ;  jump2:
0A23           1166             ;  Set_Cursor(1, 5)
0A23           1167             ;  Display_BCD(reflow_temp+0)
0A23           1168             ;  Set_Cursor(1, 7)
0A23           1169             ;  Display_BCD(reflow_temp+1)
0A23           1170             ;  Wait_Milli_Seconds(#100)    
0A23 E554      1171               mov a, reflow_temp+1
0A25 2401      1172               add a, #0x01
0A27 D4        1173               da a ; Decimal adjust instruction.  Check datasheet for more details!
0A28 F554      1174               mov reflow_temp+1, a
0A2A E554      1175               mov a, reflow_temp+1
0A2C 7007      1176               jnz INC_reflow_temp_done2
0A2E E553      1177               mov a, reflow_temp+0
0A30 2401      1178               add a, #0x01
0A32 D4        1179               da a ; Decimal adjust instruction.  Check datasheet for more details!
0A33 F553      1180               mov reflow_temp+0, a
0A35           1181              ; mov a, reflow_temp+1
0A35           1182               INC_reflow_temp_done2:
0A35           1183               
0A35           1184             ;  ljmp loop_hold_inc
0A35           1185           hold_done:
0A35           1186           
0A35           1187   
0A35           1188   
0A35           1189           check_decrement2:
0A35           1190   
0A35 20A021    1191            jb Button_min, DEC_reflow_temp_done2
0A38 C002      1191            push AR2
0A3A 7A0A      1191            mov R2, #10
0A3C 1202D7    1191            lcall ?Wait_Milli_Seconds
0A3F D002      1191            pop AR2
0A41 20A015    1191            jb Button_min, DEC_reflow_temp_done2
0A44 30A0FD    1191            jnb Button_min, $
0A47           1191   
0A47           1192            ;   jb Button_min, DEC_reflow_temp_done2  
0A47           1193            ;       Wait_Milli_Seconds(#50)         
0A47           1194            ;   jb Button_min, DEC_reflow_temp_done2  
0A47           1195            ;   loop_hold_dec:
0A47           1196   ;
0A47           1197            ;   jnb Button_min, jump3
0A47           1198            ;   ljmp DEC_reflow_temp_done2
0A47           1199            ;   jump3:
0A47           1200            ;   Set_Cursor(1, 5)
0A47           1201            ;   Display_BCD(reflow_temp+0)
0A47           1202            ;   Set_Cursor(1, 7)
0A47           1203            ;   Display_BCD(reflow_temp+1)
0A47           1204            ;   Wait_Milli_Seconds(#100)    
0A47 E554      1205               mov a, reflow_temp+1
0A49 2499      1206               add a, #0x99
0A4B D4        1207               da a ; Decimal adjust instruction.  Check datasheet for more details!
0A4C F554      1208               mov reflow_temp+1, a
0A4E E554      1209               mov a, reflow_temp+1
0A50 7007      1210               jnz INC_reflow_temp_done
0A52 E553      1211               mov a, reflow_temp+0
0A54 2499      1212               add a, #0x99
0A56 D4        1213               da a ; Decimal adjust instruction.  Check datasheet for more details!
0A57 F553      1214               mov reflow_temp+0, a
0A59           1215             ;  mov a, reflow_temp+1
0A59           1216               INC_reflow_temp_done:
0A59           1217               
0A59           1218             ;  ljmp loop_hold_dec
0A59           1219   
0A59           1220           DEC_reflow_temp_done2:
0A59           1221       
0A59           1222   
0A59 22        1223       ret
0A5A           1224   setup_soak_page:
0A5A 20A111    1225            jb set_BUTTON, continue11
0A5D C002      1225            push AR2
0A5F 7A0A      1225            mov R2, #10
0A61 1202D7    1225            lcall ?Wait_Milli_Seconds
0A64 D002      1225            pop AR2
0A66 20A105    1225            jb set_BUTTON, continue11
0A69 30A1FD    1225            jnb set_BUTTON, $
0A6C           1225   
0A6C B20A      1226       cpl tt_flag_soak
0A6E           1227       continue11:
0A6E           1228   
0A6E 200A06    1229       jb tt_flag_soak, jump4
0A71 120B53    1230       lcall INC_DEC_soak_time
0A74 020A7A    1231       ljmp display_soak_page
0A77           1232       jump4:
0A77 120B9B    1233       lcall INC_DEC_soak_temp
0A7A           1234   
0A7A           1235   
0A7A           1236       display_soak_page:
0A7A C0E0      1237            push acc
0A7C 7405      1237            mov a, #5
0A7E 14        1237            dec a
0A7F 120368    1237            lcall ?Set_Cursor_1 ; Select column and row
0A82 D0E0      1237            pop acc
0A84 C000      1238            push ar0
0A86 A855      1238            mov r0, soak_temp+0
0A88 12036D    1238            lcall ?Display_BCD
0A8B D000      1238            pop ar0
0A8D C0E0      1239            push acc
0A8F 7407      1239            mov a, #7
0A91 14        1239            dec a
0A92 120368    1239            lcall ?Set_Cursor_1 ; Select column and row
0A95 D0E0      1239            pop acc
0A97 C000      1240            push ar0
0A99 A856      1240            mov r0, soak_temp+1
0A9B 12036D    1240            lcall ?Display_BCD
0A9E D000      1240            pop ar0
0AA0           1241          
0AA0           1242       
0AA0 C0E0      1243            push acc
0AA2 7401      1243            mov a, #1
0AA4 14        1243            dec a
0AA5 120368    1243            lcall ?Set_Cursor_1 ; Select column and row
0AA8 D0E0      1243            pop acc
0AAA C083      1244            push dph
0AAC C082      1244            push dpl
0AAE C0E0      1244            push acc
0AB0 90043D    1244            mov dptr, #soak_setup0
0AB3 12035B    1244            lcall ?Send_Constant_String
0AB6 D0E0      1244            pop acc
0AB8 D082      1244            pop dpl
0ABA D083      1244            pop dph
0ABC C0E0      1245            push acc
0ABE 7409      1245            mov a, #9
0AC0 14        1245            dec a
0AC1 120368    1245            lcall ?Set_Cursor_1 ; Select column and row
0AC4 D0E0      1245            pop acc
0AC6           1245   
0AC6 C083      1246            push dph
0AC8 C082      1246            push dpl
0ACA C0E0      1246            push acc
0ACC 900442    1246            mov dptr, #soak_setup1
0ACF 12035B    1246            lcall ?Send_Constant_String
0AD2 D0E0      1246            pop acc
0AD4 D082      1246            pop dpl
0AD6 D083      1246            pop dph
0AD8           1247   
0AD8 C0E0      1248            push acc
0ADA 7401      1248            mov a, #1
0ADC 14        1248            dec a
0ADD 120366    1248            lcall ?Set_Cursor_2 ; Select column and row
0AE0 D0E0      1248            pop acc
0AE2           1248   
0AE2 C083      1249            push dph
0AE4 C082      1249            push dpl
0AE6 C0E0      1249            push acc
0AE8 90044A    1249            mov dptr, #soak_setup2
0AEB 12035B    1249            lcall ?Send_Constant_String
0AEE D0E0      1249            pop acc
0AF0 D082      1249            pop dpl
0AF2 D083      1249            pop dph
0AF4 C0E0      1250            push acc
0AF6 7408      1250            mov a, #8
0AF8 14        1250            dec a
0AF9 120366    1250            lcall ?Set_Cursor_2 ; Select column and row
0AFC D0E0      1250            pop acc
0AFE           1250   
0AFE C083      1251            push dph
0B00 C082      1251            push dpl
0B02 C0E0      1251            push acc
0B04 9003D8    1251            mov dptr, #dots
0B07 12035B    1251            lcall ?Send_Constant_String
0B0A D0E0      1251            pop acc
0B0C D082      1251            pop dpl
0B0E D083      1251            pop dph
0B10 C0E0      1252            push acc
0B12 740C      1252            mov a, #12
0B14 14        1252            dec a
0B15 120366    1252            lcall ?Set_Cursor_2 ; Select column and row
0B18 D0E0      1252            pop acc
0B1A C083      1253            push dph
0B1C C082      1253            push dpl
0B1E C0E0      1253            push acc
0B20 90044F    1253            mov dptr, #soak_setup3
0B23 12035B    1253            lcall ?Send_Constant_String
0B26 D0E0      1253            pop acc
0B28 D082      1253            pop dpl
0B2A D083      1253            pop dph
0B2C C0E0      1254            push acc
0B2E 7409      1254            mov a, #9
0B30 14        1254            dec a
0B31 120366    1254            lcall ?Set_Cursor_2 ; Select column and row
0B34 D0E0      1254            pop acc
0B36           1254   
0B36 C000      1255            push ar0
0B38 A85C      1255            mov r0, soak_sec
0B3A 12036D    1255            lcall ?Display_BCD
0B3D D000      1255            pop ar0
0B3F C0E0      1256            push acc
0B41 7406      1256            mov a, #6
0B43 14        1256            dec a
0B44 120366    1256            lcall ?Set_Cursor_2 ; Select column and row
0B47 D0E0      1256            pop acc
0B49 C000      1257            push ar0
0B4B A85D      1257            mov r0, soak_min
0B4D 12036D    1257            lcall ?Display_BCD
0B50 D000      1257            pop ar0
0B52 22        1258   ret
0B53           1259       INC_DEC_soak_time:
0B53           1260       
0B53 208324    1261            jb SETUP_SOAK_Button, check_decrement_soak
0B56 C002      1261            push AR2
0B58 7A0A      1261            mov R2, #10
0B5A 1202D7    1261            lcall ?Wait_Milli_Seconds
0B5D D002      1261            pop AR2
0B5F 208318    1261            jb SETUP_SOAK_Button, check_decrement_soak
0B62 3083FD    1261            jnb SETUP_SOAK_Button, $
0B65           1261    ; setup soak is also used to increment 
0B65           1262   
0B65 E55C      1263           mov a, soak_sec
0B67 B4590B    1264           cjne a, #0x59, add_soak_sec
0B6A E55D      1265           mov a, soak_min
0B6C 2401      1266           add a, #0x01
0B6E D4        1267           da a
0B6F F55D      1268           mov soak_min, a
0B71 E4        1269           clr a 
0B72 020B78    1270           ljmp Continue12
0B75           1271           add_soak_sec:
0B75 2401      1272           add a, #0x01
0B77 D4        1273           da a ; Decimal adjust instruction.  Check datasheet for more details!
0B78           1274           Continue12:
0B78 F55C      1275           mov soak_sec, a
0B7A           1276   
0B7A           1277           check_decrement_soak:
0B7A 20A01D    1278            jb Button_min, continue13
0B7D C002      1278            push AR2
0B7F 7A0A      1278            mov R2, #10
0B81 1202D7    1278            lcall ?Wait_Milli_Seconds
0B84 D002      1278            pop AR2
0B86 20A011    1278            jb Button_min, continue13
0B89 30A0FD    1278            jnb Button_min, $
0B8C           1278   
0B8C E55C      1279           mov a, soak_sec
0B8E B40004    1280           cjne a, #0x00, sub_soak_sec
0B91 E4        1281           clr a 
0B92 020B98    1282           ljmp Continue14
0B95           1283           sub_soak_sec:
0B95 2499      1284           add a, #0x99 ; add 99 reduces 1
0B97 D4        1285           da a ; Decimal adjust instruction.  Check datasheet for more details!
0B98           1286           Continue14:
0B98 F55C      1287           mov soak_sec, a
0B9A           1288           continue13:
0B9A           1289           
0B9A 22        1290           ret
0B9B           1291       INC_DEC_soak_temp:
0B9B           1292           
0B9B 208321    1293            jb SETUP_SOAK_Button, check_decrement2_soak
0B9E C002      1293            push AR2
0BA0 7A0A      1293            mov R2, #10
0BA2 1202D7    1293            lcall ?Wait_Milli_Seconds
0BA5 D002      1293            pop AR2
0BA7 208315    1293            jb SETUP_SOAK_Button, check_decrement2_soak
0BAA 3083FD    1293            jnb SETUP_SOAK_Button, $
0BAD           1293   
0BAD           1294           ;    jb SETUP_SOAK_Button, check_decrement2_soak  
0BAD           1295           ;        Wait_Milli_Seconds(#50)         
0BAD           1296           ;    jb SETUP_SOAK_Button, check_decrement2_soak  
0BAD           1297           ;    loop_hold_inc_soak:
0BAD           1298         ;
0BAD           1299           ;    jnb SETUP_SOAK_Button, jump6
0BAD           1300           ;    Wait_Milli_Seconds(#100)
0BAD           1301           ;    jnb SETUP_SOAK_Button, jump6
0BAD           1302           ;    ljmp hold_done_soak
0BAD           1303           ;    jump6:
0BAD           1304           ;    Set_Cursor(1, 5)
0BAD           1305           ;    Display_BCD(soak_temp+0)
0BAD           1306           ;    Set_Cursor(1, 7)
0BAD           1307           ;    Display_BCD(soak_temp+1)
0BAD           1308           ;    Wait_Milli_Seconds(#200)    
0BAD E556      1309               mov a, soak_temp+1
0BAF 2401      1310               add a, #0x01
0BB1 D4        1311               da a ; Decimal adjust instruction.  Check datasheet for more details!
0BB2 F556      1312               mov soak_temp+1, a
0BB4 E556      1313               mov a, soak_temp+1
0BB6 7007      1314               jnz INC_soak_temp_done2
0BB8 E555      1315               mov a, soak_temp+0
0BBA 2401      1316               add a, #0x01
0BBC D4        1317               da a ; Decimal adjust instruction.  Check datasheet for more details!
0BBD F555      1318               mov soak_temp+0, a
0BBF           1319              ; mov a, soak_temp+1
0BBF           1320               INC_soak_temp_done2:
0BBF           1321               
0BBF           1322             ;  ljmp loop_hold_inc_soak
0BBF           1323           hold_done_soak:
0BBF           1324           
0BBF           1325   
0BBF           1326   
0BBF           1327           check_decrement2_soak:
0BBF           1328   
0BBF 20A021    1329            jb Button_min, DEC_soak_temp_done2
0BC2 C002      1329            push AR2
0BC4 7A0A      1329            mov R2, #10
0BC6 1202D7    1329            lcall ?Wait_Milli_Seconds
0BC9 D002      1329            pop AR2
0BCB 20A015    1329            jb Button_min, DEC_soak_temp_done2
0BCE 30A0FD    1329            jnb Button_min, $
0BD1           1329   
0BD1           1330              ; 
0BD1           1331              ; jb Button_min, DEC_soak_temp_done2  
0BD1           1332              ;     Wait_Milli_Seconds(#50)         
0BD1           1333              ; jb Button_min, DEC_soak_temp_done2  
0BD1           1334              ; loop_hold_dec_soak:
0BD1           1335                ;
0BD1           1336              ; jnb Button_min, jump7
0BD1           1337              ; Wait_Milli_Seconds(#100)
0BD1           1338              ; jnb Button_min, jump7
0BD1           1339              ; ljmp DEC_soak_temp_done2
0BD1           1340              ; jump7:
0BD1           1341              ; Set_Cursor(1, 5)
0BD1           1342              ; Display_BCD(soak_temp+0)
0BD1           1343              ; Set_Cursor(1, 7)
0BD1           1344              ; Display_BCD(soak_temp+1)
0BD1           1345              ; Wait_Milli_Seconds(#100)    
0BD1 E556      1346               mov a, soak_temp+1
0BD3 2499      1347               add a, #0x99
0BD5 D4        1348               da a ; Decimal adjust instruction.  Check datasheet for more details!
0BD6 F556      1349               mov soak_temp+1, a
0BD8 E556      1350               mov a, soak_temp+1
0BDA 7007      1351               jnz INC_soak_temp_done
0BDC E555      1352               mov a, soak_temp+0
0BDE 2499      1353               add a, #0x99
0BE0 D4        1354               da a ; Decimal adjust instruction.  Check datasheet for more details!
0BE1 F555      1355               mov soak_temp+0, a
0BE3           1356             ;  mov a, soak_temp+1
0BE3           1357               INC_soak_temp_done:
0BE3           1358               
0BE3           1359              ; ljmp loop_hold_dec_soak
0BE3           1360   
0BE3           1361           DEC_soak_temp_done2:
0BE3 22        1362           ret
0BE4           1363   second_page:
0BE4 C0E0      1364            push acc
0BE6 7401      1364            mov a, #1
0BE8 14        1364            dec a
0BE9 120368    1364            lcall ?Set_Cursor_1 ; Select column and row
0BEC D0E0      1364            pop acc
0BEE C083      1365            push dph
0BF0 C082      1365            push dpl
0BF2 C0E0      1365            push acc
0BF4 900414    1365            mov dptr, #soak_reflw
0BF7 12035B    1365            lcall ?Send_Constant_String
0BFA D0E0      1365            pop acc
0BFC D082      1365            pop dpl
0BFE D083      1365            pop dph
0C00 C0E0      1366            push acc
0C02 7401      1366            mov a, #1
0C04 14        1366            dec a
0C05 120366    1366            lcall ?Set_Cursor_2 ; Select column and row
0C08 D0E0      1366            pop acc
0C0A C083      1367            push dph
0C0C C082      1367            push dpl
0C0E C0E0      1367            push acc
0C10 9003A5    1367            mov dptr, #nothing
0C13 12035B    1367            lcall ?Send_Constant_String
0C16 D0E0      1367            pop acc
0C18 D082      1367            pop dpl
0C1A D083      1367            pop dph
0C1C 22        1368       ret
0C1D           1369   
0C1D           1370   FSM_LCD:
0C1D E546      1371           mov a, state_lcd
0C1F           1372   
0C1F           1373   
0C1F           1374           ;----------------STATE 0------------------;
0C1F           1375            home_state:
0C1F B4001E    1376               cjne a, #0, soak_reflow_state
0C22 20A115    1377            jb set_BUTTON, done_home2
0C25 C002      1377            push AR2
0C27 7A0A      1377            mov R2, #10
0C29 1202D7    1377            lcall ?Wait_Milli_Seconds
0C2C D002      1377            pop AR2
0C2E 20A109    1377            jb set_BUTTON, done_home2
0C31 30A1FD    1377            jnb set_BUTTON, $
0C34           1377    
0C34           1378               ;setb set_flag  
0C34 754601    1379               mov state_lcd, #1
0C37 020C3D    1380               ljmp done_home
0C3A           1381               done_home2:
0C3A           1382               ;clr set_flag
0C3A 1208A5    1383               lcall home_page
0C3D           1384               done_home:
0C3D 020CDC    1385               ljmp Forever_done           
0C40           1386           ;------------------------------------------;
0C40           1387           
0C40           1388        ;   ;----------------STATE 1-------------------;
0C40           1389           soak_reflow_state:
0C40 B4014B    1390               cjne a, #1, setup_soak
0C43 120BE4    1391               lcall second_page
0C46           1392             ;  Wait_Milli_Seconds(#50)
0C46 120885    1393               lcall sec_counter ; prevent the timer to go over 60
0C49 120895    1394               lcall min_counter
0C4C 208212    1395            jb HOME_BUTTON, next_pushb
0C4F C002      1395            push AR2
0C51 7A0A      1395            mov R2, #10
0C53 1202D7    1395            lcall ?Wait_Milli_Seconds
0C56 D002      1395            pop AR2
0C58 208206    1395            jb HOME_BUTTON, next_pushb
0C5B 3082FD    1395            jnb HOME_BUTTON, $
0C5E           1395    ; check if home button is pressed 
0C5E 754600    1396               mov state_lcd, #0
0C61           1397               next_pushb:
0C61 208312    1398            jb SETUP_SOAK_Button, next_pushb2
0C64 C002      1398            push AR2
0C66 7A0A      1398            mov R2, #10
0C68 1202D7    1398            lcall ?Wait_Milli_Seconds
0C6B D002      1398            pop AR2
0C6D 208306    1398            jb SETUP_SOAK_Button, next_pushb2
0C70 3083FD    1398            jnb SETUP_SOAK_Button, $
0C73           1398    ; check if the the button to setup soak is pressed
0C73 754602    1399               mov state_lcd, #2
0C76           1400               next_pushb2:
0C76 20A012    1401            jb Button_min, done_soak
0C79 C002      1401            push AR2
0C7B 7A0A      1401            mov R2, #10
0C7D 1202D7    1401            lcall ?Wait_Milli_Seconds
0C80 D002      1401            pop AR2
0C82 20A006    1401            jb Button_min, done_soak
0C85 30A0FD    1401            jnb Button_min, $
0C88           1401    ; check if the buttion to setup the reflow was pressed 
0C88 754603    1402               mov state_lcd, #3
0C8B           1403               done_soak:
0C8B 020CDC    1404              ljmp Forever_done 
0C8E           1405           ;------------------------------------------;
0C8E           1406   ;
0C8E           1407        ;   ;-----------------STATE 2------------------;
0C8E           1408           setup_soak: ; its actually set up reflow Im dumb
0C8E B40221    1409               cjne a, #2, setup_reflow
0C91 1208D0    1410               lcall setup_reflow_page
0C94           1411             ;  Wait_Milli_Seconds(#50)
0C94 120885    1412               lcall sec_counter ; prevent the timer to go over 60
0C97 120895    1413               lcall min_counter
0C9A 208212    1414            jb HOME_BUTTON, done_setup_soak
0C9D C002      1414            push AR2
0C9F 7A0A      1414            mov R2, #10
0CA1 1202D7    1414            lcall ?Wait_Milli_Seconds
0CA4 D002      1414            pop AR2
0CA6 208206    1414            jb HOME_BUTTON, done_setup_soak
0CA9 3082FD    1414            jnb HOME_BUTTON, $
0CAC           1414    ; check if home button is pressed 
0CAC 754600    1415               mov state_lcd, #0
0CAF           1416               done_setup_soak:
0CAF 020CDC    1417               ljmp Forever_done 
0CB2           1418           ;------------------------------------------;
0CB2           1419   ;
0CB2           1420        ;   ;----------------STATE 3-------------------;
0CB2           1421           setup_reflow: ; its actually set up soak Im dumb
0CB2 B40303    1422               cjne a, #3, FDP
0CB5 020CBB    1423               ljmp FDP2
0CB8           1424               FDP:
0CB8 020C1F    1425               ljmp home_state
0CBB           1426               FDP2:
0CBB 120A5A    1427               lcall setup_soak_page
0CBE 120885    1428               lcall sec_counter ; prevent the timer to go over 60
0CC1 120895    1429               lcall min_counter
0CC4 208212    1430            jb HOME_BUTTON, done_setup_reflow
0CC7 C002      1430            push AR2
0CC9 7A0A      1430            mov R2, #10
0CCB 1202D7    1430            lcall ?Wait_Milli_Seconds
0CCE D002      1430            pop AR2
0CD0 208206    1430            jb HOME_BUTTON, done_setup_reflow
0CD3 3082FD    1430            jnb HOME_BUTTON, $
0CD6           1430    ; check if home button is pressed 
0CD6 754600    1431               mov state_lcd, #0
0CD9           1432               done_setup_reflow:
0CD9 020CDC    1433               ljmp Forever_done 
0CDC           1434        ;   ;------------------------------------------;
0CDC           1435           Forever_done:
0CDC 22        1436   ret
0CDD           1437   
0CDD           1438   hannah:
0CDD           1439            ;read channel 0 of the ADC and transmitting this info to the MCU
0CDD C2A7      1440            clr CE_ADC ;enable device (active low)
0CDF           1441            ;transmit the info from channel 0
0CDF 7801      1442            mov R0, #00000001B ;start bit:1
0CE1 120539    1443            lcall DO_SPI_G
0CE4           1444            
0CE4 7880      1445            mov R0, #10000000B ;read channel 0
0CE6 120539    1446            lcall DO_SPI_G
0CE9 E9        1447            mov a, R1          ; R1 contains bits 8 and 9 
0CEA 5403      1448            anl a, #00000011B  ; We need only the two least significant bits
0CEC F54C      1449            mov ch0+1, a    ; Save result high
0CEE           1450            
0CEE 7855      1451            mov R0, #55H   ; It doesn't matter what we transmit... 
0CF0 120539    1452            lcall DO_SPI_G  
0CF3 894B      1453            mov ch0+0, R1     ; R1 contains bits 0 to 7.  Save result low. 
0CF5 D2A7      1454            setb CE_ADC ;disable device
0CF7           1455            
0CF7 C2A7      1456            clr CE_ADC ;enable device
0CF9           1457            ;transmit from channel 1
0CF9 7801      1458            mov R0, #00000001B ;start bit:1
0CFB 120539    1459            lcall DO_SPI_G
0CFE           1460            
0CFE 7890      1461            mov R0, #10010000B ;read channel 1
0D00 120539    1462            lcall DO_SPI_G
0D03 E9        1463            mov a, R1          ; R1 contains bits 8 and 9 
0D04 5403      1464            anl a, #00000011B  ; We need only the two least significant bits
0D06 F54E      1465            mov ch1+1, a    ; Save result high
0D08           1466            
0D08 7855      1467            mov R0, #55H   ; It doesn't matter what we transmit... 
0D0A 120539    1468            lcall DO_SPI_G  
0D0D 894D      1469            mov ch1+0, R1     ; R1 contains bits 0 to 7.  Save result low. 
0D0F D2A7      1470            setb CE_ADC ;disable device (active low)
0D11           1471            
0D11 120562    1472            lcall Delay ;about 1s
0D14           1473            
0D14           1474            ;convert the voltage from ch0(LM335) to temperature and display in putty - ch0 correspond to the cold jnc temp
0D14 854B34    1475            mov x+0, ch0
0D17 854C35    1476            mov x+1, ch0+1
0D1A 753600    1477            mov x+2, #0
0D1D 753700    1478            mov x+3, #0
0D20           1479            
0D20 75389A    1480            mov y+0, #low (410 % 0x10000) 
0D23 753901    1480            mov y+1, #high(410 % 0x10000) 
0D26 753A00    1480            mov y+2, #low (410 / 0x10000) 
0D29 753B00    1480            mov y+3, #high(410 / 0x10000) 
0D2C 1201D8    1481            lcall mul32
0D2F 7538FF    1482            mov y+0, #low (1023 % 0x10000) 
0D32 753903    1482            mov y+1, #high(1023 % 0x10000) 
0D35 753A00    1482            mov y+2, #low (1023 / 0x10000) 
0D38 753B00    1482            mov y+3, #high(1023 / 0x10000) 
0D3B 120265    1483            lcall div32
0D3E 753811    1484            mov y+0, #low (273 % 0x10000) 
0D41 753901    1484            mov y+1, #high(273 % 0x10000) 
0D44 753A00    1484            mov y+2, #low (273 / 0x10000) 
0D47 753B00    1484            mov y+3, #high(273 / 0x10000) 
0D4A 120144    1485            lcall sub32 
0D4D 12005E    1486            lcall hex2bcd
0D50           1487            ;lcall Display_putty
0D50           1488            
0D50           1489            ;do the same for ch1(output voltage of OP AMP) - ch1 corresponds to the hot jnc temp
0D50 854D34    1490            mov x+0, ch1
0D53 854E35    1491            mov x+1, ch1+1
0D56 753600    1492            mov x+2, #0
0D59 753700    1493            mov x+3, #0
0D5C           1494            
0D5C           1495            ;load_y(1000000)
0D5C           1496            ;lcall mul32
0D5C           1497            ;load_y(OP_AMP_GAIN)
0D5C           1498            ;lcall div32
0D5C           1499            ;load_y(41)
0D5C           1500            ;lcall div32 
0D5C           1501   
0D5C           1502       ;load_y(8000)
0D5C           1503       ;lcall add32
0D5C           1504       ;load_y(258)
0D5C           1505       ;lcall div32
0D5C           1506       
0D5C           1507       ;load_y(24)
0D5C           1508       ;lcall add32
0D5C           1509       
0D5C           1510       ;load_y(10)
0D5C           1511       ;lcall div32
0D5C           1512   
0D5C 12005E    1513            lcall hex2bcd
0D5F 1205C2    1514            lcall Display_putty
0D62           1515            
0D62 740D      1516            mov a, #'\r'
0D64 120552    1517            lcall putchar
0D67 740A      1518            mov a, #'\n'
0D69 120552    1519            lcall putchar
0D6C           1520            
0D6C           1521            ;now that we have the cold and hot junction temps in variables ch0 and ch1 respectively, we can add them to get the actual temperature
0D6C           1522            
0D6C           1523            
0D6C 22        1524   ret
0D6D           1525   ;------------------------------
0D6D           1526   ;---------------------------------;
0D6D           1527   ; Main program. Includes hardware ;
0D6D           1528   ; initialization and 'forever'    ;
0D6D           1529   ; loop.                           ;
0D6D           1530   ;---------------------------------;
0D6D           1531   main:
0D6D           1532            ; Initialization
0D6D 75817F    1533       mov SP, #0x7F
0D70 120454    1534       lcall Timer0_Init
0D73 12047F    1535       lcall Timer1_Init
0D76           1536   
0D76 1205F0    1537       lcall Ports_Init ; Default all pins as bidirectional I/O. See Table 42.
0D79 120326    1538       lcall LCD_4BIT
0D7C           1539       ;lcall Double_Clk
0D7C           1540            ;lcall InitDAC1 ; Call after 'Ports_Init'
0D7C 1204D8    1541            lcall CCU_Init
0D7F 120534    1542            lcall Init_SPI
0D82           1543            
0D82           1544            
0D82 D2AF      1545            setb EA ; Enable global interrupts.
0D84           1546   
0D84           1547            ; Initialize variables
0D84 C200      1548            clr T2S_FSM_Start
0D86 756500    1549            mov T2S_FSM_state, #0
0D89           1550       ; Configure all the ports in bidirectional mode:
0D89           1551   
0D89 758400    1552       mov P0M1, #00H
0D8C 758500    1553       mov P0M2, #00H
0D8F 759100    1554       mov P1M1, #00H
0D92 759200    1555       mov P1M2, #00H ; WARNING: P1.2 and P1.3 need 1kohm pull-up resistors!
0D95 75A400    1556       mov P2M1, #00H
0D98 75A500    1557       mov P2M2, #00H
0D9B 75B100    1558       mov P3M1, #00H
0D9E 75B200    1559       mov P3M2, #00H
0DA1           1560       
0DA1           1561       ;mov minutes, #0
0DA1 756400    1562            mov seconds, #0
0DA4           1563   
0DA4           1564      ; lcall LCD_4BIT
0DA4           1565       ; For convenience a few handy macros are included in 'LCD_4bit_LPC9351.inc':
0DA4           1566   ;        Set_Cursor(1, 1)
0DA4           1567     ;  Display_BCD(BCD_counter)
0DA4           1568   
0DA4 D203      1569       setb half_seconds_flag
0DA6 D20C      1570       setb my_flag   
0DA8           1571   
0DA8 755800    1572            mov BCD_counter, #0x00
0DAB 754A00    1573            mov pwm , #0
0DAE 754800    1574            mov sec , #0
0DB1 754500    1575            mov state, #0
0DB4 754796    1576            mov temp, #150
0DB7 754205    1577       mov time_soak, #5
0DBA 7543DC    1578       mov temp_refl, #220
0DBD 754105    1579       mov temp_soak, #5
0DC0 756700    1580       mov five_sec_flag,#0
0DC3           1581            ; After initialization the program stays in this 'forever' loop
0DC3           1582   
0DC3 755A00    1583       mov reflow_sec, #0x00
0DC6 755B00    1584       mov reflow_min, #0x00
0DC9 756300    1585       mov minutes, #0x00
0DCC 754600    1586       mov state_lcd, #0
0DCF C208      1587       clr TR1_flag
0DD1 755301    1588       mov reflow_temp+0, #0x01
0DD4 755450    1589       mov reflow_temp+1, #0x50
0DD7 C209      1590       clr tt_reflow_flag
0DD9 755C00    1591       mov soak_sec, #0x00
0DDC 755D00    1592       mov soak_min, #0x00
0DDF           1593   
0DDF 755501    1594       mov soak_temp+0, #0x01
0DE2 755650    1595       mov soak_temp+1, #0x50
0DE5 C20B      1596       clr stop_flag
0DE7           1597   
0DE7 1205F0    1598       lcall Ports_Init
0DEA 12051E    1599       lcall InitSerialPort
0DED 75A400    1600       mov P2M1, #0
0DF0 75A500    1601       mov P2M2, #0
0DF3           1602   
0DF3           1603   
0DF3           1604   
0DF3           1605       
0DF3           1606   forever:         
0DF3 120C1D    1607       lcall FSM_LCD
0DF6           1608   
0DF6 120732    1609       lcall T2S_FSM
0DF9           1610   
0DF9 C2AF      1611       clr EA
0DFB 120CDD    1612       lcall hannah
0DFE D2AF      1613       setb EA
0E00           1614            ; One second has passed, refresh the LCD with new time
0E00           1615   ;        Set_Cursor(1, 1)
0E00           1616   ;    Send_Constant_String(#timee)
0E00           1617   ;    Set_Cursor(1, 5)
0E00           1618   ;    Display_BCD(sec)
0E00           1619   ;    Set_Cursor(2, 1)
0E00           1620   ;    Send_Constant_String(#statee)
0E00           1621    ;   Set_Cursor(2, 5)
0E00           1622     ;  Display_BCD(BCD_counter)
0E00           1623   
0E00           1624       
0E00           1625           
0E00 20A614    1626       jb P2.6, continue19
0E03 C002      1627            push AR2
0E05 7A32      1627            mov R2, #50
0E07 1202D7    1627            lcall ?Wait_Milli_Seconds
0E0A D002      1627            pop AR2 ; debounce
0E0C 20A608    1628            jb P2.6, continue19
0E0F 30A6FD    1629            jnb P2.6, $
0E12 C28E      1630            clr TR1 
0E14 020DF3    1631            ljmp forever
0E17           1632      continue19:
0E17           1633   
0E17           1634   
0E17           1635   
0E17           1636     ;  mov a, five_sec_flag
0E17           1637     ;  cjne a,#5, pass_quack
0E17           1638     ;  quack_like_a_duck:
0E17           1639     ;  clr TR1 ; Stop timer 1.
0E17           1640     ;  mov a,#0
0E17           1641     ;  mov five_sec_flag,a
0E17           1642     ;  clr TR1 ; Stop timer 1.
0E17           1643   ;        setb T2S_FSM_Start ; This plays the current minutes:seconds by making the state machine get out of state zero.
0E17           1644     ;  pass_hash:
0E17           1645     ;  pass_quack:
0E17           1646     ;  setb TR1 ; en timer 1.
0E17           1647       
0E17 C0E0      1648            push acc
0E19 740A      1648            mov a, #10
0E1B 14        1648            dec a
0E1C 120368    1648            lcall ?Set_Cursor_1 ; Select column and row
0E1F D0E0      1648            pop acc
0E21 C000      1649            push ar0
0E23 A83C      1649            mov r0, bcd+0
0E25 12036D    1649            lcall ?Display_BCD
0E28 D000      1649            pop ar0
0E2A           1650   
0E2A E545      1651       mov a, state
0E2C           1652     state0: 
0E2C B40013    1653         cjne a, #0, state1
0E2F 754A00    1654         mov pwm, #0
0E32 C28E      1655         clr TR1
0E34 20B008    1656         jb p3.0, state0_done
0E37 30B0FD    1657         jnb p3.0, $ ;wait for key release
0E3A D28E      1658         setb TR1
0E3C 754501    1659         mov state, #1
0E3F           1660     state0_done:
0E3F 020DF3    1661         ljmp forever
0E42           1662      
0E42           1663      state1:
0E42 B40113    1664         cjne a, #1 , state2
0E45 754A64    1665         mov pwm, #100
0E48 754800    1666         mov sec, #0
0E4B E541      1667         mov a, temp_soak
0E4D C3        1668         clr c
0E4E 9547      1669         subb a, temp
0E50           1670         ;add branches to compare temp with 150
0E50 5003      1671         jnc state1_done
0E52 754502    1672         mov state, #2
0E55           1673     state1_done:
0E55 020DF3    1674          ljmp forever
0E58           1675          
0E58           1676     state2: ;press p3.0 multiple time plz cos it is stuck
0E58 B40210    1677         cjne a, #2 , state3
0E5B 754A14    1678         mov pwm, #20
0E5E E542      1679         mov a, time_soak
0E60 C3        1680         clr c
0E61 9548      1681         subb a, sec
0E63           1682         ;add branches to compare sec with  60
0E63 5003      1683         jnc state2_done
0E65 754503    1684         mov state, #3
0E68           1685     state2_done:
0E68 020DF3    1686          ljmp forever          
0E6B           1687     
0E6B           1688     state3:
0E6B B40313    1689         cjne a, #3 , state4
0E6E 754A50    1690         mov pwm, #80
0E71 754800    1691         mov sec, #0     
0E74 E543      1692         mov a, temp_refl
0E76 C3        1693         clr c
0E77 9547      1694         subb a, temp
0E79           1695         ;add branches to compare temp with 220
0E79 5003      1696         jnc state3_done
0E7B 754504    1697         mov state, #4
0E7E           1698     state3_done:
0E7E 020DF3    1699          ljmp forever
0E81           1700          
0E81           1701      state4:
0E81 B40410    1702         cjne a, #4 , state5
0E84 754A14    1703         mov pwm, #20
0E87 E544      1704         mov a, time_refl
0E89 C3        1705         clr c
0E8A 9548      1706         subb a, sec
0E8C           1707         ;add branches to compare sec with 45
0E8C 5003      1708         jnc state4_done
0E8E 754505    1709         mov state, #5
0E91           1710     state4_done:
0E91 020DF3    1711          ljmp forever    
0E94           1712          
0E94           1713      state5:
0E94 B40595    1714         cjne a, #5 , state0
0E97 754A00    1715         mov pwm, #0
0E9A C3        1716         clr c
0E9B 9547      1717         subb a, temp
0E9D           1718         ;add branches to compare temp with 60
0E9D 5003      1719         jnc state5_done
0E9F 754500    1720         mov state, #0
0EA2           1721     state5_done:
0EA2 020DF3    1722          ljmp forever 
0EA5           1723          
0EA5           1724   
0EA5           1725   EN
