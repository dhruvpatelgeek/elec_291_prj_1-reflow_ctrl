0000              1   ; ISR_example.asm: a) Increments/decrements a BCD variable every half second using
0000              2   ; an ISR for timer 2; b) Generates a 2kHz square wave at pin P3.7 using
0000              3   ; an ISR for timer 0; and c) in the 'main' loop it displays the variable
0000              4   ; incremented/decremented using the ISR for timer 2 on the LCD.  Also resets it to 
0000              5   ; zero if the 'CLEAR' pushbutton connected to P1.7 is pressed.
                  7   $LIST
0000              9   
0000             10   CLK           EQU 7373000  ;NOT CALLING double_clk then?? ; Microcontroller system crystal frequency in Hz
0000             11   TIMER0_RATE   EQU 4096     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0000             12   TIMER0_RELOAD EQU ((65536-(CLK/(2*TIMER0_RATE))))
0000             13   TIMER1_RATE   EQU 100     ; 100Hz, for a timer tick of 10ms
0000             14   TIMER1_RELOAD EQU ((65536-(CLK/(2*TIMER1_RATE))))
0000             15   
0000             16   CLEAR         equ P1.7
0000             17   SOUND_OUT     equ P2.7
0000             18   UPDOWN        equ P2.4
0000             19   
0000             20   CCU_RATE    EQU 11025    ;35000 in sound_fsm ; 22050Hz is the sampling rate of the wav file we are playing
0000             21   CCU_RELOAD  EQU ((65536-((CLK/(2*CCU_RATE)))))
0000             22   ;BAUD        EQU 115200
0000             23   ;BRVAL       EQU ((CLK/BAUD)-16)
0000             24   
0000             25   FLASH_CE    EQU P2.4
0000             26   SOUND       EQU P2.7
0000             27   
0000             28   ; Commands supported by the SPI flash memory according to the datasheet
0000             29   WRITE_ENABLE     EQU 0x06  ; Address:0 Dummy:0 Num:0
0000             30   WRITE_DISABLE    EQU 0x04  ; Address:0 Dummy:0 Num:0
0000             31   READ_STATUS      EQU 0x05  ; Address:0 Dummy:0 Num:1 to infinite
0000             32   READ_BYTES       EQU 0x03  ; Address:3 Dummy:0 Num:1 to infinite
0000             33   READ_SILICON_ID  EQU 0xab  ; Address:0 Dummy:3 Num:1 to infinite
0000             34   FAST_READ        EQU 0x0b  ; Address:3 Dummy:1 Num:1 to infinite
0000             35   WRITE_STATUS     EQU 0x01  ; Address:0 Dummy:0 Num:1
0000             36   WRITE_BYTES      EQU 0x02  ; Address:3 Dummy:0 Num:1 to 256
0000             37   ERASE_ALL        EQU 0xc7  ; Address:0 Dummy:0 Num:0
0000             38   ERASE_BLOCK      EQU 0xd8  ; Address:3 Dummy:0 Num:0
0000             39   READ_DEVICE_ID   EQU 0x9f  ; Address:0 Dummy:2 Num:1 to infinite
0000             40   
0000             41   ; Reset vector
0000             42   org 0x0000
0000 020750      43       ljmp main
0003             44   
0003             45   ; External interrupt 0 vector (not used in this code)
0003             46   org 0x0003
0003 32          47            reti
0004             48   
0004             49   ; Timer/Counter 0 overflow interrupt vector
000B             50   org 0x000B
000B 0203C5      51            ljmp Timer0_ISR
000E             52   
000E             53   ; External interrupt 1 vector (not used in this code)
0013             54   org 0x0013
0013 32          55            reti
0014             56   
0014             57   ; Timer/Counter 1 overflow interrupt vector
001B             58   org 0x001B
001B 0203E1      59            ljmp Timer1_ISR
001E             60   
001E             61   ; Serial port receive/transmit interrupt vector (not used in this code)
0023             62   org 0x0023 
0023 32          63            reti
0024             64   
005B             65   org 0x005b ; CCU interrupt vector.  Used in this code to replay the wave file.
005B 020459      66            ljmp CCU_ISR
005E             67   
005E             68   
005E             69   ;                                                        -                     
005E             70   ;                                                       -  -                    
005E             71   ;                                                      -    -                   
005E             72   ;                              leave it at this temp>>-      -                  
005E             73   ;                                                    -        -                 
005E             74   ;                                                   -          -                 
005E             75   ;                                                  -            -               
005E             76   ;                                                 -              -              
005E             77   ;                                                -                -             
005E             78   ;                                               -                  -            
005E             79   ;                                              -                    -           
005E             80   ;                                             -    reflow>>cool     -          
005E             81   ;               -----------------------------    (temperature only)  -         
005E             82   ;              -     soak (time+temp)                                 -        
005E             83   ;             -                                                        -       
005E             84   ;            -                                                          -       
005E             85   ;          -                                                             -      
005E             86   ;         -                                                               -     
005E             87   ;        -                                                                 -    
005E             88   ;      -                                                                    -    
005E             89   ;     - ramp to soak (temperature)                                           -   
005E             90   ;   -                                                                         -   
005E             91   ;   state 1 ((temp==soak)? ssr_off: ssr_on)
005E             92   ;          state 2 ((time=soak_time)?(pwm_off):(pwn_on)
005E             93   ;                                           state 3 ((temp==soak)? ssr_off: ssr_on)
005E             94   ;                                                        state 4 (cooling ssr_off)
005E             95   ;                                                                             state 5 (done)
005E             96   
005E             97   ; In the 8051 we can define direct access variables starting at location 0x30 up to location 0x7F
0030             98   dseg at 0x30
0030             99   
0030            100   x: ds 4
0034            101   y: ds 4
0038            102   ;Result: ds 2 
0038            103   ch0: ds 2
003A            104   ch1: ds 2
003C            105   oven_temp: ds 2
003E            106   bcd: ds 5
0043            107   
0043            108   Count10ms:    ds 1 ; Used to determine when half second has passed
0044            109   BCD_counter:  ds 1 ; The BCD counter incrememted in the ISR and displayed in the main loop
0045            110   temp_soak: ds 1 ; temp to soak
0046            111   time_soak: ds 1 ; time to soak
0047            112   temp_refl: ds 1 ; temp of relfow
0048            113   time_refl: ds 1 ; time to reflow 
0049            114   state: ds 1 ; current state 
004A            115   temp: ds 1 ; current temp in degree C
004B            116   sec: ds 1 ; current time in seconds 
004C            117   product: ds 1; pwm-currsec
004D            118   pwm: ds 1 ; 
004E            119   
004E            120   ;;; timer
004E            121   w:             ds 3 ; 24-bit play counter.  Decremented in CCU ISR.
0051            122   minutes:       ds 1
0052            123   seconds:       ds 1
0053            124   T2S_FSM_state: ds 1
0054            125   Count5ms:      ds 1
0055            126   five_sec_flag:  ds 1
0056            127   
0000            128   BSEG
0000            129   T2S_FSM_start: dbit 1
0001            130   seconds_flag:  dbit 1
0002            131   mf: dbit 1
0003            132   
0003            133   ;_ _ _ _ | _ _ _ _ _ _
0003            134   ;
0003            135   ;pwm = 40 (say)
0003            136   ;then output will be 100 
0003            137   ;_________
0003            138   ;         |
0003            139   ;         |_____________
0003            140   ; where period is 1 second 
0003            141   ; In the 8051 we have variables that are 1-bit in size.  We can use the setb, clr, jb, and jnb
0003            142   ; instructions with these variables.  This is how you define a 1-bit variable:
0003            143   bseg
0003            144   half_seconds_flag: dbit 1 ; Set to one in the ISR every time 500 ms had passed
0004            145   
005E            146   cseg
005E            147   ;definitions for clk, baud rate, etc.
005E            148   XTAL EQU (14746000/2) 
005E            149   BAUD EQU 115200
005E            150   BRVAL EQU ((XTAL/BAUD)-16)
005E            151   OP_AMP_GAIN EQU 340 ;what is the exact gain?
005E            152   
005E            153   ;define the connections between the ADC and MCU (P89 & MCP3008)
005E            154   CE_ADC    EQU  P2.7
005E            155   MY_MOSI   EQU  P2.6
005E            156   MY_MISO   EQU  P2.5
005E            157   MY_SCLK   EQU  P2.4
005E            158   
005E            159   ; These 'equ' must match the wiring between the microcontroller and the LCD!
005E            160   LCD_RS equ P0.5
005E            161   LCD_RW equ P0.6
005E            162   LCD_E  equ P0.7
005E            163   LCD_D4 equ P1.2
005E            164   LCD_D5 equ P1.3
005E            165   LCD_D6 equ P1.4
005E            166   LCD_D7 equ P1.6
005E            167   
                546   $LIST
                169   $LIST 
02CE            171   
                173   	$LIST
03A1            175   
03A1            176   
03A1            177   ;                     1234567890123456    <- This helps determine the location of the counter
03A1 4243445F   178   Initial_Message:  db 'BCD_counter: xx ', 0
     636F756E
     7465723A
     20787820
     00
03B2            179   
03B2            180   ;---------------------------------;
03B2            181   ; Routine to initialize the ISR   ;
03B2            182   ; for timer 0                     ;
03B2            183   ;---------------------------------;
03B2            184   Timer0_Init:
03B2 E589       185            mov a, TMOD
03B4 54F0       186            anl a, #0xf0 ; Clear the bits for timer 0
03B6 4401       187            orl a, #0x01 ; Configure timer 0 as 16-timer
03B8 F589       188            mov TMOD, a
03BA 758CFC     189            mov TH0, #high(TIMER0_RELOAD)
03BD 758A7C     190            mov TL0, #low(TIMER0_RELOAD)
03C0            191            ; Enable the timer and interrupts
03C0 D2A9       192       setb ET0  ; Enable timer 0 interrupt
03C2 D28C       193       setb TR0  ; Start timer 0
03C4 22         194            ret
03C5            195   
03C5            196   ;---------------------------------;
03C5            197   ; ISR for timer 0.  Set to execute;
03C5            198   ; every 1/4096Hz to generate a    ;
03C5            199   ; 2048 Hz square wave at pin P3.7 ;
03C5            200   ;---------------------------------;
03C5            201   Timer0_ISR:
03C5 758CFC     202            mov TH0, #high(TIMER0_RELOAD)
03C8 758A7C     203            mov TL0, #low(TIMER0_RELOAD)
03CB B2A7       204            cpl SOUND_OUT ; Connect speaker to this pin
03CD 32         205            reti
03CE            206   
03CE            207   ;---------------------------------;
03CE            208   ; Routine to initialize the ISR   ;
03CE            209   ; for timer 1                     ;
03CE            210   ;---------------------------------;
03CE            211   Timer1_Init:
03CE E589       212            mov a, TMOD
03D0 540F       213            anl a, #0x0f ; Clear the bits for timer 1
03D2 4410       214            orl a, #0x10 ; Configure timer 1 as 16-timer
03D4 F589       215            mov TMOD, a
03D6 758D6F     216            mov TH1, #high(TIMER1_RELOAD)
03D9 758BFF     217            mov TL1, #low(TIMER1_RELOAD)
03DC            218            ; Enable the timer and interrupts
03DC D2AB       219       setb ET1  ; Enable timer 1 interrupt
03DE D28E       220       setb TR1  ; Start timer 1
03E0 22         221            ret
03E1            222   
03E1            223   ;---------------------------------;
03E1            224   ; ISR for timer 1                 ;
03E1            225   ;---------------------------------;
03E1            226   Timer1_ISR:
03E1 758D6F     227            mov TH1, #high(TIMER1_RELOAD)
03E4 758BFF     228            mov TL1, #low(TIMER1_RELOAD)
03E7 B2A6       229            cpl P2.6 ; To check the interrupt rate with oscilloscope. It must be precisely a 10 ms pulse.
03E9            230            
03E9            231            ; The two registers used in the ISR must be saved in the stack
03E9 C0E0       232            push acc
03EB C0D0       233            push psw
03ED            234            
03ED            235            ; Increment the 8-bit 10-mili-second counter
03ED 0543       236            inc Count10ms
03EF            237   
03EF            238   Inc_Done:
03EF E543       239            mov a, Count10ms
03F1 954D       240            subb a, pwm ; if pwm greater than a pwm is on else off
03F3 D4         241            da a
03F4 E54C       242            mov a, product
03F6 5005       243       jnc off_segment
03F8 D281       244       setb p0.1
03FA C3         245       clr c
03FB 8005       246       sjmp pass
03FD            247       off_segment:
03FD C281       248       clr p0.1
03FF C3         249       clr c
0400 8000       250       sjmp pass
0402            251   
0402            252       ; Check if 1 second has passed
0402            253       pass:
0402            254   
0402            255            ; Check if half second has passed ;THIS COUNTS 2s. WHY?
0402 E543       256            mov a, Count10ms
0404 B4C82B     257            cjne a, #200, Timer1_ISR_done ;SHOULDNT THIS BE: cjne a, #100, Timer1_ISR_done; Warning: this instruction changes the carry flag!
0407            258            ;----------------------------
0407 054B       259            inc sec ; one second has passed
0409 E54B       260       mov a,sec
040B D4         261       da a
040C F54B       262       mov sec,a
040E            263   
040E 0555       264       inc five_sec_flag ; one second has passed ;THIS SHOULD BE FOR 5s THOUGH
0410 E555       265       mov a,five_sec_flag
0412 D4         266       da a
0413 F555       267       mov five_sec_flag,a
0415            268   
0415 E54B       269       mov a,sec
0417 755100     270       mov minutes, #0
041A 85E052     271       mov seconds, acc
041D            272   
041D            273       
041D            274       ;----------------------------
041D            275            ; 500 milliseconds have passed.  Set a flag so the main program knows
041D D203       276            setb half_seconds_flag ; Let the main program know half second had passed
041F B28C       277            cpl TR0 ; Enable/disable timer/counter 0. This line creates a beep-silence-beep-silence sound.
0421            278            ; Reset to zero the 10-milli-seconds counter, it is a 8-bit variable
0421 754300     279            mov Count10ms, #0x0
0424            280            ; Increment the BCD counter
0424 E544       281            mov a, BCD_counter
0426 30A404     282            jnb UPDOWN, Timer1_ISR_decrement
0429 2401       283            add a, #0x01
042B 8002       284            sjmp Timer1_ISR_da
042D            285   Timer1_ISR_decrement:
042D 2499       286            add a, #0x99 ; Adding the 10-complement of -1 is like subtracting 1.
042F            287   Timer1_ISR_da:
042F D4         288            da a ; Decimal adjust instruction.  Check datasheet for more details!
0430 F544       289            mov BCD_counter, a
0432            290            
0432            291   Timer1_ISR_done:
0432 D0D0       292            pop psw
0434 D0E0       293            pop acc
0436 32         294            reti
0437            295   
0437            296   
0437            297   
0437 74696D65   298   timee:  db 'time', 0
     00
043C 73746174   299   statee:  db 'state', 0
     6500
0442            300   
0442            301   
0442            302   ;------------------------------
0442            303   ;---------------------------------;
0442            304   ; Routine to initialize the CCU.  ;
0442            305   ; We are using the CCU timer in a ;
0442            306   ; manner similar to the timer 2   ;
0442            307   ; available in other 8051s        ;
0442            308   ;---------------------------------;
0442            309   CCU_Init:
0442 75CDFE     310            mov TH2, #high(CCU_RELOAD)
0445 75CCB2     311            mov TL2, #low(CCU_RELOAD)
0448 75CFFE     312            mov TOR2H, #high(CCU_RELOAD)
044B 75CEB2     313            mov TOR2L, #low(CCU_RELOAD)
044E 75F980     314            mov TCR21, #10000000b ; Latch the reload value
0451 75C980     315            mov TICR2, #10000000b ; Enable CCU Timer Overflow Interrupt
0454 D2EC       316            setb ECCU ; Enable CCU interrupt
0456 D2C8       317            setb TMOD20 ; Start CCU timer
0458 22         318            ret
0459            319   
0459            320   ;---------------------------------;
0459            321   ; ISR for CCU.  Used to playback  ;
0459            322   ; the WAV file stored in the SPI  ;
0459            323   ; flash memory.                   ;
0459            324   ;---------------------------------;
0459            325   CCU_ISR:
0459 75E900     326            mov TIFR2, #0 ; Clear CCU Timer Overflow Interrupt Flag bit. Actually, it clears all the bits!
045C            327            
045C            328            ; The registers used in the ISR must be saved in the stack
045C C0E0       329            push acc
045E C0D0       330            push psw
0460            331            
0460            332            ; Check if the play counter is zero.  If so, stop playing sound.
0460 E54E       333            mov a, w+0
0462 454F       334            orl a, w+1
0464 4550       335            orl a, w+2
0466 6015       336            jz stop_playing
0468            337            
0468            338            ; Decrement play counter 'w'.  In this implementation 'w' is a 24-bit counter.
0468 74FF       339            mov a, #0xff
046A 154E       340            dec w+0
046C B54E07     341            cjne a, w+0, keep_playing
046F 154F       342            dec w+1
0471 B54F02     343            cjne a, w+1, keep_playing
0474 1550       344            dec w+2
0476            345            
0476            346   keep_playing:
0476            347   
0476 120557     348            lcall Send_SPI ; Read the next byte from the SPI Flash...
0479 F5F5       349            mov AD1DAT3, a ; and send it to the DAC
047B            350            
047B 8006       351            sjmp CCU_ISR_Done
047D            352   
047D            353   stop_playing:
047D C2C8       354            clr TMOD20 ; Stop CCU timer
047F D2A4       355            setb FLASH_CE  ; Disable SPI Flash
0481 C2A7       356            clr SOUND ; Turn speaker off
0483            357   
0483            358   CCU_ISR_Done:    
0483 D0D0       359            pop psw
0485 D0E0       360            pop acc
0487 32         361            reti
0488            362   
0488            363   ;---------------------------------;
0488            364   ; Initial configuration of ports. ;
0488            365   ; After reset the default for the ;
0488            366   ; pins is 'Open Drain'.  This     ;
0488            367   ; routine changes them pins to    ;
0488            368   ; Quasi-bidirectional like in the ;
0488            369   ; original 8051.                  ;
0488            370   ; Notice that P1.2 and P1.3 are   ;
0488            371   ; always 'Open Drain'. If those   ;
0488            372   ; pins are to be used as output   ;
0488            373   ; they need a pull-up resistor.   ;
0488            374   ;---------------------------------;
0488            375   Ports_Init:
0488            376       ; Configure all the ports in bidirectional mode:
0488 758400     377       mov P0M1, #00H
048B 758500     378       mov P0M2, #00H
048E 759100     379       mov P1M1, #00H
0491 759200     380       mov P1M2, #00H ; WARNING: P1.2 and P1.3 need 1 kohm pull-up resistors if used as outputs!
0494 75A400     381       mov P2M1, #00H
0497 75A500     382       mov P2M2, #00H
049A 75B100     383       mov P3M1, #00H
049D 75B200     384       mov P3M2, #00H
04A0 22         385            ret
04A1            386   
04A1            387   ;cseg
04A1            388   ;INITIALIZE AND CONFIGURE THE SERIAL PORT OF THE P89
04A1            389   InitSerialPort:
04A1            390            ;DEBOUNCING??
04A1            391            ; Since the reset button bounces, we need to wait a bit before
04A1            392       ; sending messages, otherwise we risk displaying gibberish!
04A1            393       ;mov R1, #222
04A1            394       ;mov R0, #166
04A1            395       ;djnz R0, $   ; 3 cycles->3*45.21123ns*166=22.51519us
04A1            396       ;djnz R1, $-4 ; 22.51519us*222=4.998ms
04A1            397       ; Now we can proceed with the configuration
04A1            398            
04A1 75BD00     399            mov     BRGCON,#0x00
04A4 75BF00     400            mov     BRGR1,#high(BRVAL)
04A7 75BE30     401            mov     BRGR0,#low(BRVAL)
04AA 75BD03     402            mov     BRGCON,#0x03 ; Turn-on the baud rate generator
04AD 759852     403            mov     SCON,#0x52 ; Serial port in mode 1, ren, txrdy, rxempty
04B0 759100     404            mov     P1M1,#0x00 ; Enable pins RxD and TXD
04B3 759200     405            mov     P1M2,#0x00 ; Enable pins RxD and TXD
04B6 22         406            ret
04B7            407   
04B7            408   INIT_SPI_hb:     
04B7 D2A5       409            setb MY_MISO    ; Make MISO an input pin     
04B9 C2A4       410            clr MY_SCLK     ; For mode (0,0) SCLK is zero     
04BB 22         411            ret
04BC            412   ;bit-bang SPI
04BC            413   DO_SPI_G:     
04BC C0E0       414            push acc     
04BE 7900       415            mov R1, #0      ; Received byte stored in R1     
04C0 7A08       416            mov R2, #8      ; Loop counter (8-bits)
04C2            417   DO_SPI_G_LOOP:     
04C2 E8         418            mov a, R0       ; Byte to write is in R0     
04C3 33         419            rlc a           ; Carry flag has bit to write     
04C4 F8         420            mov R0, a     
04C5 92A6       421            mov MY_MOSI, c 
04C7 D2A4       422            setb MY_SCLK    ; Transmit     
04C9 A2A5       423            mov c, MY_MISO  ; Read received bit     
04CB E9         424            mov a, R1       ; Save received bit in R1    
04CC 33         425            rlc a 
04CD F9         426            mov R1, a     
04CE C2A4       427            clr MY_SCLK     
04D0 DAF0       428            djnz R2, DO_SPI_G_LOOP     
04D2 D0E0       429            pop acc     
04D4 22         430            ret 
04D5            431   
04D5            432   
04D5            433   
04D5            434   
04D5            435            
04D5            436   getchar:
04D5 109802     437            jbc     RI,getchar_L1
04D8 80FB       438            sjmp getchar
04DA            439   getchar_L1:
04DA E599       440            mov     a,SBUF
04DC 22         441            ret     
04DD            442       
04DD            443   ;approximate delay of 1s
04DD            444   Delay:
04DD 7A14       445       mov R2, #20
04DF 79FA       446   L4: mov R1, #250
04E1 78A6       447   L5: mov R0, #166
04E3 D8FE       448   L6: djnz R0, L6 ; 3 cycles->3*45.21123ns*166=22.51519us
04E5 D9FA       449       djnz R1, L5 ; 22.51519us*250=5.629ms
04E7 DAF6       450       djnz R2, L4 ; 5.629ms*89=0.5s (approximately)
04E9 22         451       ret
04EA            452       
04EA 30313233   453   HexAscii: db '0123456789ABCDEF'
     34353637
     38394142
     43444546
04FA            454   
04FA            455   SendString:
04FA E4         456       clr a
04FB 93         457       movc a, @a+dptr
04FC 6006       458       jz SendString_L1
04FE 120399     459       lcall putchar
0501 A3         460       inc dptr
0502 80F6       461       sjmp SendString  
0504            462   SendString_L1:
0504 22         463            ret
0505            464       
0505            465   new_line:
0505 0D0A00     466         DB '\r' ,'\n', 0     
0508            467       
0508            468   Display_putty:
0508 C000       469            push ar0
050A A842       469            mov r0, bcd+4
050C 120383     469            lcall ?Send_BCD
050F D000       469            pop ar0
0511 C000       470            push ar0
0513 A841       470            mov r0, bcd+3
0515 120383     470            lcall ?Send_BCD
0518 D000       470            pop ar0
051A C000       471            push ar0
051C A840       471            mov r0, bcd+2
051E 120383     471            lcall ?Send_BCD
0521 D000       471            pop ar0
0523 C000       472            push ar0
0525 A83F       472            mov r0, bcd+1
0527 120383     472            lcall ?Send_BCD
052A D000       472            pop ar0
052C C000       473            push ar0
052E A83E       473            mov r0, bcd+0
0530 120383     473            lcall ?Send_BCD
0533 D000       473            pop ar0
0535 22         474            ret   
0536            475   ;---------------------------------;
0536            476   ; Initialize ADC1/DAC1 as DAC1.   ;
0536            477   ; Warning, the ADC1/DAC1 can work ;
0536            478   ; only as ADC or DAC, not both.   ;
0536            479   ; The P89LPC9351 has two ADC/DAC  ;
0536            480   ; interfaces.  One can be used as ;
0536            481   ; ADC and the other can be used   ;
0536            482   ; as DAC.  Also configures the    ;
0536            483   ; pin associated with the DAC, in ;
0536            484   ; this case P0.4 as 'Open Drain'. ;
0536            485   ;---------------------------------;
0536            486   InitDAC1:
0536            487       ; Configure pin P0.4 (DAC1 output pin) as open drain
0536 438410     488            orl     P0M1,   #00010000B
0539 438510     489            orl     P0M2,   #00010000B
053C 75A128     490       mov ADMODB, #00101000B ; Select main clock/2 for ADC/DAC.  Also enable DAC1 output (Table 25 of reference manual)
053F 759704     491            mov     ADCON1, #00000100B ; Enable the converter
0542 75F580     492            mov AD1DAT3, #0x80     ; Start value is 3.3V/2 (zero reference for AC WAV file)
0545 22         493            ret
0546            494   
0546            495   ;---------------------------------;
0546            496   ; Change the internal RC osc. clk ;
0546            497   ; from 7.373MHz to 14.746MHz.     ;
0546            498   ;---------------------------------;
0546            499   Double_Clk:
0546            500       ;mov dptr, #CLKCON
0546            501       ;movx a, @dptr
0546            502       ;orl a, #00001000B ; double the clock speed to 14.746MHz
0546            503       ;movx @dptr,a
0546 22         504            ret
0547            505   
0547            506   ;---------------------------------;
0547            507   ; Initialize the SPI interface    ;
0547            508   ; and the pins associated to SPI. ;
0547            509   ;---------------------------------;
0547            510   Init_SPI:
0547            511            ; Configure MOSI (P2.2), CS* (P2.4), and SPICLK (P2.5) as push-pull outputs (see table 42, page 51)
0547 53A4CB     512            anl P2M1, #low(not(00110100B))
054A 43A534     513            orl P2M2, #00110100B
054D            514            ; Configure MISO (P2.3) as input (see table 42, page 51)
054D 43A408     515            orl P2M1, #00001000B
0550 53A5F7     516            anl P2M2, #low(not(00001000B)) 
0553            517            ; Configure SPI
0553 75E2D0     518            mov SPCTL, #11010000B ; Ignore /SS, Enable SPI, DORD=0, Master=1, CPOL=0, CPHA=0, clk/4
0556 22         519            ret
0557            520   
0557            521   ;---------------------------------;
0557            522   ; Sends AND receives a byte via   ;
0557            523   ; SPI.                            ;
0557            524   ;---------------------------------;
0557            525   Send_SPI:
0557 F5E3       526            mov SPDAT, a
0559            527   Send_SPI_1:
0559 E5E1       528            mov a, SPSTAT 
055B 30E7FB     529            jnb acc.7, Send_SPI_1 ; Check SPI Transfer Completion Flag
055E F5E1       530            mov SPSTAT, a ; Clear SPI Transfer Completion Flag
0560 E5E3       531            mov a, SPDAT ; return received byte via accumulator
0562 22         532            ret
0563            533   
0563            534   ;---------------------------------;
0563            535   ; SPI flash 'write enable'        ;
0563            536   ; instruction.                    ;
0563            537   ;---------------------------------;
0563            538   Enable_Write:
0563 C2A4       539            clr FLASH_CE
0565 7406       540            mov a, #WRITE_ENABLE
0567 120557     541            lcall Send_SPI
056A D2A4       542            setb FLASH_CE
056C 22         543            ret
056D            544   
056D            545   ;---------------------------------;
056D            546   ; This function checks the 'write ;
056D            547   ; in progress' bit of the SPI     ;
056D            548   ; flash memory.                   ;
056D            549   ;---------------------------------;
056D            550   Check_WIP:
056D C2A4       551            clr FLASH_CE
056F 7405       552            mov a, #READ_STATUS
0571 120557     553            lcall Send_SPI
0574 7455       554            mov a, #0x55
0576 120557     555            lcall Send_SPI
0579 D2A4       556            setb FLASH_CE
057B 20E0EF     557            jb acc.0, Check_WIP ;  Check the Write in Progress bit
057E 22         558            ret
057F            559            
057F            560   ; Display a binary number in the LCD (must be less than 99).  Number to display passed in accumulator.
057F            561   LCD_number:
057F C0E0       562            push acc
0581 75F00A     563            mov b, #10
0584 84         564            div ab
0585 4430       565            orl a, #'0'
0587 12031C     566            lcall ?WriteData
058A E5F0       567            mov a, b
058C 4430       568            orl a, #'0'
058E 12031C     569            lcall ?WriteData
0591 D0E0       570            pop acc
0593 22         571            ret
0594            572            
0594            573   ; Sounds we need in the SPI flash: 0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 30; 40; 50; minutes; seconds;
0594            574   ; Approximate index of sounds in file 'stop_watch.wav'
0594            575   ; This was generated using: computer_sender -Asw_index.asm -S2000 stop_watch.wav
0594            576   sound_index:
0594 00002D     577       db 0x00, 0x00, 0x2d ; 0 
0597 003107     578       db 0x00, 0x31, 0x07 ; 1 
059A 007007     579       db 0x00, 0x70, 0x07 ; 2 
059D 00ADB9     580       db 0x00, 0xad, 0xb9 ; 3 
05A0 00F266     581       db 0x00, 0xf2, 0x66 ; 4 
05A3 0135D5     582       db 0x01, 0x35, 0xd5 ; 5 
05A6 017D33     583       db 0x01, 0x7d, 0x33 ; 6 
05A9 01C761     584       db 0x01, 0xc7, 0x61 ; 7 
05AC 021279     585       db 0x02, 0x12, 0x79 ; 8 
05AF 0249C1     586       db 0x02, 0x49, 0xc1 ; 9 
05B2 028F7A     587       db 0x02, 0x8f, 0x7a ; 10 
05B5 02D063     588       db 0x02, 0xd0, 0x63 ; 11 
05B8 031B87     589       db 0x03, 0x1b, 0x87 ; 12 
05BB 03630E     590       db 0x03, 0x63, 0x0e ; 13 
05BE 03B95F     591       db 0x03, 0xb9, 0x5f ; 14 
05C1 04113A     592       db 0x04, 0x11, 0x3a ; 15 
05C4 0466C4     593       db 0x04, 0x66, 0xc4 ; 16 
05C7 04C012     594       db 0x04, 0xc0, 0x12 ; 17 
05CA 052698     595       db 0x05, 0x26, 0x98 ; 18 
05CD 0574E9     596       db 0x05, 0x74, 0xe9 ; 19 
05D0 05D28E     597       db 0x05, 0xd2, 0x8e ; 20 
05D3 061D83     598       db 0x06, 0x1d, 0x83 ; 21 -> 30 
05D6 066342     599       db 0x06, 0x63, 0x42 ; 22 -> 40 
05D9 06AAB9     600       db 0x06, 0xaa, 0xb9 ; 23 -> 50 
05DC 06F3D6     601       db 0x06, 0xf3, 0xd6 ; 24 -> Minutes 
05DF 073F02     602       db 0x07, 0x3f, 0x02 ; 25 -> Seconds 
05E2            603   
05E2            604   ; Size of each sound in 'sound_index'
05E2            605   ; Generated using: computer_sender -Asw_index.asm -S2000 stop_watch.wav
05E2            606   Size_Length:
05E2 0030DA     607       db 0x00, 0x30, 0xda ; 0 
05E5 003F00     608       db 0x00, 0x3f, 0x00 ; 1 
05E8 003DB2     609       db 0x00, 0x3d, 0xb2 ; 2 
05EB 0044AD     610       db 0x00, 0x44, 0xad ; 3 
05EE 00436F     611       db 0x00, 0x43, 0x6f ; 4 
05F1 00475E     612       db 0x00, 0x47, 0x5e ; 5 
05F4 004A2E     613       db 0x00, 0x4a, 0x2e ; 6 
05F7 004B18     614       db 0x00, 0x4b, 0x18 ; 7 
05FA 003748     615       db 0x00, 0x37, 0x48 ; 8 
05FD 0045B9     616       db 0x00, 0x45, 0xb9 ; 9 
0600 0040E9     617       db 0x00, 0x40, 0xe9 ; 10 
0603 004B24     618       db 0x00, 0x4b, 0x24 ; 11 
0606 004787     619       db 0x00, 0x47, 0x87 ; 12 
0609 005651     620       db 0x00, 0x56, 0x51 ; 13 
060C 0057DB     621       db 0x00, 0x57, 0xdb ; 14 
060F 00558A     622       db 0x00, 0x55, 0x8a ; 15 
0612 00594E     623       db 0x00, 0x59, 0x4e ; 16 
0615 006686     624       db 0x00, 0x66, 0x86 ; 17 
0618 004E51     625       db 0x00, 0x4e, 0x51 ; 18 
061B 005DA5     626       db 0x00, 0x5d, 0xa5 ; 19 
061E 004AF5     627       db 0x00, 0x4a, 0xf5 ; 20 
0621 0045BF     628       db 0x00, 0x45, 0xbf ; 21 -> 30
0624 004777     629       db 0x00, 0x47, 0x77 ; 22 -> 40
0627 00491D     630       db 0x00, 0x49, 0x1d ; 23 -> 50
062A 004B2C     631       db 0x00, 0x4b, 0x2c ; 24 -> minutes
062D 005C87     632       db 0x00, 0x5c, 0x87 ; 25 -> seconds
0630            633   
0630            634   ; The sound and its length from the two tables above is passed in the accumulator.
0630            635   Play_Sound_Using_Index:
0630 D2A7       636            setb SOUND ; Turn speaker on
0632 C2C8       637            clr TMOD20 ; Stop the CCU from playing previous request
0634 D2A4       638            setb FLASH_CE
0636            639            
0636            640            ; There are three bytes per row in our tables, so multiply index by three
0636 75F003     641            mov b, #3
0639 A4         642            mul ab
063A F8         643            mov R0, a ; Make a copy of the index*3
063B            644            
063B C2A4       645            clr FLASH_CE ; Enable SPI Flash
063D 7403       646            mov a, #READ_BYTES
063F 120557     647            lcall Send_SPI
0642            648            ; Set the initial position in memory of where to start playing
0642 900594     649            mov dptr, #sound_index
0645 E8         650            mov a, R0
0646 93         651            movc a, @a+dptr
0647 120557     652            lcall Send_SPI
064A A3         653            inc dptr
064B E8         654            mov a, R0
064C 93         655            movc a, @a+dptr
064D 120557     656            lcall Send_SPI
0650 A3         657            inc dptr
0651 E8         658            mov a, R0
0652 93         659            movc a, @a+dptr
0653 120557     660            lcall Send_SPI
0656            661            ; Now set how many bytes to play
0656 9005E2     662            mov dptr, #Size_Length
0659 E8         663            mov a, R0
065A 93         664            movc a, @a+dptr
065B F550       665            mov w+2, a
065D A3         666            inc dptr
065E E8         667            mov a, R0
065F 93         668            movc a, @a+dptr
0660 F54F       669            mov w+1, a
0662 A3         670            inc dptr
0663 E8         671            mov a, R0
0664 93         672            movc a, @a+dptr
0665 F54E       673            mov w+0, a
0667            674            
0667 7400       675            mov a, #0x00 ; Request first byte to send to DAC
0669 120557     676            lcall Send_SPI
066C            677            
066C D2C8       678            setb TMOD20 ; Start playback by enabling CCU timer
066E            679   
066E 22         680            ret
066F            681   
066F            682   ;---------------------------------------------------------------------------------;
066F            683   ; This is the FSM that plays temperature approx every 5s
066F            684   ; talking_stopwatch.asm was used as a guideline
066F            685   ;---------------------------------------------------------------------------------;
066F            686   T2S_FSM:
066F E553       687            mov a, T2S_FSM_state
0671            688   
0671            689   T2S_FSM_State0: ; Checks for the start signal (T2S_FSM_Start==1; T2S_FSM_Start becomes 1 when the OVEN ON PB is pressed. Use T2S_FSM_Start like a flag)
0671 B40013     690            cjne a, #0, T2S_FSM_State1 ;if the state is not 0 go to state 1
0674 30000F     691            jnb T2S_FSM_Start, T2S_FSM_State0_Done ;T2S_FSM_Start is set when the oven is turned on. In the main program, continually check the oven start PB and when it is pressed, s
0677            692            ;if if are at this point, it means the oven was turned on (pB was pressed)
0677            693            
0677            694            ; Check if temp is larger than 19
0677 C3         695            clr c
0678 E54A       696            mov a, temp
067A 9414       697            subb a, #20
067C 5005       698            jnc temp_gt_19 ;??if when I subtract 20 from minutes, I get a carry it means minutes - 20 is a neg number??
067E            699            ;if there is no carry it means the number is more than 19, otherwise it is less than?
067E 755301     700            mov T2S_FSM_state, #1
0681 8003       701            sjmp T2S_FSM_State0_Done
0683            702   temp_gt_19: ;greater than 19???
0683 755303     703            mov T2S_FSM_state, #3
0686            704   T2S_FSM_State0_Done:
0686 22         705            ret     
0687            706            
0687            707   T2S_FSM_State1: ; Plays temp when temp is less than 20
0687 B40109     708            cjne a, #1, T2S_FSM_State2 ;if the state is not 1 go to state 2
068A E54A       709            mov a, temp
068C 120630     710            lcall Play_Sound_Using_Index
068F 755302     711            mov T2S_FSM_State, #2
0692 22         712            ret
0693            713   
0693            714   T2S_FSM_State2: ; Stay in this state until sound finishes playing
0693 B40207     715            cjne a, #2, T2S_FSM_State3
0696 20C803     716            jb TMOD20, T2S_FSM_State2_Done 
0699 755309     717            mov T2S_FSM_State, #9
069C            718   T2S_FSM_State2_Done:
069C 22         719            ret
069D            720   
069D            721   T2S_FSM_State3: 
069D B40310     722            cjne a, #3, T2S_FSM_State4
06A0            723            
06A0            724            ; Check if minutes is larger than 99
06A0 C3         725            clr c
06A1 E54A       726            mov a, temp
06A3 9464       727            subb a, #100
06A5 5005       728            jnc temp_gt_99 ;??if when I subtract 20 from minutes, I get a carry it means minutes - 20 is a neg number??
06A7 755306     729            mov T2S_FSM_state, #6 ;at this point we know that the number is less than 99
06AA 8003       730            sjmp T2S_FSM_State3_Done
06AC            731   temp_gt_99: ;greater than 99
06AC 755304     732            mov T2S_FSM_state, #4 ;if greater than 99, go to state 4
06AF            733   T2S_FSM_State3_Done:
06AF 22         734            ret     
06B0            735   
06B0            736   T2S_FSM_State4: ; Plays the hundreds when temp is larger than 99, for example for 142 minutes, it plays '1 hundred'
06B0 B4040F     737            cjne a, #4, T2S_FSM_State5
06B3            738            ;if state is 4 it means the temp was greater than 99 and we need to play the hundreds number
06B3 E54A       739            mov a, temp
06B5 75F064     740            mov b, #100
06B8 84         741            div ab ;divide temp by 100
06B9 241B       742            add a, #27 
06BB 120630     743            lcall Play_Sound_Using_Index
06BE 755305     744            mov T2S_FSM_State, #5
06C1 22         745            ret
06C2            746   
06C2            747   T2S_FSM_State5: ; Stay in this state until sound finishes playing
06C2 B40507     748            cjne a, #5, T2S_FSM_State6
06C5 20C803     749            jb TMOD20, T2S_FSM_State5_Done 
06C8 755306     750            mov T2S_FSM_State, #6
06CB            751   T2S_FSM_State5_Done:
06CB 22         752       ret 
06CC            753   
06CC            754   T2S_FSM_State6: ;play the tens of the temperature (ex. "thirty")
06CC B4060F     755            cjne a, #6, T2S_FSM_State7
06CF E54A       756            mov a, temp
06D1 75F00A     757            mov b, #10
06D4 84         758            div ab ;divide by 10 so we can get the tens
06D5 2412       759            add a, #18 
06D7 120630     760            lcall Play_Sound_Using_Index
06DA 755307     761            mov T2S_FSM_State, #7
06DD 22         762            ret
06DE            763   
06DE            764   T2S_FSM_State7: ; Stay in this state until sound finishes playing
06DE B40707     765            cjne a, #7, T2S_FSM_State8
06E1 20C803     766            jb TMOD20, T2S_FSM_State7_Done 
06E4 755308     767            mov T2S_FSM_state, #8
06E7            768   T2S_FSM_State7_Done:
06E7 22         769       ret
06E8            770   
06E8            771   T2S_FSM_State8: ; Plays the units when temp is larger than 19, for example for 42 temp, it plays 'two'
06E8 B40811     772            cjne a, #8, T2S_FSM_State9
06EB E54A       773            mov a, temp
06ED 75F00A     774            mov b, #10
06F0 84         775            div ab
06F1 E5F0       776            mov a, b
06F3 6003       777            jz T2S_FSM_State8_Done ; Prevents from playing something like 'forty zero'
06F5 120630     778            lcall Play_Sound_Using_Index
06F8            779   T2S_FSM_State8_Done:
06F8 755302     780            mov T2S_FSM_State, #2
06FB 22         781            ret
06FC            782   
06FC            783   T2S_FSM_State9: ; Plays the word 'degrees celsius'
06FC B40904     784            cjne a, #9, T2S_FSM_State10
06FF            785            ;@@@@@@@ mov a, DEGREES_C_INDEX ; DEGREES_C_INDEX has the words 'degrees celsius'
06FF            786            ;@@@@@@@ lcall Play_Sound_Using_Index
06FF 75530A     787            mov T2S_FSM_State, #10
0702 22         788            ret
0703            789   
0703            790   T2S_FSM_State10: ; Stay in this state until sound finishes playing
0703 B40A07     791            cjne a, #10, T2S_FSM_Error
0706 20C803     792            jb TMOD20, T2S_FSM_State10_Done 
0709            793            ;clr T2S_FSM_Start ;clear the flag that indicates the oven was turned on ;UPDATE: DON'T WANT TO CLEAR THE OVEN_ON FLAG BECAUSE THE OVEN HASN'T BEEN TURNED OFF YET. MUST ADD AN OFF PB LATER
0709 755300     794            mov T2S_FSM_State, #0 ;go back to state 0
070C            795   T2S_FSM_State10_Done:
070C 22         796            ret     
070D            797   
070D            798   T2S_FSM_Error: ; If we got to this point, there is an error in the finite state machine.  Restart it.
070D C0E0       799            push acc
070F 7401       799            mov a, #1
0711 14         799            dec a
0712 120368     799            lcall ?Set_Cursor_1 ; Select column and row
0715 D0E0       799            pop acc
0717 C083       800            push dph
0719 C082       800            push dpl
071B C0E0       800            push acc
071D 900740     800            mov dptr, #Line_error
0720 12035B     800            lcall ?Send_Constant_String
0723 D0E0       800            pop acc
0725 D082       800            pop dpl
0727 D083       800            pop dph
0729            801            
0729 755300     802            mov T2S_FSM_state, #0
072C C200       803            clr T2S_FSM_Start
072E 22         804            ret
072F            805   ; End of FMS that plays current temp
072F            806   
072F 53746F70   807   Line1: db 'Stop watch', 0
     20776174
     636800
073A 30303A30   808   Line2: db '00:00', 0
     3000
0740 4552524F   809   Line_error: db 'ERROR', 0
     5200
0746 74312069   810   Line_in_t1_isr: db 't1 isr', 0
     737200
074D            811   ;------------------------------
074D            812   relay:
074D 0208A0     813       ljmp next
0750            814   ;---------------------------------;
0750            815   ; Main program. Includes hardware ;
0750            816   ; initialization and 'forever'    ;
0750            817   ; loop.                           ;
0750            818   ;---------------------------------;
0750            819   main:
0750            820            ; Initialization
0750 75817F     821       mov SP, #0x7F
0753 1203B2     822       lcall Timer0_Init
0756 1203CE     823       lcall Timer1_Init
0759 120488     824       lcall Ports_Init ; Default all pins as bidirectional I/O. See Table 42.
075C 1204A1     825       lcall InitSerialPort
075F 75A400     826       mov P2M1, #0
0762 75A500     827       mov P2M2, #0
0765 120326     828       lcall LCD_4BIT
0768 120546     829       lcall Double_Clk ;IF WE ARE DOUBLING THE CLOCK, WE NEED TO CHANGE THE CLK DEFN times 2
076B 120536     830            lcall InitDAC1 ; Call after 'Ports_Init'
076E 120442     831            lcall CCU_Init
0771 120547     832            lcall Init_SPI
0774 1204B7     833       lcall Init_SPI_hb
0777            834            
0777 C28E       835            clr TR1 ; Stop timer 1 ;ADDED
0779 C2C8       836            clr TMOD20 ; Stop CCU timer ;ADDED
077B D2AF       837            setb EA ; Enable global interrupts.
077D            838            
077D C2A7       839            clr SOUND ; Turn speaker off ;ADDED
077F            840   
077F            841            ; Initialize variables
077F C200       842            clr T2S_FSM_Start
0781 755300     843            mov T2S_FSM_state, #0
0784 755200     844            mov seconds, #0
0787            845            
0787 7401       846            mov a, #1 ;ADDED
0789 F555       847            mov five_sec_flag, a ;ADDED
078B            848   
078B            849       ; For convenience a few handy macros are included in 'LCD_4bit_LPC9351.inc':
078B C0E0       850            push acc
078D 7401       850            mov a, #1
078F 14         850            dec a
0790 120368     850            lcall ?Set_Cursor_1 ; Select column and row
0793 D0E0       850            pop acc
0795 C000       851            push ar0
0797 A844       851            mov r0, BCD_counter
0799 12036D     851            lcall ?Display_BCD
079C D000       851            pop ar0
079E            852   
079E D203       853       setb half_seconds_flag
07A0 754400     854            mov BCD_counter, #0x00
07A3 754D00     855            mov pwm , #0
07A6 754B00     856            mov sec , #0
07A9 754900     857            mov state, #0
07AC 754A39     858            mov temp, #57 ;mov temp, #150
07AF 754605     859       mov time_soak, #5
07B2 7547DC     860       mov temp_refl, #220
07B5 755500     861       mov five_sec_flag,#0
07B8            862            ; After initialization the program stays in this 'forever' loop
07B8            863       
07B8            864       ;###FOR THE PURPOSE OF TESTING: SET T2S_FSM_Start TO 1 TO INDICATE OVEN IS ON 
07B8 D200       865            setb T2S_FSM_Start ;OVEN IS on
07BA D28E       866            setb TR1 ; Start timer 1 as soon as oven is on
07BC            867       
07BC            868   forever:         
07BC E555       869       mov a, five_sec_flag
07BE B4018C     870            cjne a, #1, relay ;IF FLAG SET, GO TO FSM TO SPEAK. IF NOT SET, DONT GO TO FSM JUST CONTINUE TO NEXT THING
07C1            871       
07C1            872       
07C1            873       ;before going to FSM, set five_sec_flag to 0
07C1 7400       874       mov a, #0
07C3 F555       875       mov five_sec_flag, a
07C5            876       
07C5            877       ;now go to fsm
07C5 12066F     878       lcall T2S_FSM
07C8            879   
07C8            880   
07C8            881   ;temperatrue
07C8            882            ;read channel 0 of the ADC and transmitting this info to the MCU
07C8 C2A7       883            clr CE_ADC ;enable device (active low)
07CA            884            ;transmit the info from channel 0
07CA 7801       885            mov R0, #00000001B ;start bit:1
07CC 1204BC     886            lcall DO_SPI_G
07CF            887            
07CF 7880       888            mov R0, #10000000B ;read channel 0
07D1 1204BC     889            lcall DO_SPI_G
07D4 E9         890            mov a, R1          ; R1 contains bits 8 and 9 
07D5 5403       891            anl a, #00000011B  ; We need only the two least significant bits
07D7 F539       892            mov ch0+1, a    ; Save result high
07D9            893            
07D9 7855       894            mov R0, #55H   ; It doesn't matter what we transmit... 
07DB 1204BC     895            lcall DO_SPI_G  
07DE 8938       896            mov ch0+0, R1     ; R1 contains bits 0 to 7.  Save result low. 
07E0 D2A7       897            setb CE_ADC ;disable device
07E2            898            
07E2 C2A7       899            clr CE_ADC ;enable device
07E4            900            ;transmit from channel 1
07E4 7801       901            mov R0, #00000001B ;start bit:1
07E6 1204BC     902            lcall DO_SPI_G
07E9            903            
07E9 7890       904            mov R0, #10010000B ;read channel 1
07EB 1204BC     905            lcall DO_SPI_G
07EE E9         906            mov a, R1          ; R1 contains bits 8 and 9 
07EF 5403       907            anl a, #00000011B  ; We need only the two least significant bits
07F1 F53B       908            mov ch1+1, a    ; Save result high
07F3            909            
07F3 7855       910            mov R0, #55H   ; It doesn't matter what we transmit... 
07F5 1204BC     911            lcall DO_SPI_G  
07F8 893A       912            mov ch1+0, R1     ; R1 contains bits 0 to 7.  Save result low. 
07FA D2A7       913            setb CE_ADC ;disable device (active low)
07FC            914            
07FC 1204DD     915            lcall Delay ;about 1s
07FF            916            
07FF            917            ;convert the voltage from ch0(LM335) to temperature and display in putty - ch0 correspond to the cold jnc temp
07FF 853830     918            mov x+0, ch0
0802 853931     919            mov x+1, ch0+1
0805 753200     920            mov x+2, #0
0808 753300     921            mov x+3, #0
080B            922            
080B 75349A     923            mov y+0, #low (410 % 0x10000) 
080E 753501     923            mov y+1, #high(410 % 0x10000) 
0811 753600     923            mov y+2, #low (410 / 0x10000) 
0814 753700     923            mov y+3, #high(410 / 0x10000) 
0817 1201D8     924            lcall mul32
081A 7534FF     925            mov y+0, #low (1023 % 0x10000) 
081D 753503     925            mov y+1, #high(1023 % 0x10000) 
0820 753600     925            mov y+2, #low (1023 / 0x10000) 
0823 753700     925            mov y+3, #high(1023 / 0x10000) 
0826 120265     926            lcall div32
0829 753411     927            mov y+0, #low (273 % 0x10000) 
082C 753501     927            mov y+1, #high(273 % 0x10000) 
082F 753600     927            mov y+2, #low (273 / 0x10000) 
0832 753700     927            mov y+3, #high(273 / 0x10000) 
0835 120144     928            lcall sub32 
0838 12005E     929            lcall hex2bcd
083B 120508     930            lcall Display_putty
083E            931            
083E 740D       932            mov a, #'\r'
0840 120399     933            lcall putchar
0843 740A       934            mov a, #'\n'
0845 120399     935            lcall putchar
0848            936            
0848            937            ;do the same for ch1(output voltage of OP AMP) - ch1 corresponds to the hot jnc temp
0848 853A30     938            mov x+0, ch1
084B 853B31     939            mov x+1, ch1+1
084E 753200     940            mov x+2, #0
0851 753300     941            mov x+3, #0
0854            942            
0854 753464     943            mov y+0, #low (100 % 0x10000) 
0857 753500     943            mov y+1, #high(100 % 0x10000) 
085A 753600     943            mov y+2, #low (100 / 0x10000) 
085D 753700     943            mov y+3, #high(100 / 0x10000) 
0860 1201D8     944            lcall mul32
0863 75345E     945            mov y+0, #low (94 % 0x10000) 
0866 753500     945            mov y+1, #high(94 % 0x10000) 
0869 753600     945            mov y+2, #low (94 / 0x10000) 
086C 753700     945            mov y+3, #high(94 / 0x10000) 
086F 120123     946            lcall add32
0872 75345C     947            mov y+0, #low (348 % 0x10000) 
0875 753501     947            mov y+1, #high(348 % 0x10000) 
0878 753600     947            mov y+2, #low (348 / 0x10000) 
087B 753700     947            mov y+3, #high(348 / 0x10000) 
087E 120265     948            lcall div32 
0881 75341E     949            mov y+0, #low (30 % 0x10000) 
0884 753500     949            mov y+1, #high(30 % 0x10000) 
0887 753600     949            mov y+2, #low (30 / 0x10000) 
088A 753700     949            mov y+3, #high(30 / 0x10000) 
088D 120123     950            lcall add32
0890            951   
0890 12005E     952            lcall hex2bcd
0893 120508     953            lcall Display_putty
0896            954            
0896 740D       955            mov a, #'\r'
0898 120399     956            lcall putchar
089B 740A       957            mov a, #'\n'
089D 120399     958            lcall putchar
08A0            959            
08A0            960            ;now that we have the cold and hot junction temps in variables ch0 and ch1 respectively, we can add them to get the actual temperature
08A0            961            
08A0            962            
08A0            963            
08A0            964   
08A0            965   next:    
08A0            966            ; One second has passed, refresh the LCD with new time
08A0 C0E0       967            push acc
08A2 7401       967            mov a, #1
08A4 14         967            dec a
08A5 120368     967            lcall ?Set_Cursor_1 ; Select column and row
08A8 D0E0       967            pop acc
08AA C083       968            push dph
08AC C082       968            push dpl
08AE C0E0       968            push acc
08B0 900437     968            mov dptr, #timee
08B3 12035B     968            lcall ?Send_Constant_String
08B6 D0E0       968            pop acc
08B8 D082       968            pop dpl
08BA D083       968            pop dph
08BC C0E0       969            push acc
08BE 7405       969            mov a, #5
08C0 14         969            dec a
08C1 120368     969            lcall ?Set_Cursor_1 ; Select column and row
08C4 D0E0       969            pop acc
08C6 C000       970            push ar0
08C8 A84B       970            mov r0, sec
08CA 12036D     970            lcall ?Display_BCD
08CD D000       970            pop ar0
08CF C0E0       971            push acc
08D1 7401       971            mov a, #1
08D3 14         971            dec a
08D4 120366     971            lcall ?Set_Cursor_2 ; Select column and row
08D7 D0E0       971            pop acc
08D9 C083       972            push dph
08DB C082       972            push dpl
08DD C0E0       972            push acc
08DF 90043C     972            mov dptr, #statee
08E2 12035B     972            lcall ?Send_Constant_String
08E5 D0E0       972            pop acc
08E7 D082       972            pop dpl
08E9 D083       972            pop dph
08EB C0E0       973            push acc
08ED 7405       973            mov a, #5
08EF 14         973            dec a
08F0 120366     973            lcall ?Set_Cursor_2 ; Select column and row
08F3 D0E0       973            pop acc
08F5 C000       974            push ar0
08F7 A849       974            mov r0, state
08F9 12036D     974            lcall ?Display_BCD
08FC D000       974            pop ar0
08FE            975   
08FE            976   
08FE            977       ;mov a, five_sec_flag
08FE            978       ;cjne a,#5, pass_quack
08FE            979       ;quack_like_a_duck:
08FE            980       ;clr TR1 ; Stop timer 1.
08FE            981       ;mov a,#0
08FE            982       ;mov five_sec_flag,a
08FE            983       ;clr TR1 ; Stop timer 1.
08FE            984            ;setb T2S_FSM_Start ; This plays the current minutes:seconds by making the state machine get out of state zero.
08FE            985       ;pass_hash:
08FE            986       ;pass_quack:
08FE            987       ;setb TR1 ; en timer 1.
08FE            988       
08FE E549       989       mov a, state
0900            990     state0: 
0900 B4000F     991         cjne a, #0, state1
0903 754D00     992         mov pwm, #0
0906 20A006     993         jb p2.0, state0_done
0909 30A0FD     994         jnb p2.0, $ ;wait for key release
090C 754901     995         mov state, #1
090F            996     state0_done:
090F 0207BC     997         ljmp forever
0912            998      
0912            999      state1:
0912 B40113    1000         cjne a, #1 , state2
0915 754D64    1001         mov pwm, #100
0918 754B00    1002         mov sec, #0
091B E545      1003         mov a, temp_soak
091D C3        1004         clr c
091E 954A      1005         subb a, temp
0920           1006         ;add branches to compare temp with 150
0920 5003      1007         jnc state1_done
0922 754902    1008         mov state, #2
0925           1009     state1_done:
0925 0207BC    1010          ljmp forever
0928           1011          
0928           1012     state2:
0928 B40210    1013         cjne a, #2 , state3
092B 754D14    1014         mov pwm, #20
092E E546      1015         mov a, time_soak
0930 C3        1016         clr c
0931 954B      1017         subb a, sec
0933           1018         ;add branches to compare sec with  60
0933 5003      1019         jnc state2_done
0935 754903    1020         mov state, #3
0938           1021     state2_done:
0938 0207BC    1022          ljmp forever          
093B           1023     
093B           1024     state3:
093B B40313    1025         cjne a, #3 , state4
093E 754D50    1026         mov pwm, #80
0941 754B00    1027         mov sec, #0     
0944 E547      1028         mov a, temp_refl
0946 C3        1029         clr c
0947 954A      1030         subb a, temp
0949           1031         ;add branches to compare temp with 220
0949 5003      1032         jnc state3_done
094B 754904    1033         mov state, #4
094E           1034     state3_done:
094E 0207BC    1035          ljmp forever
0951           1036          
0951           1037      state4:
0951 B40410    1038         cjne a, #4 , state5
0954 754D14    1039         mov pwm, #20
0957 E548      1040         mov a, time_refl
0959 C3        1041         clr c
095A 954B      1042         subb a, sec
095C           1043         ;add branches to compare sec with 45
095C 5003      1044         jnc state4_done
095E 754905    1045         mov state, #5
0961           1046     state4_done:
0961 0207BC    1047          ljmp forever    
0964           1048          
0964           1049      state5:
0964 B40599    1050         cjne a, #5 , state0
0967 754D00    1051         mov pwm, #0
096A C3        1052         clr c
096B 954A      1053         subb a, temp
096D           1054         ;add branches to compare temp with 60
096D 5003      1055         jnc state5_done
096F 754900    1056         mov state, #0
0972           1057     state5_done:
0972 0207BC    1058          ljmp forever 
0975           1059          
0975           1060   
0975           1061   EN
