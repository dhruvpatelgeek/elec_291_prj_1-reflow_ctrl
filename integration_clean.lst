0000              1   
0000              2   ;;;;;;;;
0000              3   ; Start/Constants
                  5       $LIST
0000              7   
0000              8       CLK           EQU 7373000  ; Microcontroller system crystal frequency in Hz
0000              9       TIMER0_RATE   EQU 100     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0000             10       TIMER0_RELOAD EQU ((65536-(CLK/(2*TIMER0_RATE))))
0000             11       TIMER1_RATE   EQU 100     ; 100Hz, for a timer tick of 10ms
0000             12       TIMER1_RELOAD EQU ((65536-(CLK/(2*TIMER1_RATE))))
0000             13   
0000             14   
0000             15   
0000             16       CCU_RATE    EQU 11025     ; 22050Hz is the sampling rate of the wav file we are playing
0000             17       CCU_RELOAD  EQU ((65536-((CLK/(2*CCU_RATE)))))
0000             18       BAUD        EQU 115200
0000             19       BRVAL       EQU ((CLK/BAUD)-16)
0000             20   
0000             21           ;definitions for clk, baud rate, etc.
0000             22       OP_AMP_GAIN EQU 340 ;what is the exact gain?
0000             23   
0000             24   
0000             25   
0000             26       ; Commands supported by the SPI flash memory according to the datasheet
0000             27       WRITE_ENABLE     EQU 0x06  ; Address:0 Dummy:0 Num:0
0000             28       WRITE_DISABLE    EQU 0x04  ; Address:0 Dummy:0 Num:0
0000             29       READ_STATUS      EQU 0x05  ; Address:0 Dummy:0 Num:1 to infinite
0000             30       READ_BYTES       EQU 0x03  ; Address:3 Dummy:0 Num:1 to infinite
0000             31       READ_SILICON_ID  EQU 0xab  ; Address:0 Dummy:3 Num:1 to infinite
0000             32       FAST_READ        EQU 0x0b  ; Address:3 Dummy:1 Num:1 to infinite
0000             33       WRITE_STATUS     EQU 0x01  ; Address:0 Dummy:0 Num:1
0000             34       WRITE_BYTES      EQU 0x02  ; Address:3 Dummy:0 Num:1 to 256
0000             35       ERASE_ALL        EQU 0xc7  ; Address:0 Dummy:0 Num:0
0000             36       ERASE_BLOCK      EQU 0xd8  ; Address:3 Dummy:0 Num:0
0000             37       READ_DEVICE_ID   EQU 0x9f  ; Address:0 Dummy:2 Num:1 to infinite
0000             38   ;Vectors
0000             39       ; Reset vector
0000             40       org 0x0000
0000 020CC0      41           ljmp main
0003             42   
0003             43       ; External interrupt 0 vector (not used in this code)
0003             44       org 0x0003
0003 32          45           reti
0004             46   
0004             47       ; Timer/Counter 0 overflow interrupt vector
000B             48       org 0x000B
000B 020480      49           ljmp Timer0_ISR
000E             50   
000E             51       ; External interrupt 1 vector (not used in this code)
0013             52       org 0x0013
0013 32          53           reti
0014             54   
0014             55       ; Timer/Counter 1 overflow interrupt vector
001B             56       org 0x001B
001B 0204AB      57           ljmp Timer1_ISR
001E             58   
001E             59       ; Serial port receive/transmit interrupt vector (not used in this code)
0023             60       org 0x0023 
0023 32          61           reti
0024             62   
005B             63       org 0x005b ; CCU interrupt vector.  Used in this code to replay the wave file.
005B 020501      64           ljmp CCU_ISR
005E             65   
005E             66   
005E             67       ;                                                        -                     
005E             68       ;                                                       -  -                    
005E             69       ;                                                      -    -                   
005E             70       ;                              leave it at this temp>>-      -                  
005E             71       ;                                                    -        -                 
005E             72       ;                                                   -          -                 
005E             73       ;                                                  -            -               
005E             74       ;                                                 -              -              
005E             75       ;                                                -                -             
005E             76       ;                                               -                  -            
005E             77       ;                                              -                    -           
005E             78       ;                                             -    reflow>>cool     -          
005E             79       ;               -----------------------------    (temperature only)  -         
005E             80       ;              -     soak (time+temp)                                 -        
005E             81       ;             -                                                        -       
005E             82       ;            -                                                          -       
005E             83       ;          -                                                             -      
005E             84       ;         -                                                               -     
005E             85       ;        -                                                                 -    
005E             86       ;      -                                                                    -    
005E             87       ;     - ramp to soak (temperature)                                           -   
005E             88       ;   -                                                                         -   
005E             89       ;   state 1 ((temp==soak)? ssr_off: ssr_on)
005E             90       ;          state 2 ((time=soak_time)?(pwm_off):(pwn_on)
005E             91       ;                                           state 3 ((temp==soak)? ssr_off: ssr_on)
005E             92       ;                                                        state 4 (cooling ssr_off)
005E             93       ;                                                                             state 5 (done)
005E             94   
005E             95       ; In the 8051 we can define direct access variables starting at location 0x30 up to location 0x7F
005E             96   ;Variables(dseg) 
0030             97       dseg at 0x30
0030             98   
0030             99       ;FSM varialbles
0030            100       temp_soak:       ds 1 ; temp to soak
0031            101       time_soak:       ds 1 ; time to soak
0032            102       temp_refl:       ds 1 ; temp of relfow
0033            103       time_refl:       ds 1 ; time to reflow 
0034            104       state:           ds 1 ; current state 
0035            105       state_lcd:       ds 1
0036            106       temp:            ds 1 ; current temp in degree C
0037            107       sec:             ds 1 ; current time in seconds 
0038            108       product:         ds 1; pwm-currsec
0039            109       pwm:             ds 1 ; 
003A            110   
003A            111       ;Timer variables
003A            112       Count1ms:        ds 2 ; Used to determine when half second has passed
003C            113       reflow_temp:     ds 2
003E            114       soak_temp:       ds 2
0040            115       reflow_temp_var: ds 1
0041            116       BCD_counter:     ds 1 ; The BCD counter incrememted in the ISR and displayed in the main loop
0042            117       hour:            ds 1
0043            118       reflow_sec:      ds 1
0044            119       reflow_min:      ds 1
0045            120       soak_sec:        ds 1
0046            121       soak_min:        ds 1
0047            122       Count10ms:       ds 1 ; Used to determine when half second has passed
0048            123       Count10ms2:      ds 1
0049            124       w:               ds 3 ; 24-bit play counter.  Decremented in CCU ISR.
004C            125       minutes:         ds 1
004D            126       seconds:         ds 1
004E            127       T2S_FSM_state:   ds 1
004F            128       Count5ms:        ds 1
0050            129       five_sec_flag:   ds 1
0051            130   
0051            131       ; Temperature 
0051            132   
0051            133       x: ds 4
0055            134       y: ds 4
0059            135       Result: ds 2 
005B            136       ch0: ds 2
005D            137       ch1: ds 2
005F            138       oven_temp: ds 2
0061            139       bcd: ds 5
0066            140   
0066            141   ;flags(bseg)
0000            142       BSEG
0000            143       T2S_FSM_start:     dbit 1
0001            144       seconds_flag:      dbit 1
0002            145       mf:                dbit 1
0003            146       half_seconds_flag: dbit 1 ; Set to one in the ISR every time 500 ms had passed
0004            147       AMPM_flag:         dbit 1
0005            148       alarm_AMPM_flag:   dbit 1
0006            149       on_off_flag:       dbit 1 ; 1 is on
0007            150       alarm_buzzer_flag: dbit 1
0008            151       TR1_flag:          dbit 1
0009            152       tt_reflow_flag:    dbit 1
000A            153       tt_flag_soak:      dbit 1
000B            154       stop_flag:         dbit 1
000C            155       my_flag:           dbit 1
000D            156   
000D            157   
000D            158       ;_ _ _ _ | _ _ _ _ _ _
000D            159       ;
000D            160       ;pwm = 40 (say)
000D            161       ;then output will be 100 
000D            162       ;_________
000D            163       ;         |
000D            164       ;         |_____________
000D            165       ; where period is 1 second 
000D            166       ; In the 8051 we have variables that are 1-bit in size.  We can use the setb, clr, jb, and jnb
000D            167       ; instructions with these variables.  This is how you define a 1-bit variable:
000D            168   
000D            169   ;Pin config(cseg)
000D            170   
005E            171       cseg
005E            172       ; These 'equ' must match the wiring between the microcontroller and the LCD!
005E            173       LCD_RS equ P0.5
005E            174       LCD_RW equ P0.6
005E            175       LCD_E  equ P0.7
005E            176       LCD_D4 equ P1.2
005E            177       LCD_D5 equ P1.3
005E            178       LCD_D6 equ P1.4
005E            179       LCD_D7 equ P1.6
005E            180   
005E            181       CLEAR         equ P3.0
005E            182       FLASH_CE      EQU P2.4
005E            183       SOUND         EQU P2.7
005E            184       
005E            185       SETUP_SOAK_Button equ  P2.1
005E            186       set_BUTTON        equ  P2.2
005E            187       Button_min        equ  P2.0
005E            188       HOME_BUTTON       equ  P1.7
005E            189   
005E            190       SQUARE_WAVE       EQU P0.1
005E            191   
005E            192       ;define the connections between the ADC and MCU (P89 & MCP3008)
005E            193       CE_ADC    EQU  P1.7;P2.4   ;SS
005E            194       MY_MOSI   EQU  P3.1 ;P2.2  ;MOSI
005E            195       MY_MISO   EQU  P0.3   ;MISO
005E            196       MY_SCLK   EQU  P0.2   ;SPICLK
005E            197       
005E            198   ;include files
                546   $LIST
                201   	    $LIST
03A1            203   ;Strings
03A1            204     ;                       1234567890123456
03A1            205      ;General
03A1 0D0A00     206       Newline:          db   '\r', '\n', 0
03A4 20202020   207       Space:            db   '      ','\r', '\n', 0
     20200D0A
     00
03AD 20202020   208       nothing:          db '                ',0      
     20202020
     20202020
     20202020
     00
03BE 20202020   209       test2:            db '      Test2     ',0
     20205465
     73743220
     20202020
     00
03CF 20202020   210       hot:                           db '      HOT       ', 0
     2020484F
     54202020
     20202020
     00
03E0 3A00       211       dots:             db ':',0
03E2 74696D65   212       timee:            db 'time', 0
     00
03E7 3100       213       statee:           db '1', 0
03E9            214   
03E9 4243445F   215       Initial_Message:  db 'BCD_counter: xx ', 0
     636F756E
     7465723A
     20787820
     00
03FA            216      ;Home page
03FA 54656D70   217       Temp0:            db 'Temp:xxxC       ', 0
     3A787878
     43202020
     20202020
     00
040B 54696D65   218       Time:             db 'Time xx:xx SET  ', 0
     2078783A
     78782053
     45542020
     00
041C            219      ;Second Page
041C 2020534F   220       soak_reflw:       db '  SOAK  REFLOW  ', 0
     414B2020
     5245464C
     4F572020
     00
042D            221      ;Reflow Setup
042D 54656D70   222       reflow_setup:     db 'Temp',0
     00
0432 2A524546   223       reflow_setup4:    db '*REFLOW*',0
     4C4F572A
     00
043B 54696D65   224       reflow_setup2:    db 'Time',0
     00
0440 484F4D45   225       reflow_setup3:    db 'HOME',0
     00
0445            226      ;Soak Setup
0445 54656D70   227       soak_setup0:      db 'Temp',0
     00
044A 202A534F   228       soak_setup1:      db ' *SOAK*',0
     414B2A00
0452 54696D65   229       soak_setup2:      db 'Time',0
     00
0457 484F4D45   230       soak_setup3:      db 'HOME',0
     00
045C            231   
045C            232       ;Termperature
045C 30313233   233       HexAscii: db '0123456789ABCDEF',0
     34353637
     38394142
     43444546
     00
046D            234   ;------ISR-------;
046D            235       ;---------------------------------;
046D            236       ; Routine to initialize the ISR   ;
046D            237       ; for timer 0                     ;
046D            238       ;---------------------------------;
046D            239       Timer0_Init:
046D E589       240           mov a, TMOD
046F 54F0       241           anl a, #0xf0 ; Clear the bits for timer 0
0471 4401       242           orl a, #0x01 ; Configure timer 0 as 16-timer
0473 F589       243           mov TMOD, a
0475 758C6F     244           mov TH0, #high(TIMER0_RELOAD)
0478 758AFF     245           mov TL0, #low(TIMER0_RELOAD)
047B            246           ; Enable the timer and interrupts
047B D2A9       247           setb ET0  ; Enable timer 0 interrupt
047D D28C       248           setb TR0  ; Start timer 0
047F 22         249           ret
0480            250   
0480            251       ;---------------------------------;
0480            252       ; ISR for timer 0.  Set to execute;
0480            253       ; every 1/4096Hz to generate a    ;
0480            254       ; 2048 Hz square wave at pin P3.7 ;
0480            255       ;---------------------------------;
0480            256       Timer0_ISR:
0480 758C6F     257           mov TH0, #high(TIMER0_RELOAD)
0483 758AFF     258           mov TL0, #low(TIMER0_RELOAD)
0486 C0E0       259           push acc
0488 C0D0       260           push psw
048A            261           
048A 0548       262           inc Count10ms2
048C E548       263           mov a, Count10ms2
048E B43202     264           cjne a, #50, Timer0_ISR_done 
0491 D20C       265           setb my_flag  ; used to refresh the page even if timer 1 is disabled 
0493            266   
0493            267           Timer0_ISR_done:
0493 D0D0       268           pop psw
0495 D0E0       269           pop acc
0497 32         270           reti
0498            271   
0498            272       ;---------------------------------;
0498            273       ; Routine to initialize the ISR   ;
0498            274       ; for timer 1                     ;
0498            275       ;---------------------------------;
0498            276       Timer1_Init:
0498 E589       277           mov a, TMOD
049A 540F       278           anl a, #0x0f ; Clear the bits for timer 1
049C 4410       279           orl a, #0x10 ; Configure timer 1 as 16-timer
049E F589       280           mov TMOD, a
04A0 758D6F     281           mov TH1, #high(TIMER1_RELOAD)
04A3 758BFF     282           mov TL1, #low(TIMER1_RELOAD)
04A6            283           ; Enable the timer and interrupts
04A6 D2AB       284           setb ET1  ; Enable timer 1 interrupt
04A8 D28E       285           setb TR1  ; Start timer 1
04AA 22         286           ret
04AB            287   
04AB            288       ;---------------------------------;
04AB            289       ; ISR for timer 1                 ;
04AB            290       ;---------------------------------;
04AB            291       Timer1_ISR:
04AB 758D6F     292           mov TH1, #high(TIMER1_RELOAD)
04AE 758BFF     293           mov TL1, #low(TIMER1_RELOAD)       
04B1            294           ; The two registers used in the ISR must be saved in the stack
04B1 C0E0       295           push acc
04B3 C0D0       296           push psw 
04B5            297           ; Increment the 8-bit 10-mili-second counter
04B5 0547       298           inc Count10ms
04B7            299           ; Increment the 16-bit one mili second counter
04B7            300       Inc_Done:
04B7 E547       301           mov a, Count10ms
04B9 9539       302           subb a, pwm ; if pwm greater than a count 10 ms  is  the pin is off else on 
04BB D4         303           da a
04BC 5005       304           jnc off_segment
04BE D281       305           setb SQUARE_WAVE
04C0 C3         306           clr c
04C1 8005       307           sjmp pass
04C3            308           off_segment:
04C3 C281       309           clr SQUARE_WAVE
04C5 C3         310           clr c
04C6 8000       311           sjmp pass
04C8            312           ; Check if 1 second has passed
04C8            313           pass:
04C8 E547       314           mov a, Count10ms
04CA B4C818     315           cjne a, #200, Timer1_ISR_done ; Warning: this instruction changes the carry flag!
04CD            316           ;----------------------------;
04CD 0537       317           inc sec ; one second has passed
04CF E537       318           mov a,sec
04D1 D4         319           da a
04D2 F537       320           mov sec,a
04D4 E537       321           mov a,sec
04D6            322          ; mov minutes, #0
04D6 85E04D     323           mov seconds, acc 
04D9            324           ;----------------------------
04D9            325           ; 500 milliseconds have passed.  Set a flag so the main program knows
04D9 D203       326           setb half_seconds_flag ; Let the main program know half second had passed
04DB            327           ; Reset to zero the 10-milli-seconds counter, it is a 8-bit variable
04DB 754700     328           mov Count10ms, #0x00
04DE            329           ; Increment the BCD counter
04DE E541       330           mov a, BCD_counter
04E0 2401       331           add a, #0x01
04E2            332       Timer1_ISR_da:
04E2 D4         333           da a ; Decimal adjust instruction.  Check datasheet for more details!
04E3 F541       334           mov BCD_counter, a
04E5            335           
04E5            336       Timer1_ISR_done:
04E5 D0D0       337           pop psw
04E7 D0E0       338           pop acc
04E9 32         339           reti
04EA            340   
04EA            341   
04EA            342   
04EA            343   
04EA            344   
04EA            345       ;------------------------------
04EA            346       ;---------------------------------;
04EA            347       ; Routine to initialize the CCU.  ;
04EA            348       ; We are using the CCU timer in a ;
04EA            349       ; manner similar to the timer 2   ;
04EA            350       ; available in other 8051s        ;
04EA            351       ;---------------------------------;
04EA            352       CCU_Init:
04EA 75CDFE     353           mov TH2, #high(CCU_RELOAD)
04ED 75CCB2     354           mov TL2, #low(CCU_RELOAD)
04F0 75CFFE     355           mov TOR2H, #high(CCU_RELOAD)
04F3 75CEB2     356           mov TOR2L, #low(CCU_RELOAD)
04F6 75F980     357           mov TCR21, #10000000b ; Latch the reload value
04F9 75C980     358           mov TICR2, #10000000b ; Enable CCU Timer Overflow Interrupt
04FC D2EC       359           setb ECCU ; Enable CCU interrupt
04FE D2C8       360           setb TMOD20 ; Start CCU timer
0500 22         361           ret
0501            362   
0501            363       ;---------------------------------;
0501            364       ; ISR for CCU.  Used to playback  ;
0501            365       ; the WAV file stored in the SPI  ;
0501            366       ; flash memory.                   ;
0501            367       ;---------------------------------;
0501            368       CCU_ISR:
0501 75E900     369           mov TIFR2, #0 ; Clear CCU Timer Overflow Interrupt Flag bit. Actually, it clears all the bits!
0504            370           
0504            371           ; The registers used in the ISR must be saved in the stack
0504 C0E0       372           push acc
0506 C0D0       373           push psw
0508            374           
0508            375           ; Check if the play counter is zero.  If so, stop playing sound.
0508 E549       376           mov a, w+0
050A 454A       377           orl a, w+1
050C 454B       378           orl a, w+2
050E 6015       379           jz stop_playing
0510            380           
0510            381           ;;yolo this is gonna fuck with the speaker
0510            382           ; Increment the 16-bit one mili second counter
0510            383         ;  inc Count1ms+0    ; Increment the low 8-bits first
0510            384         ;  mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
0510            385         ;  jnz Inc_Done
0510            386         ;  inc Count1ms+1
0510            387           ; Decrement play counter 'w'.  In this implementation 'w' is a 24-bit counter.
0510 74FF       388           mov a, #0xff
0512 1549       389           dec w+0
0514 B54907     390           cjne a, w+0, keep_playing
0517 154A       391           dec w+1
0519 B54A02     392           cjne a, w+1, keep_playing
051C 154B       393           dec w+2
051E            394           
051E            395       keep_playing:
051E            396   
051E 120571     397           lcall Send_SPI ; Read the next byte from the SPI Flash...
0521 F5F5       398           mov AD1DAT3, a ; and send it to the DAC
0523            399           
0523 8006       400           sjmp CCU_ISR_Done
0525            401   
0525            402       stop_playing:
0525 C2C8       403           clr TMOD20 ; Stop CCU timer
0527 D2A4       404           setb FLASH_CE  ; Disable SPI Flash
0529 C2A7       405           clr SOUND ; Turn speaker off
052B            406   
052B            407       CCU_ISR_Done:        
052B D0D0       408           pop psw
052D D0E0       409           pop acc
052F 32         410           reti
0530            411   ;----------------;
0530            412   
0530            413   ;---------------------------------;
0530            414   ; Initial configuration of ports. ;
0530            415   ; After reset the default for the ;
0530            416   ; pins is 'Open Drain'.  This     ;
0530            417   ; routine changes them pins to    ;
0530            418   ; Quasi-bidirectional like in the ;
0530            419   ; original 8051.                  ;
0530            420   ; Notice that P1.2 and P1.3 are   ;
0530            421   ; always 'Open Drain'. If those   ;
0530            422   ; pins are to be used as output   ;
0530            423   ; they need a pull-up resistor.   ;
0530            424   ;---------------------------------;
0530            425   Ports_Init:
0530            426       ; Configure all the ports in bidirectional mode:
0530 758400     427       mov P0M1, #00H
0533 758500     428       mov P0M2, #00H
0536 759100     429       mov P1M1, #00H
0539 759200     430       mov P1M2, #00H ; WARNING: P1.2 and P1.3 need 1 kohm pull-up resistors if used as outputs!
053C 75A400     431       mov P2M1, #00H
053F 75A500     432       mov P2M2, #00H
0542 75B100     433       mov P3M1, #00H
0545 75B200     434       mov P3M2, #00H
0548 22         435            ret
0549            436   
0549            437   ;---------------------------------;
0549            438   ; Initialize ADC1/DAC1 as DAC1.   ;
0549            439   ; Warning, the ADC1/DAC1 can work ;
0549            440   ; only as ADC or DAC, not both.   ;
0549            441   ; The P89LPC9351 has two ADC/DAC  ;
0549            442   ; interfaces.  One can be used as ;
0549            443   ; ADC and the other can be used   ;
0549            444   ; as DAC.  Also configures the    ;
0549            445   ; pin associated with the DAC, in ;
0549            446   ; this case P0.4 as 'Open Drain'. ;
0549            447   ;---------------------------------;
0549            448   InitDAC1:
0549            449       ; Configure pin P0.4 (DAC1 output pin) as open drain
0549 438410     450            orl     P0M1,   #00010000B
054C 438510     451            orl     P0M2,   #00010000B
054F 75A128     452       mov ADMODB, #00101000B ; Select main clock/2 for ADC/DAC.  Also enable DAC1 output (Table 25 of reference manual)
0552 759704     453            mov     ADCON1, #00000100B ; Enable the converter
0555 75F580     454            mov AD1DAT3, #0x80     ; Start value is 3.3V/2 (zero reference for AC WAV file)
0558 22         455            ret
0559            456   
0559            457   ;---------------------------------;
0559            458   ; Change the internal RC osc. clk ;
0559            459   ; from 7.373MHz to 14.746MHz.     ;
0559            460   ;---------------------------------;
0559            461   Double_Clk:
0559 90FFDE     462       mov dptr, #CLKCON
055C E0         463       movx a, @dptr
055D 4408       464       orl a, #00001000B ; double the clock speed to 14.746MHz
055F F0         465       movx @dptr,a
0560 22         466            ret
0561            467   
0561            468   ;---------------------------------;
0561            469   ; Initialize the SPI interface    ;
0561            470   ; and the pins associated to SPI. ;
0561            471   ;---------------------------------;
0561            472   Init_SPI:
0561            473            ; Configure MOSI (P2.2), CS* (P2.4), and SPICLK (P2.5) as push-pull outputs (see table 42, page 51)
0561 53A4CB     474            anl P2M1, #low(not(00110100B))
0564 43A534     475            orl P2M2, #00110100B
0567            476            ; Configure MISO (P2.3) as input (see table 42, page 51)
0567 43A408     477            orl P2M1, #00001000B
056A 53A5F7     478            anl P2M2, #low(not(00001000B)) 
056D            479            ; Configure SPI
056D 75E2D0     480            mov SPCTL, #11010000B ; Ignore /SS, Enable SPI, DORD=0, Master=1, CPOL=0, CPHA=0, clk/4
0570 22         481            ret
0571            482   
0571            483   ;---------------------------------;
0571            484   ; Sends AND receives a byte via   ;
0571            485   ; SPI.                            ;
0571            486   ;---------------------------------;
0571            487   Send_SPI:
0571 F5E3       488            mov SPDAT, a
0573            489       Send_SPI_1:
0573 E5E1       490           mov a, SPSTAT 
0575 30E7FB     491           jnb acc.7, Send_SPI_1 ; Check SPI Transfer Completion Flag
0578 F5E1       492           mov SPSTAT, a ; Clear SPI Transfer Completion Flag
057A E5E3       493           mov a, SPDAT ; return received byte via accumulator
057C 22         494           ret
057D            495   
057D            496   ;---------------------------------;
057D            497   ; SPI flash 'write enable'        ;
057D            498   ; instruction.                    ;
057D            499   ;---------------------------------;
057D            500   Enable_Write:
057D C2A4       501            clr FLASH_CE
057F 7406       502            mov a, #WRITE_ENABLE
0581 120571     503            lcall Send_SPI
0584 D2A4       504            setb FLASH_CE
0586 22         505            ret
0587            506   
0587            507   ;---------------------------------;
0587            508   ; This function checks the 'write ;
0587            509   ; in progress' bit of the SPI     ;
0587            510   ; flash memory.                   ;
0587            511   ;---------------------------------;
0587            512   Check_WIP:
0587 C2A4       513            clr FLASH_CE
0589 7405       514            mov a, #READ_STATUS
058B 120571     515            lcall Send_SPI
058E 7455       516            mov a, #0x55
0590 120571     517            lcall Send_SPI
0593 D2A4       518            setb FLASH_CE
0595 20E0EF     519            jb acc.0, Check_WIP ;  Check the Write in Progress bit
0598 22         520            ret
0599            521            
0599            522   ; Display a binary number in the LCD (must be less than 99).  Number to display passed in accumulator.
0599            523   LCD_number:
0599 C0E0       524            push acc
059B 75F00A     525            mov b, #10
059E 84         526            div ab
059F 4430       527            orl a, #'0'
05A1 12031C     528            lcall ?WriteData
05A4 E5F0       529            mov a, b
05A6 4430       530            orl a, #'0'
05A8 12031C     531            lcall ?WriteData
05AB D0E0       532            pop acc
05AD 22         533            ret
05AE            534   ;SPEAKER
05AE            535       ; Sounds we need in the SPI flash: 0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 30; 40; 50; minutes; seconds;
05AE            536       ; Approximate index of sounds in file 'stop_watch.wav'
05AE            537       ; This was generated using: computer_sender -Asw_index.asm -S2000 stop_watch.wav
05AE            538       sound_index:
05AE 00002D     539           db 0x00, 0x00, 0x2d ; 0 
05B1 003107     540           db 0x00, 0x31, 0x07 ; 1 
05B4 007007     541           db 0x00, 0x70, 0x07 ; 2 
05B7 00ADB9     542           db 0x00, 0xad, 0xb9 ; 3 
05BA 00F266     543           db 0x00, 0xf2, 0x66 ; 4 
05BD 0135D5     544           db 0x01, 0x35, 0xd5 ; 5 
05C0 017D33     545           db 0x01, 0x7d, 0x33 ; 6 
05C3 01C761     546           db 0x01, 0xc7, 0x61 ; 7 
05C6 021279     547           db 0x02, 0x12, 0x79 ; 8 
05C9 0249C1     548           db 0x02, 0x49, 0xc1 ; 9 
05CC 028F7A     549           db 0x02, 0x8f, 0x7a ; 10 
05CF 02D063     550           db 0x02, 0xd0, 0x63 ; 11 
05D2 031B87     551           db 0x03, 0x1b, 0x87 ; 12 
05D5 03630E     552           db 0x03, 0x63, 0x0e ; 13 
05D8 03B95F     553           db 0x03, 0xb9, 0x5f ; 14 
05DB 04113A     554           db 0x04, 0x11, 0x3a ; 15 
05DE 0466C4     555           db 0x04, 0x66, 0xc4 ; 16 
05E1 04C012     556           db 0x04, 0xc0, 0x12 ; 17 
05E4 052698     557           db 0x05, 0x26, 0x98 ; 18 
05E7 0574E9     558           db 0x05, 0x74, 0xe9 ; 19 
05EA 05D28E     559           db 0x05, 0xd2, 0x8e ; 20 
05ED 061D83     560           db 0x06, 0x1d, 0x83 ; 21 -> 30 
05F0 066342     561           db 0x06, 0x63, 0x42 ; 22 -> 40 
05F3 06AAB9     562           db 0x06, 0xaa, 0xb9 ; 23 -> 50 
05F6 06F3D6     563           db 0x06, 0xf3, 0xd6 ; 24 -> Minutes 
05F9 073F02     564           db 0x07, 0x3f, 0x02 ; 25 -> Seconds 
05FC            565   
05FC            566       ; Size of each sound in 'sound_index'
05FC            567       ; Generated using: computer_sender -Asw_index.asm -S2000 stop_watch.wav
05FC            568       Size_Length:
05FC 0030DA     569           db 0x00, 0x30, 0xda ; 0 
05FF 003F00     570           db 0x00, 0x3f, 0x00 ; 1 
0602 003DB2     571           db 0x00, 0x3d, 0xb2 ; 2 
0605 0044AD     572           db 0x00, 0x44, 0xad ; 3 
0608 00436F     573           db 0x00, 0x43, 0x6f ; 4 
060B 00475E     574           db 0x00, 0x47, 0x5e ; 5 
060E 004A2E     575           db 0x00, 0x4a, 0x2e ; 6 
0611 004B18     576           db 0x00, 0x4b, 0x18 ; 7 
0614 003748     577           db 0x00, 0x37, 0x48 ; 8 
0617 0045B9     578           db 0x00, 0x45, 0xb9 ; 9 
061A 0040E9     579           db 0x00, 0x40, 0xe9 ; 10 
061D 004B24     580           db 0x00, 0x4b, 0x24 ; 11 
0620 004787     581           db 0x00, 0x47, 0x87 ; 12 
0623 005651     582           db 0x00, 0x56, 0x51 ; 13 
0626 0057DB     583           db 0x00, 0x57, 0xdb ; 14 
0629 00558A     584           db 0x00, 0x55, 0x8a ; 15 
062C 00594E     585           db 0x00, 0x59, 0x4e ; 16 
062F 006686     586           db 0x00, 0x66, 0x86 ; 17 
0632 004E51     587           db 0x00, 0x4e, 0x51 ; 18 
0635 005DA5     588           db 0x00, 0x5d, 0xa5 ; 19 
0638 004AF5     589           db 0x00, 0x4a, 0xf5 ; 20 
063B 0045BF     590           db 0x00, 0x45, 0xbf ; 21 -> 30
063E 004777     591           db 0x00, 0x47, 0x77 ; 22 -> 40
0641 00491D     592           db 0x00, 0x49, 0x1d ; 23 -> 50
0644 004B2C     593           db 0x00, 0x4b, 0x2c ; 24 -> minutes
0647 005C87     594           db 0x00, 0x5c, 0x87 ; 25 -> seconds
064A            595   
064A            596       ; The sound and its length from the two tables above is passed in the accumulator.
064A            597       Play_Sound_Using_Index:
064A D2A7       598           setb SOUND ; Turn speaker on
064C C2C8       599           clr TMOD20 ; Stop the CCU from playing previous request
064E D2A4       600           setb FLASH_CE
0650            601           
0650            602           ; There are three bytes per row in our tables, so multiply index by three
0650 75F003     603           mov b, #3
0653 A4         604           mul ab
0654 F8         605           mov R0, a ; Make a copy of the index*3
0655            606           
0655 C2A4       607           clr FLASH_CE ; Enable SPI Flash
0657 7403       608           mov a, #READ_BYTES
0659 120571     609           lcall Send_SPI
065C            610           ; Set the initial position in memory of where to start playing
065C 9005AE     611           mov dptr, #sound_index
065F E8         612           mov a, R0
0660 93         613           movc a, @a+dptr
0661 120571     614           lcall Send_SPI
0664 A3         615           inc dptr
0665 E8         616           mov a, R0
0666 93         617           movc a, @a+dptr
0667 120571     618           lcall Send_SPI
066A A3         619           inc dptr
066B E8         620           mov a, R0
066C 93         621           movc a, @a+dptr
066D 120571     622           lcall Send_SPI
0670            623           ; Now set how many bytes to play
0670 9005FC     624           mov dptr, #Size_Length
0673 E8         625           mov a, R0
0674 93         626           movc a, @a+dptr
0675 F54B       627           mov w+2, a
0677 A3         628           inc dptr
0678 E8         629           mov a, R0
0679 93         630           movc a, @a+dptr
067A F54A       631           mov w+1, a
067C A3         632           inc dptr
067D E8         633           mov a, R0
067E 93         634           movc a, @a+dptr
067F F549       635           mov w+0, a
0681            636           
0681 7400       637           mov a, #0x00 ; Request first byte to send to DAC
0683 120571     638           lcall Send_SPI
0686            639           
0686 D2C8       640           setb TMOD20 ; Start playback by enabling CCU timer
0688            641   
0688 22         642           ret
0689            643       
0689            644   ;;;;;;/;;;;;;;;----------------------------------- add all the function in this bracee
0689            645   ;;;;;;/;;;;;;;;----------------------------------- add all the function in this bracee
0689            646   ;;;;;;/;;;;;;;;----------------------------------- add all the function in this bracee
0689            647   ;;;;;;/;;;;;;;;----------------------------------- add all the function in this bracee
0689            648   ;;;;;;/;;;;;;;;----------------------------------- add all the function in this bracee
0689            649   ;;;;;;/;;;;;;;;----------------------------------- add all the function in this brace
0689            650   ;;;;;;/;;;;;;;;----------------------------------- add all the function in this bracee
0689            651   ;;;;;;/;;;;;;;;----------------------------------- add all the function in this bracee
0689            652   ;;;;;;/;;;;;;;;----------------------------------- add all the function in this brace
0689            653   
0689            654   InitSerialPort:
0689            655            ;DEBOUNCING??
0689            656            ; Since the reset button bounces, we need to wait a bit before
0689            657       ; sending messages, otherwise we risk displaying gibberish!
0689            658       ;mov R1, #222
0689            659       ;mov R0, #166
0689            660       ;djnz R0, $   ; 3 cycles->3*45.21123ns*166=22.51519us
0689            661       ;djnz R1, $-4 ; 22.51519us*222=4.998ms
0689            662       ; Now we can proceed with the configuration
0689            663            
0689 75BD00     664            mov     BRGCON,#0x00
068C 75BF00     665            mov     BRGR1,#high(BRVAL)
068F 75BE30     666            mov     BRGR0,#low(BRVAL)
0692 75BD03     667            mov     BRGCON,#0x03 ; Turn-on the baud rate generator
0695 759852     668            mov     SCON,#0x52 ; Serial port in mode 1, ren, txrdy, rxempty
0698 759100     669            mov     P1M1,#0x00 ; Enable pins RxD and TXD
069B 759200     670            mov     P1M2,#0x00 ; Enable pins RxD and TXD
069E 22         671            ret
069F            672   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;    
069F            673   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;     
069F            674   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;     
069F            675   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;     
069F            676   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;     
069F            677   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;     
069F            678   ;INIT_SPI:     
069F            679   ;        setb MY_MISO    ; Make MISO an input pin     
069F            680   ;        clr MY_SCLK     ; For mode (0,0) SCLK is zero     
069F            681   ;        ret
069F            682   ;bit-bang SPI
069F            683   
069F            684   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;     
069F            685   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;     
069F            686   ;;;;;;;;;;;;;;;;;;;;;;;;; check here for e;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;    
069F            687   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;     
069F            688   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;     
069F            689   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;     
069F            690   
069F            691   DO_SPI_G:     
069F C0E0       692            push acc     
06A1 7900       693            mov R1, #0      ; Received byte stored in R1     
06A3 7A08       694            mov R2, #8      ; Loop counter (8-bits)
06A5            695   DO_SPI_G_LOOP:     
06A5 E8         696            mov a, R0       ; Byte to write is in R0     
06A6 33         697            rlc a           ; Carry flag has bit to write     
06A7 F8         698            mov R0, a     
06A8 92B1       699            mov MY_MOSI, c 
06AA D282       700            setb MY_SCLK    ; Transmit     
06AC A283       701            mov c, MY_MISO  ; Read received bit     
06AE E9         702            mov a, R1       ; Save received bit in R1    
06AF 33         703            rlc a 
06B0 F9         704            mov R1, a     
06B1 C282       705            clr MY_SCLK     
06B3 DAF0       706            djnz R2, DO_SPI_G_LOOP     
06B5 D0E0       707            pop acc     
06B7 22         708            ret 
06B8            709            
06B8            710   ;;---------------------------------;
06B8            711   ;; Send a BCD number to PuTTY      ;
06B8            712   ;;---------------------------------;
06B8            713   ;Send_BCD mac
06B8            714   ;        push ar0
06B8            715   ;        mov r0, %0
06B8            716   ;        lcall ?Send_BCD
06B8            717   ;        pop ar0
06B8            718   ;endmac
06B8            719   ;
06B8            720   ;?Send_BCD:
06B8            721   ;        push acc
06B8            722   ;        ; Write most significant digit
06B8            723   ;        mov a, r0
06B8            724   ;        swap a
06B8            725   ;        anl a, #0fh
06B8            726   ;        orl a, #30h
06B8            727   ;        lcall putchar
06B8            728   ;        ; write least significant digit
06B8            729   ;        mov a, r0
06B8            730   ;        anl a, #0fh
06B8            731   ;        orl a, #30h
06B8            732   ;        lcall putchar
06B8            733   ;        pop acc
06B8            734   ;        ret      
06B8            735   
06B8            736   ; Send a character using the serial port
06B8            737   ;putchar:
06B8            738   ;        jbc     TI,putchar_L1
06B8            739   ;        sjmp putchar
06B8            740   ;putchar_L1:
06B8            741   ;        mov     SBUF,a
06B8            742   ;        ret
06B8            743            
06B8            744   getchar:
06B8 109802     745            jbc     RI,getchar_L1
06BB 80FB       746            sjmp getchar
06BD            747   getchar_L1:
06BD E599       748            mov     a,SBUF
06BF 22         749            ret     
06C0            750       
06C0            751   ;approximate delay of 1s
06C0            752   Delay:
06C0 7AB2       753       mov R2, #89*2
06C2 79FA       754   L4: mov R1, #250
06C4 78A6       755   L5: mov R0, #166
06C6 D8FE       756   L6: djnz R0, L6 ; 3 cycles->3*45.21123ns*166=22.51519us
06C8 D9FA       757       djnz R1, L5 ; 22.51519us*250=5.629ms
06CA DAF6       758       djnz R2, L4 ; 5.629ms*89=0.5s (approximately)
06CC 22         759       ret
06CD            760       
06CD            761   
06CD            762   
06CD            763   SendTemp:
06CD 90045C     764            mov dptr, #HexAscii 
06D0            765            
06D0 E562       766            mov a, bcd+1
06D2 C4         767            swap a
06D3 540F       768            anl a, #0xf
06D5 93         769            movc a, @a+dptr
06D6 120399     770            lcall putchar
06D9 E562       771            mov a, bcd+1
06DB 540F       772            anl a, #0xf
06DD 93         773            movc a, @a+dptr
06DE 120399     774            lcall putchar
06E1            775   
06E1 742E       776            mov a, #'.'
06E3 120399     777            lcall putchar
06E6            778   
06E6 E561       779            mov a, bcd+0
06E8 C4         780            swap a
06E9 540F       781            anl a, #0xf
06EB 93         782            movc a, @a+dptr
06EC 120399     783            lcall putchar
06EF E561       784            mov a, bcd+0
06F1 540F       785            anl a, #0xf
06F3 93         786            movc a, @a+dptr
06F4 120399     787            lcall putchar
06F7            788            
06F7 740D       789            mov a, #'\r'
06F9 120399     790            lcall putchar
06FC 740A       791            mov a, #'\n'
06FE 120399     792            lcall putchar   
0701 22         793            ret    
0702            794   
0702            795   SendString:
0702 E4         796       clr a
0703 93         797       movc a, @a+dptr
0704 6006       798       jz SendString_L1
0706 120399     799       lcall putchar
0709 A3         800       inc dptr
070A 80F6       801       sjmp SendString  
070C            802   SendString_L1:
070C 22         803            ret
070D            804       
070D            805   new_line:
070D 0D0A00     806         DB '\r' ,'\n', 0     
0710            807       
0710            808   Display_putty:
0710 C000       809            push ar0
0712 A862       809            mov r0, bcd+1
0714 120383     809            lcall ?Send_BCD
0717 D000       809            pop ar0
0719 C000       810            push ar0
071B A861       810            mov r0, bcd+0
071D 120383     810            lcall ?Send_BCD
0720 D000       810            pop ar0
0722 22         811            ret   
0723            812   
0723            813   ;;;;;;/;;;;;;;;----------------------------------- add all thr function in this brace
0723            814   ;---------------------------------------------------------------------------------;
0723            815   ; This is the FSM that plays minutes and seconds after the STOP button is pressed ;
0723            816   ; The state diagram of this FSM is available as 'Stop_Watch_FSM.pdf'              ;
0723            817   
0723            818   ;;;;;;/;;;;;;;;----------------------------------- add all thr function in this brace
0723            819   
0723            820   ;;;;;;/;;;;;;;;----------------------------------- add all thr function in this brace
0723            821   
0723            822   ;;;;;;/;;;;;;;;----------------------------------- add all thr function in this brace
0723            823   
0723            824   ;;;;;;/;;;;;;;;----------------------------------- add all thr function in this brace
0723            825   ;;;;;;/;;;;;;;;----------------------------------- add all thr function in this brace
0723            826   
0723            827   ;;;;;;/;;;;;;;;----------------------------------- add all thr function in this brace
0723            828   
0723            829   ;;;;;;/;;;;;;;;----------------------------------- add all thr function in this brace
0723            830   
0723            831   ;;;;;;/;;;;;;;;----------------------------------- add all thr function in this brace
0723            832       T2S_FSM:
0723 E54E       833           mov a, T2S_FSM_state
0725            834   
0725            835       T2S_FSM_State0: ; Checks for the start signal (T2S_FSM_Start==1)
0725 B40013     836           cjne a, #0, T2S_FSM_State1
0728 30000F     837           jnb T2S_FSM_Start, T2S_FSM_State0_Done
072B            838           ; Check if minutes is larger than 19
072B C3         839           clr c
072C E54C       840           mov a, minutes
072E 9414       841           subb a, #20
0730 5005       842           jnc minutes_gt_19
0732 754E01     843           mov T2S_FSM_state, #1
0735 8003       844           sjmp T2S_FSM_State0_Done
0737            845       minutes_gt_19:
0737 754E03     846           mov T2S_FSM_state, #3
073A            847       T2S_FSM_State0_Done:
073A 22         848           ret
073B            849           
073B            850       T2S_FSM_State1: ; Plays minutes when minutes is less than 20
073B B40109     851           cjne a, #1, T2S_FSM_State2
073E E54C       852           mov a, minutes
0740 12064A     853           lcall Play_Sound_Using_Index
0743 754E02     854           mov T2S_FSM_State, #2
0746 22         855           ret 
0747            856   
0747            857       T2S_FSM_State2: ; Stay in this state until sound finishes playing
0747 B40207     858           cjne a, #2, T2S_FSM_State3
074A 20C803     859           jb TMOD20, T2S_FSM_State2_Done 
074D 754E06     860           mov T2S_FSM_State, #6
0750            861       T2S_FSM_State2_Done:
0750 22         862           ret
0751            863   
0751            864       T2S_FSM_State3: ; Plays the tens when minutes is larger than 19, for example for 42 minutes, it plays 'forty'
0751 B4030F     865           cjne a, #3, T2S_FSM_State4
0754 E54C       866           mov a, minutes
0756 75F00A     867           mov b, #10
0759 84         868           div ab
075A 2412       869           add a, #18
075C 12064A     870           lcall Play_Sound_Using_Index
075F 754E04     871           mov T2S_FSM_State, #4
0762 22         872           ret
0763            873   
0763            874       T2S_FSM_State4: ; Stay in this state until sound finishes playing
0763 B40407     875           cjne a, #4, T2S_FSM_State5
0766 20C803     876           jb TMOD20, T2S_FSM_State4_Done 
0769 754E05     877           mov T2S_FSM_State, #5
076C            878       T2S_FSM_State4_Done:
076C 22         879           ret
076D            880   
076D            881       T2S_FSM_State5: ; Plays the units when minutes is larger than 19, for example for 42 minutes, it plays 'two'
076D B40511     882           cjne a, #5, T2S_FSM_State6
0770 E54C       883           mov a, minutes
0772 75F00A     884           mov b, #10
0775 84         885           div ab
0776 E5F0       886           mov a, b
0778 6003       887           jz T2S_FSM_State5_Done ; Prevents from playing something like 'forty zero'
077A 12064A     888           lcall Play_Sound_Using_Index
077D            889       T2S_FSM_State5_Done:
077D 754E02     890           mov T2S_FSM_State, #2
0780 22         891           ret
0781            892   
0781            893       T2S_FSM_State6: ; Plays the word 'minutes'
0781 B40609     894           cjne a, #6, T2S_FSM_State7
0784 7418       895           mov a, #24 ; Index 24 has the word 'minutes'
0786 12064A     896           lcall Play_Sound_Using_Index
0789 754E07     897           mov T2S_FSM_State, #7
078C 22         898           ret
078D            899   
078D            900       T2S_FSM_State7: ; Stay in this state until sound finishes playing
078D B40713     901           cjne a, #7, T2S_FSM_State8
0790 20C80F     902           jb TMOD20, T2S_FSM_State7_Done 
0793            903           ; Done playing previous sound, check if seconds is larger than 19
0793 C3         904           clr c
0794 E54D       905           mov a, seconds
0796 9414       906           subb a, #20
0798 5005       907           jnc seconds_gt_19
079A 754E08     908           mov T2S_FSM_state, #8
079D 809B       909           sjmp T2S_FSM_State0_Done
079F            910       seconds_gt_19:
079F 754E0A     911           mov T2S_FSM_state, #10
07A2            912       T2S_FSM_State7_Done:
07A2 22         913           ret
07A3            914   
07A3            915       T2S_FSM_State8: ; Play the seconds when seconds is less than 20.
07A3 B40809     916           cjne a, #8, T2S_FSM_State9
07A6 E54D       917           mov a, seconds
07A8 12064A     918           lcall Play_Sound_Using_Index
07AB 754E09     919           mov T2S_FSM_state, #9
07AE 22         920           ret
07AF            921   
07AF            922       T2S_FSM_State9: ; Stay in this state until sound finishes playing
07AF B40907     923           cjne a, #9, T2S_FSM_State10
07B2 20C803     924           jb TMOD20, T2S_FSM_State9_Done 
07B5 754E0D     925           mov T2S_FSM_State, #13
07B8            926       T2S_FSM_State9_Done:
07B8 22         927           ret
07B9            928   
07B9            929       T2S_FSM_State10:  ; Plays the tens when seconds is larger than 19, for example for 35 seconds, it plays 'thirty'
07B9 B40A0F     930           cjne a, #10, T2S_FSM_State11
07BC E54D       931           mov a, seconds
07BE 75F00A     932           mov b, #10
07C1 84         933           div ab
07C2 2412       934           add a, #18
07C4 12064A     935           lcall Play_Sound_Using_Index
07C7 754E0B     936           mov T2S_FSM_state, #11
07CA 22         937           ret
07CB            938   
07CB            939       T2S_FSM_State11: ; Stay in this state until sound finishes playing
07CB B40B07     940           cjne a, #11, T2S_FSM_State12
07CE 20C803     941           jb TMOD20, T2S_FSM_State11_Done 
07D1 754E0C     942           mov T2S_FSM_State, #12
07D4            943       T2S_FSM_State11_Done:
07D4 22         944           ret
07D5            945   
07D5            946       T2S_FSM_State12: ; Plays the units when seconds is larger than 19, for example for 35 seconds, it plays 'five'
07D5 B40C11     947           cjne a, #12, T2S_FSM_State13
07D8 E54D       948           mov a, seconds
07DA 75F00A     949           mov b, #10
07DD 84         950           div ab
07DE E5F0       951           mov a, b
07E0 6003       952           jz T2S_FSM_State12_Done ; Prevents from saying something like 'thirty zero'
07E2 12064A     953           lcall Play_Sound_Using_Index
07E5            954       T2S_FSM_State12_Done:
07E5 754E09     955           mov T2S_FSM_State, #9
07E8 22         956           ret
07E9            957   
07E9            958       T2S_FSM_State13: ; Plays the word 'seconds'
07E9 B40D09     959           cjne a, #13, T2S_FSM_State14
07EC 7419       960           mov a, #25 ; Index 25 has the word 'seconds'
07EE 12064A     961           lcall Play_Sound_Using_Index
07F1 754E0E     962           mov T2S_FSM_State, #14
07F4 22         963           ret
07F5            964   
07F5            965       T2S_FSM_State14: ; Stay in this state until sound finishes playing
07F5 B40E09     966           cjne a, #14, T2S_FSM_Error
07F8 20C805     967           jb TMOD20, T2S_FSM_State14_Done 
07FB C200       968           clr T2S_FSM_Start 
07FD 754E00     969           mov T2S_FSM_State, #0
0800            970       T2S_FSM_State14_Done:
0800 22         971           ret
0801            972   
0801            973       T2S_FSM_Error: ; If we got to this point, there is an error in the finite state machine.  Restart it.
0801 754E00     974           mov T2S_FSM_state, #0
0804 C200       975           clr T2S_FSM_Start
0806 22         976           ret
0807            977   ;---------------------------------------------------------------------------------;       
0807            978   WaitHalfSec:
0807 7AB2       979               mov R2, #178
0809 79FA       980               Lr3: mov R1, #250
080B 78A6       981               Lr2: mov R0, #166
080D D8FE       982               Lr1: djnz R0, Lr1 ; 3 cycles->3*45.21123ns*166=22.51519us
080F D9FA       983               djnz R1, Lr2 ; 22.51519us*250=5.629ms
0811 DAF6       984               djnz R2, Lr3 ; 5.629ms*89=0.5s (approximately)
0813 22         985               ret
0814            986            
0814            987   
0814            988   ;convert:
0814            989       ;    mov x+0, Result
0814            990       ;    mov x+1, Result+1 
0814            991       ;    mov x+2, #0
0814            992       ;    mov x+3, #0
0814            993       ;    ret
0814            994       ;    
0814            995       ;
0814            996   ;config_adc:
0814            997       ;        clr CE_ADC 
0814            998       ;        mov R0, #00000001B; Start bit:1 
0814            999       ;        lcall DO_SPI_G
0814           1000       ;
0814           1001       ;        mov R0, #10000000B; Single ended, read channel 0 
0814           1002       ;        lcall DO_SPI_G 
0814           1003       ;        mov a, R1          ; R1 contains bits 8 and 9 
0814           1004       ;        anl a, #00000011B  ; We need only the two least significant bits 
0814           1005       ;        mov Result+1, a    ; Save result high.
0814           1006       ;
0814           1007       ;        mov R0, #55H; It doesn't matter what we transmit... 
0814           1008       ;        lcall DO_SPI_G 
0814           1009       ;        mov Result, R1     ; R1 contains bits 0 to 7.  Save result low. 
0814           1010       ;        setb CE_ADC 
0814           1011       ;        lcall convert  
0814           1012       ;        mov a, bcd ; move temp to accumulator 
0814           1013       ;        ret
0814           1014   Display_temp:
0814           1015       ;    Load_y(410)
0814           1016       ;    lcall mul32
0814           1017       ;    Load_y(1023)
0814           1018       ;    lcall div32
0814           1019       ;    Load_y(273)
0814           1020       ;    lcall sub32
0814           1021       ;    lcall hex2bcd
0814           1022       ;    lcall InitSerialPort
0814 C0E0      1023            push acc
0816 7401      1023            mov a, #1
0818 14        1023            dec a
0819 120368    1023            lcall ?Set_Cursor_1 ; Select column and row
081C D0E0      1023            pop acc
081E C083      1024            push dph
0820 C082      1024            push dpl
0822 C0E0      1024            push acc
0824 9003FA    1024            mov dptr, #Temp0
0827 12035B    1024            lcall ?Send_Constant_String
082A D0E0      1024            pop acc
082C D082      1024            pop dpl
082E D083      1024            pop dph
0830           1025       ;    lcall SendString
0830           1026       ;    Set_Cursor(1, 5)    
0830           1027       ;    Send_BCD(bcd+1) ; send fisrt 2 digits to putty
0830           1028       ;    Display_BCD(bcd+1); send fisrt 2 digits to lcd
0830           1029       ;    Set_Cursor(1, 7) 
0830           1030       ;    Send_BCD(bcd) ; send last 2 digits to putty
0830           1031       ;    Display_BCD(bcd+0) ; send last 2 digits to lcd
0830           1032       ;    Set_Cursor(1, 5)
0830           1033       ;    Send_Constant_String(#dots)
0830           1034       ;    lcall SendString
0830           1035       ;    mov DPTR, #Newline
0830           1036       ;    lcall SendString
0830 22        1037     ret
0831           1038   
0831           1039   Reset_timer:
0831           1040   
0831 C28E      1041       clr TR1                 ; Stop timer 2
0833 E4        1042       clr a
0834 754700    1043            mov Count10ms, #0x00
0837           1044            ; Now clear the BCD counter and minutes
0837 F541      1045            mov BCD_counter, a
0839 D28E      1046            setb TR1                ; Start timer 2
083B           1047   
083B 22        1048       ret
083C           1049   Display_time:
083C C0E0      1050            push acc
083E 7401      1050            mov a, #1
0840 14        1050            dec a
0841 120366    1050            lcall ?Set_Cursor_2 ; Select column and row
0844 D0E0      1050            pop acc
0846 C083      1051            push dph
0848 C082      1051            push dpl
084A C0E0      1051            push acc
084C 90040B    1051            mov dptr, #Time
084F 12035B    1051            lcall ?Send_Constant_String
0852 D0E0      1051            pop acc
0854 D082      1051            pop dpl
0856 D083      1051            pop dph
0858 C203      1052       clr half_seconds_flag ; We clear this flag in the main loop, but it is set in the ISR for timer 2
085A C20C      1053       clr my_flag
085C C0E0      1054            push acc
085E 7409      1054            mov a, #9
0860 14        1054            dec a
0861 120366    1054            lcall ?Set_Cursor_2 ; Select column and row
0864 D0E0      1054            pop acc     ; the place in the LCD where we want the BCD counter value
0866 C000      1055            push ar0
0868 A841      1055            mov r0, BCD_counter
086A 12036D    1055            lcall ?Display_BCD
086D D000      1055            pop ar0 ; This macro is also in 'LCD_4bit.inc'
086F C0E0      1056            push acc
0871 7406      1056            mov a, #6
0873 14        1056            dec a
0874 120366    1056            lcall ?Set_Cursor_2 ; Select column and row
0877 D0E0      1056            pop acc     ; the place in the LCD where we want the BCD counter value
0879 C000      1057            push ar0
087B A84C      1057            mov r0, minutes
087D 12036D    1057            lcall ?Display_BCD
0880 D000      1057            pop ar0 ; This macro is also in 'LCD_4bit.inc'
0882           1058   
0882 22        1059       ret
0883           1060   ;;Timer couter 
0883           1061       sec_counter: 
0883 E541      1062           mov a,BCD_counter
0885 B4600A    1063           cjne a, #0x60, Continue1 ; check if the couter reached 60s
0888 E54C      1064           mov a, minutes
088A 2401      1065           add a, #0x01 ; add one to the minutes
088C D4        1066           da a ; Decimal adjust instruction.  Check datasheet for more details!
088D F54C      1067           mov minutes, a
088F 120831    1068           lcall Reset_timer
0892           1069                Continue1:
0892 22        1070           ret
0893           1071       min_counter:
0893 E54C      1072                    mov a,minutes
0895 B4600A    1073                    cjne a, #0x60, Continue2
0898 C28E      1074                    clr TR1                 ; Stop timer 2
089A E4        1075                    clr a                   
089B 754700    1076                    mov Count10ms, #0x00      ; Now clear the BCD counter
089E F54C      1077                    mov minutes, a              ; Reset minutes
08A0 D28E      1078           setb TR1                ; Start timer 2
08A2           1079   
08A2           1080                    Continue2:
08A2 22        1081           ret
08A3           1082   home_page:
08A3           1083       ; Press Button 2.7 to clean the time
08A3           1084      ; jb P2.7, continue20
08A3           1085      ; Wait_Milli_Seconds(#50) ; debounce
08A3           1086      ; jb P2.7, continue20
08A3           1087      ; jnb p2.7, $
08A3           1088      ;;clr TR1 
08A3           1089      ; mov state , #0
08A3           1090      ; mov BCD_counter, #0x00
08A3           1091      ; mov minutes, #0x0   
08A3           1092      ; lcall Display_time
08A3           1093   
08A3           1094      continue20:
08A3           1095       ;--------Timer----------;
08A3           1096   
08A3 300309    1097       jnb half_seconds_flag, Temp_sensor
08A6 120883    1098       lcall sec_counter
08A9 120893    1099       lcall min_counter
08AC 12083C    1100       lcall Display_time
08AF           1101   
08AF           1102       ;-----------------------;
08AF           1103   
08AF           1104       ;-----TEMP SENSOR-------;
08AF           1105       Temp_sensor:
08AF           1106    ;    lcall config_adc
08AF 120814    1107       lcall Display_temp
08B2           1108    ;    lcall  WaitHalfSec 
08B2           1109    ;    ;-----------------------;
08B2           1110   
08B2           1111   
08B2           1112   
08B2           1113   
08B2 22        1114       ret
08B3           1115   
08B3           1116   setup_reflow_page:
08B3 20A211    1117            jb set_BUTTON, continue9
08B6 C002      1117            push AR2
08B8 7A0A      1117            mov R2, #10
08BA 1202D7    1117            lcall ?Wait_Milli_Seconds
08BD D002      1117            pop AR2
08BF 20A205    1117            jb set_BUTTON, continue9
08C2 30A2FD    1117            jnb set_BUTTON, $
08C5           1117   
08C5 B209      1118       cpl tt_reflow_flag
08C7           1119       continue9:
08C7           1120   
08C7 200906    1121       jb tt_reflow_flag, jump1
08CA           1122       ;jnb tt_reflow_flag, jump1
08CA 1209AC    1123       lcall INC_DEC_Reflow_time
08CD 0208D3    1124       ljmp display_reflow_page
08D0           1125       jump1:
08D0 1209F4    1126       lcall INC_DEC_Reflow_temp
08D3           1127   
08D3           1128   
08D3           1129       display_reflow_page:
08D3 C0E0      1130            push acc
08D5 7405      1130            mov a, #5
08D7 14        1130            dec a
08D8 120368    1130            lcall ?Set_Cursor_1 ; Select column and row
08DB D0E0      1130            pop acc
08DD C000      1131            push ar0
08DF A83C      1131            mov r0, reflow_temp+0
08E1 12036D    1131            lcall ?Display_BCD
08E4 D000      1131            pop ar0
08E6 C0E0      1132            push acc
08E8 7407      1132            mov a, #7
08EA 14        1132            dec a
08EB 120368    1132            lcall ?Set_Cursor_1 ; Select column and row
08EE D0E0      1132            pop acc
08F0 C000      1133            push ar0
08F2 A83D      1133            mov r0, reflow_temp+1
08F4 12036D    1133            lcall ?Display_BCD
08F7 D000      1133            pop ar0
08F9           1134          
08F9           1135       
08F9 C0E0      1136            push acc
08FB 7401      1136            mov a, #1
08FD 14        1136            dec a
08FE 120368    1136            lcall ?Set_Cursor_1 ; Select column and row
0901 D0E0      1136            pop acc
0903 C083      1137            push dph
0905 C082      1137            push dpl
0907 C0E0      1137            push acc
0909 90042D    1137            mov dptr, #reflow_setup
090C 12035B    1137            lcall ?Send_Constant_String
090F D0E0      1137            pop acc
0911 D082      1137            pop dpl
0913 D083      1137            pop dph
0915 C0E0      1138            push acc
0917 7409      1138            mov a, #9
0919 14        1138            dec a
091A 120368    1138            lcall ?Set_Cursor_1 ; Select column and row
091D D0E0      1138            pop acc
091F C083      1139            push dph
0921 C082      1139            push dpl
0923 C0E0      1139            push acc
0925 900432    1139            mov dptr, #reflow_setup4
0928 12035B    1139            lcall ?Send_Constant_String
092B D0E0      1139            pop acc
092D D082      1139            pop dpl
092F D083      1139            pop dph
0931           1140   
0931 C0E0      1141            push acc
0933 7401      1141            mov a, #1
0935 14        1141            dec a
0936 120366    1141            lcall ?Set_Cursor_2 ; Select column and row
0939 D0E0      1141            pop acc
093B C083      1142            push dph
093D C082      1142            push dpl
093F C0E0      1142            push acc
0941 90043B    1142            mov dptr, #reflow_setup2
0944 12035B    1142            lcall ?Send_Constant_String
0947 D0E0      1142            pop acc
0949 D082      1142            pop dpl
094B D083      1142            pop dph
094D C0E0      1143            push acc
094F 7408      1143            mov a, #8
0951 14        1143            dec a
0952 120366    1143            lcall ?Set_Cursor_2 ; Select column and row
0955 D0E0      1143            pop acc
0957 C083      1144            push dph
0959 C082      1144            push dpl
095B C0E0      1144            push acc
095D 9003E0    1144            mov dptr, #dots
0960 12035B    1144            lcall ?Send_Constant_String
0963 D0E0      1144            pop acc
0965 D082      1144            pop dpl
0967 D083      1144            pop dph
0969 C0E0      1145            push acc
096B 740C      1145            mov a, #12
096D 14        1145            dec a
096E 120366    1145            lcall ?Set_Cursor_2 ; Select column and row
0971 D0E0      1145            pop acc
0973 C083      1146            push dph
0975 C082      1146            push dpl
0977 C0E0      1146            push acc
0979 900440    1146            mov dptr, #reflow_setup3
097C 12035B    1146            lcall ?Send_Constant_String
097F D0E0      1146            pop acc
0981 D082      1146            pop dpl
0983 D083      1146            pop dph
0985 C0E0      1147            push acc
0987 7409      1147            mov a, #9
0989 14        1147            dec a
098A 120366    1147            lcall ?Set_Cursor_2 ; Select column and row
098D D0E0      1147            pop acc
098F C000      1148            push ar0
0991 A843      1148            mov r0, reflow_sec
0993 12036D    1148            lcall ?Display_BCD
0996 D000      1148            pop ar0
0998 C0E0      1149            push acc
099A 7406      1149            mov a, #6
099C 14        1149            dec a
099D 120366    1149            lcall ?Set_Cursor_2 ; Select column and row
09A0 D0E0      1149            pop acc
09A2 C000      1150            push ar0
09A4 A844      1150            mov r0, reflow_min
09A6 12036D    1150            lcall ?Display_BCD
09A9 D000      1150            pop ar0
09AB           1151   
09AB 22        1152       ret
09AC           1153       INC_DEC_Reflow_time:
09AC           1154   
09AC 20A124    1155            jb SETUP_SOAK_Button, check_decrement
09AF C002      1155            push AR2
09B1 7A0A      1155            mov R2, #10
09B3 1202D7    1155            lcall ?Wait_Milli_Seconds
09B6 D002      1155            pop AR2
09B8 20A118    1155            jb SETUP_SOAK_Button, check_decrement
09BB 30A1FD    1155            jnb SETUP_SOAK_Button, $
09BE           1155    ; setup soak is also used to increment 
09BE           1156   
09BE E543      1157           mov a, reflow_sec
09C0 B4590B    1158           cjne a, #0x59, add_reflow_sec
09C3 E544      1159           mov a, reflow_min
09C5 2401      1160           add a, #0x01
09C7 D4        1161           da a
09C8 F544      1162           mov reflow_min, a
09CA E4        1163           clr a 
09CB 0209D1    1164           ljmp Continue5
09CE           1165           add_reflow_sec:
09CE 2401      1166           add a, #0x01
09D0 D4        1167           da a ; Decimal adjust instruction.  Check datasheet for more details!
09D1           1168           Continue5:
09D1 F543      1169           mov reflow_sec, a
09D3           1170   
09D3           1171           check_decrement:
09D3 20A01D    1172            jb Button_min, continue8
09D6 C002      1172            push AR2
09D8 7A0A      1172            mov R2, #10
09DA 1202D7    1172            lcall ?Wait_Milli_Seconds
09DD D002      1172            pop AR2
09DF 20A011    1172            jb Button_min, continue8
09E2 30A0FD    1172            jnb Button_min, $
09E5           1172   
09E5 E543      1173           mov a, reflow_sec
09E7 B40004    1174           cjne a, #0x00, sub_reflow_sec
09EA E4        1175           clr a 
09EB 0209F1    1176           ljmp Continue6
09EE           1177           sub_reflow_sec:
09EE 2499      1178           add a, #0x99 ; add 99 reduces 1
09F0 D4        1179           da a ; Decimal adjust instruction.  Check datasheet for more details!
09F1           1180           Continue6:
09F1 F543      1181           mov reflow_sec, a
09F3           1182           continue8:
09F3 22        1183           ret
09F4           1184       INC_DEC_Reflow_temp:
09F4           1185   
09F4 20A121    1186            jb SETUP_SOAK_Button, check_decrement2
09F7 C002      1186            push AR2
09F9 7A0A      1186            mov R2, #10
09FB 1202D7    1186            lcall ?Wait_Milli_Seconds
09FE D002      1186            pop AR2
0A00 20A115    1186            jb SETUP_SOAK_Button, check_decrement2
0A03 30A1FD    1186            jnb SETUP_SOAK_Button, $
0A06           1186    ; SET UP IS ALSO USED TO INCREMENT 
0A06 E53D      1187               mov a, reflow_temp+1
0A08 2401      1188               add a, #0x01
0A0A D4        1189               da a ; Decimal adjust instruction.  Check datasheet for more details!
0A0B F53D      1190               mov reflow_temp+1, a
0A0D E53D      1191               mov a, reflow_temp+1
0A0F 7007      1192               jnz INC_reflow_temp_done2
0A11 E53C      1193               mov a, reflow_temp+0
0A13 2401      1194               add a, #0x01
0A15 D4        1195               da a ; Decimal adjust instruction.  Check datasheet for more details!
0A16 F53C      1196               mov reflow_temp+0, a
0A18           1197               INC_reflow_temp_done2:
0A18           1198               
0A18           1199           hold_done:
0A18           1200           
0A18           1201   
0A18           1202   
0A18           1203           check_decrement2:
0A18           1204   
0A18 20A021    1205            jb Button_min, DEC_reflow_temp_done2
0A1B C002      1205            push AR2
0A1D 7A0A      1205            mov R2, #10
0A1F 1202D7    1205            lcall ?Wait_Milli_Seconds
0A22 D002      1205            pop AR2
0A24 20A015    1205            jb Button_min, DEC_reflow_temp_done2
0A27 30A0FD    1205            jnb Button_min, $
0A2A           1205   
0A2A           1206            ;   jb Button_min, DEC_reflow_temp_done2  
0A2A           1207            ;       Wait_Milli_Seconds(#50)         
0A2A           1208            ;   jb Button_min, DEC_reflow_temp_done2  
0A2A           1209            ;   loop_hold_dec:
0A2A           1210   
0A2A           1211            ;   jnb Button_min, jump3
0A2A           1212            ;   ljmp DEC_reflow_temp_done2
0A2A           1213            ;   jump3:
0A2A           1214            ;   Set_Cursor(1, 5)
0A2A           1215            ;   Display_BCD(reflow_temp+0)
0A2A           1216            ;   Set_Cursor(1, 7)
0A2A           1217            ;   Display_BCD(reflow_temp+1)
0A2A           1218            ;   Wait_Milli_Seconds(#100)    
0A2A E53D      1219               mov a, reflow_temp+1
0A2C 2499      1220               add a, #0x99
0A2E D4        1221               da a ; Decimal adjust instruction.  Check datasheet for more details!
0A2F F53D      1222               mov reflow_temp+1, a
0A31 E53D      1223               mov a, reflow_temp+1
0A33 7007      1224               jnz INC_reflow_temp_done
0A35 E53C      1225               mov a, reflow_temp+0
0A37 2499      1226               add a, #0x99
0A39 D4        1227               da a ; Decimal adjust instruction.  Check datasheet for more details!
0A3A F53C      1228               mov reflow_temp+0, a
0A3C           1229             ;  mov a, reflow_temp+1
0A3C           1230               INC_reflow_temp_done:
0A3C           1231               
0A3C           1232             ;  ljmp loop_hold_dec
0A3C           1233   
0A3C           1234           DEC_reflow_temp_done2:
0A3C           1235       
0A3C           1236   
0A3C 22        1237       ret
0A3D           1238   setup_soak_page:
0A3D 20A211    1239            jb set_BUTTON, continue11
0A40 C002      1239            push AR2
0A42 7A0A      1239            mov R2, #10
0A44 1202D7    1239            lcall ?Wait_Milli_Seconds
0A47 D002      1239            pop AR2
0A49 20A205    1239            jb set_BUTTON, continue11
0A4C 30A2FD    1239            jnb set_BUTTON, $
0A4F           1239   
0A4F B20A      1240       cpl tt_flag_soak
0A51           1241       continue11:
0A51           1242   
0A51 200A06    1243       jb tt_flag_soak, jump4
0A54 120B36    1244       lcall INC_DEC_soak_time
0A57 020A5D    1245       ljmp display_soak_page
0A5A           1246       jump4:
0A5A 120B7E    1247       lcall INC_DEC_soak_temp
0A5D           1248   
0A5D           1249   
0A5D           1250       display_soak_page:
0A5D C0E0      1251            push acc
0A5F 7405      1251            mov a, #5
0A61 14        1251            dec a
0A62 120368    1251            lcall ?Set_Cursor_1 ; Select column and row
0A65 D0E0      1251            pop acc
0A67 C000      1252            push ar0
0A69 A83E      1252            mov r0, soak_temp+0
0A6B 12036D    1252            lcall ?Display_BCD
0A6E D000      1252            pop ar0
0A70 C0E0      1253            push acc
0A72 7407      1253            mov a, #7
0A74 14        1253            dec a
0A75 120368    1253            lcall ?Set_Cursor_1 ; Select column and row
0A78 D0E0      1253            pop acc
0A7A C000      1254            push ar0
0A7C A83F      1254            mov r0, soak_temp+1
0A7E 12036D    1254            lcall ?Display_BCD
0A81 D000      1254            pop ar0
0A83           1255          
0A83           1256       
0A83 C0E0      1257            push acc
0A85 7401      1257            mov a, #1
0A87 14        1257            dec a
0A88 120368    1257            lcall ?Set_Cursor_1 ; Select column and row
0A8B D0E0      1257            pop acc
0A8D C083      1258            push dph
0A8F C082      1258            push dpl
0A91 C0E0      1258            push acc
0A93 900445    1258            mov dptr, #soak_setup0
0A96 12035B    1258            lcall ?Send_Constant_String
0A99 D0E0      1258            pop acc
0A9B D082      1258            pop dpl
0A9D D083      1258            pop dph
0A9F C0E0      1259            push acc
0AA1 7409      1259            mov a, #9
0AA3 14        1259            dec a
0AA4 120368    1259            lcall ?Set_Cursor_1 ; Select column and row
0AA7 D0E0      1259            pop acc
0AA9           1259   
0AA9 C083      1260            push dph
0AAB C082      1260            push dpl
0AAD C0E0      1260            push acc
0AAF 90044A    1260            mov dptr, #soak_setup1
0AB2 12035B    1260            lcall ?Send_Constant_String
0AB5 D0E0      1260            pop acc
0AB7 D082      1260            pop dpl
0AB9 D083      1260            pop dph
0ABB           1261   
0ABB C0E0      1262            push acc
0ABD 7401      1262            mov a, #1
0ABF 14        1262            dec a
0AC0 120366    1262            lcall ?Set_Cursor_2 ; Select column and row
0AC3 D0E0      1262            pop acc
0AC5           1262   
0AC5 C083      1263            push dph
0AC7 C082      1263            push dpl
0AC9 C0E0      1263            push acc
0ACB 900452    1263            mov dptr, #soak_setup2
0ACE 12035B    1263            lcall ?Send_Constant_String
0AD1 D0E0      1263            pop acc
0AD3 D082      1263            pop dpl
0AD5 D083      1263            pop dph
0AD7 C0E0      1264            push acc
0AD9 7408      1264            mov a, #8
0ADB 14        1264            dec a
0ADC 120366    1264            lcall ?Set_Cursor_2 ; Select column and row
0ADF D0E0      1264            pop acc
0AE1           1264   
0AE1 C083      1265            push dph
0AE3 C082      1265            push dpl
0AE5 C0E0      1265            push acc
0AE7 9003E0    1265            mov dptr, #dots
0AEA 12035B    1265            lcall ?Send_Constant_String
0AED D0E0      1265            pop acc
0AEF D082      1265            pop dpl
0AF1 D083      1265            pop dph
0AF3 C0E0      1266            push acc
0AF5 740C      1266            mov a, #12
0AF7 14        1266            dec a
0AF8 120366    1266            lcall ?Set_Cursor_2 ; Select column and row
0AFB D0E0      1266            pop acc
0AFD C083      1267            push dph
0AFF C082      1267            push dpl
0B01 C0E0      1267            push acc
0B03 900457    1267            mov dptr, #soak_setup3
0B06 12035B    1267            lcall ?Send_Constant_String
0B09 D0E0      1267            pop acc
0B0B D082      1267            pop dpl
0B0D D083      1267            pop dph
0B0F C0E0      1268            push acc
0B11 7409      1268            mov a, #9
0B13 14        1268            dec a
0B14 120366    1268            lcall ?Set_Cursor_2 ; Select column and row
0B17 D0E0      1268            pop acc
0B19           1268   
0B19 C000      1269            push ar0
0B1B A845      1269            mov r0, soak_sec
0B1D 12036D    1269            lcall ?Display_BCD
0B20 D000      1269            pop ar0
0B22 C0E0      1270            push acc
0B24 7406      1270            mov a, #6
0B26 14        1270            dec a
0B27 120366    1270            lcall ?Set_Cursor_2 ; Select column and row
0B2A D0E0      1270            pop acc
0B2C C000      1271            push ar0
0B2E A846      1271            mov r0, soak_min
0B30 12036D    1271            lcall ?Display_BCD
0B33 D000      1271            pop ar0
0B35 22        1272       ret
0B36           1273       INC_DEC_soak_time:
0B36           1274       
0B36 20A124    1275            jb SETUP_SOAK_Button, check_decrement_soak
0B39 C002      1275            push AR2
0B3B 7A0A      1275            mov R2, #10
0B3D 1202D7    1275            lcall ?Wait_Milli_Seconds
0B40 D002      1275            pop AR2
0B42 20A118    1275            jb SETUP_SOAK_Button, check_decrement_soak
0B45 30A1FD    1275            jnb SETUP_SOAK_Button, $
0B48           1275    ; setup soak is also used to increment 
0B48           1276   
0B48 E545      1277           mov a, soak_sec
0B4A B4590B    1278           cjne a, #0x59, add_soak_sec
0B4D E546      1279           mov a, soak_min
0B4F 2401      1280           add a, #0x01
0B51 D4        1281           da a
0B52 F546      1282           mov soak_min, a
0B54 E4        1283           clr a 
0B55 020B5B    1284           ljmp Continue12
0B58           1285           add_soak_sec:
0B58 2401      1286           add a, #0x01
0B5A D4        1287           da a ; Decimal adjust instruction.  Check datasheet for more details!
0B5B           1288           Continue12:
0B5B F545      1289           mov soak_sec, a
0B5D           1290   
0B5D           1291           check_decrement_soak:
0B5D 20A01D    1292            jb Button_min, continue13
0B60 C002      1292            push AR2
0B62 7A0A      1292            mov R2, #10
0B64 1202D7    1292            lcall ?Wait_Milli_Seconds
0B67 D002      1292            pop AR2
0B69 20A011    1292            jb Button_min, continue13
0B6C 30A0FD    1292            jnb Button_min, $
0B6F           1292   
0B6F E545      1293           mov a, soak_sec
0B71 B40004    1294           cjne a, #0x00, sub_soak_sec
0B74 E4        1295           clr a 
0B75 020B7B    1296           ljmp Continue14
0B78           1297           sub_soak_sec:
0B78 2499      1298           add a, #0x99 ; add 99 reduces 1
0B7A D4        1299           da a ; Decimal adjust instruction.  Check datasheet for more details!
0B7B           1300           Continue14:
0B7B F545      1301           mov soak_sec, a
0B7D           1302           continue13:
0B7D           1303           
0B7D 22        1304           ret
0B7E           1305       INC_DEC_soak_temp:
0B7E           1306           
0B7E 20A121    1307            jb SETUP_SOAK_Button, check_decrement2_soak
0B81 C002      1307            push AR2
0B83 7A0A      1307            mov R2, #10
0B85 1202D7    1307            lcall ?Wait_Milli_Seconds
0B88 D002      1307            pop AR2
0B8A 20A115    1307            jb SETUP_SOAK_Button, check_decrement2_soak
0B8D 30A1FD    1307            jnb SETUP_SOAK_Button, $
0B90           1307   
0B90           1308           ;    jb SETUP_SOAK_Button, check_decrement2_soak  
0B90           1309           ;        Wait_Milli_Seconds(#50)         
0B90           1310           ;    jb SETUP_SOAK_Button, check_decrement2_soak  
0B90           1311           ;    loop_hold_inc_soak:
0B90           1312         ;
0B90           1313           ;    jnb SETUP_SOAK_Button, jump6
0B90           1314           ;    Wait_Milli_Seconds(#100)
0B90           1315           ;    jnb SETUP_SOAK_Button, jump6
0B90           1316           ;    ljmp hold_done_soak
0B90           1317           ;    jump6:
0B90           1318           ;    Set_Cursor(1, 5)
0B90           1319           ;    Display_BCD(soak_temp+0)
0B90           1320           ;    Set_Cursor(1, 7)
0B90           1321           ;    Display_BCD(soak_temp+1)
0B90           1322           ;    Wait_Milli_Seconds(#200)    
0B90 E53F      1323               mov a, soak_temp+1
0B92 2401      1324               add a, #0x01
0B94 D4        1325               da a ; Decimal adjust instruction.  Check datasheet for more details!
0B95 F53F      1326               mov soak_temp+1, a
0B97 E53F      1327               mov a, soak_temp+1
0B99 7007      1328               jnz INC_soak_temp_done2
0B9B E53E      1329               mov a, soak_temp+0
0B9D 2401      1330               add a, #0x01
0B9F D4        1331               da a ; Decimal adjust instruction.  Check datasheet for more details!
0BA0 F53E      1332               mov soak_temp+0, a
0BA2           1333              ; mov a, soak_temp+1
0BA2           1334               INC_soak_temp_done2:
0BA2           1335               
0BA2           1336             ;  ljmp loop_hold_inc_soak
0BA2           1337           hold_done_soak:
0BA2           1338           
0BA2           1339   
0BA2           1340   
0BA2           1341           check_decrement2_soak:
0BA2           1342   
0BA2 20A021    1343            jb Button_min, DEC_soak_temp_done2
0BA5 C002      1343            push AR2
0BA7 7A0A      1343            mov R2, #10
0BA9 1202D7    1343            lcall ?Wait_Milli_Seconds
0BAC D002      1343            pop AR2
0BAE 20A015    1343            jb Button_min, DEC_soak_temp_done2
0BB1 30A0FD    1343            jnb Button_min, $
0BB4           1343   
0BB4           1344              ; 
0BB4           1345              ; jb Button_min, DEC_soak_temp_done2  
0BB4           1346              ;     Wait_Milli_Seconds(#50)         
0BB4           1347              ; jb Button_min, DEC_soak_temp_done2  
0BB4           1348              ; loop_hold_dec_soak:
0BB4           1349                ;
0BB4           1350              ; jnb Button_min, jump7
0BB4           1351              ; Wait_Milli_Seconds(#100)
0BB4           1352              ; jnb Button_min, jump7
0BB4           1353              ; ljmp DEC_soak_temp_done2
0BB4           1354              ; jump7:
0BB4           1355              ; Set_Cursor(1, 5)
0BB4           1356              ; Display_BCD(soak_temp+0)
0BB4           1357              ; Set_Cursor(1, 7)
0BB4           1358              ; Display_BCD(soak_temp+1)
0BB4           1359              ; Wait_Milli_Seconds(#100)    
0BB4 E53F      1360               mov a, soak_temp+1
0BB6 2499      1361               add a, #0x99
0BB8 D4        1362               da a ; Decimal adjust instruction.  Check datasheet for more details!
0BB9 F53F      1363               mov soak_temp+1, a
0BBB E53F      1364               mov a, soak_temp+1
0BBD 7007      1365               jnz INC_soak_temp_done
0BBF E53E      1366               mov a, soak_temp+0
0BC1 2499      1367               add a, #0x99
0BC3 D4        1368               da a ; Decimal adjust instruction.  Check datasheet for more details!
0BC4 F53E      1369               mov soak_temp+0, a
0BC6           1370             ;  mov a, soak_temp+1
0BC6           1371               INC_soak_temp_done:
0BC6           1372               
0BC6           1373              ; ljmp loop_hold_dec_soak
0BC6           1374   
0BC6           1375           DEC_soak_temp_done2:
0BC6 22        1376           ret
0BC7           1377   second_page:
0BC7 C0E0      1378            push acc
0BC9 7401      1378            mov a, #1
0BCB 14        1378            dec a
0BCC 120368    1378            lcall ?Set_Cursor_1 ; Select column and row
0BCF D0E0      1378            pop acc
0BD1 C083      1379            push dph
0BD3 C082      1379            push dpl
0BD5 C0E0      1379            push acc
0BD7 90041C    1379            mov dptr, #soak_reflw
0BDA 12035B    1379            lcall ?Send_Constant_String
0BDD D0E0      1379            pop acc
0BDF D082      1379            pop dpl
0BE1 D083      1379            pop dph
0BE3 C0E0      1380            push acc
0BE5 7401      1380            mov a, #1
0BE7 14        1380            dec a
0BE8 120366    1380            lcall ?Set_Cursor_2 ; Select column and row
0BEB D0E0      1380            pop acc
0BED C083      1381            push dph
0BEF C082      1381            push dpl
0BF1 C0E0      1381            push acc
0BF3 9003AD    1381            mov dptr, #nothing
0BF6 12035B    1381            lcall ?Send_Constant_String
0BF9 D0E0      1381            pop acc
0BFB D082      1381            pop dpl
0BFD D083      1381            pop dph
0BFF 22        1382       ret
0C00           1383   
0C00           1384   FSM_LCD:
0C00 E535      1385           mov a, state_lcd
0C02           1386   
0C02           1387   
0C02           1388           ;----------------STATE 0------------------;
0C02           1389            home_state:
0C02 B4001E    1390               cjne a, #0, soak_reflow_state
0C05 20A215    1391            jb set_BUTTON, done_home2
0C08 C002      1391            push AR2
0C0A 7A0A      1391            mov R2, #10
0C0C 1202D7    1391            lcall ?Wait_Milli_Seconds
0C0F D002      1391            pop AR2
0C11 20A209    1391            jb set_BUTTON, done_home2
0C14 30A2FD    1391            jnb set_BUTTON, $
0C17           1391     
0C17           1392               ; If pushbutton set_Button is pressed it changes to soak_reflow Page otherwise it stays at the home page
0C17 753501    1393               mov state_lcd, #1
0C1A 020C20    1394               ljmp done_home
0C1D           1395               done_home2:
0C1D 1208A3    1396               lcall home_page
0C20           1397               done_home:
0C20 020CBF    1398               ljmp Forever_done           
0C23           1399           ;------------------------------------------;
0C23           1400           
0C23           1401        ;   ;----------------STATE 1-------------------;
0C23           1402           soak_reflow_state:
0C23 B4014B    1403               cjne a, #1, setup_soak
0C26 120BC7    1404               lcall second_page
0C29           1405             ;  Wait_Milli_Seconds(#50)
0C29 120883    1406               lcall sec_counter ; prevent the timer to go over 60
0C2C 120893    1407               lcall min_counter
0C2F 209712    1408            jb HOME_BUTTON, next_pushb
0C32 C002      1408            push AR2
0C34 7A0A      1408            mov R2, #10
0C36 1202D7    1408            lcall ?Wait_Milli_Seconds
0C39 D002      1408            pop AR2
0C3B 209706    1408            jb HOME_BUTTON, next_pushb
0C3E 3097FD    1408            jnb HOME_BUTTON, $
0C41           1408    ; check if home button is pressed 
0C41 753500    1409               mov state_lcd, #0
0C44           1410               next_pushb:
0C44 20A112    1411            jb SETUP_SOAK_Button, next_pushb2
0C47 C002      1411            push AR2
0C49 7A0A      1411            mov R2, #10
0C4B 1202D7    1411            lcall ?Wait_Milli_Seconds
0C4E D002      1411            pop AR2
0C50 20A106    1411            jb SETUP_SOAK_Button, next_pushb2
0C53 30A1FD    1411            jnb SETUP_SOAK_Button, $
0C56           1411    ; check if the the button to setup soak is pressed
0C56 753502    1412               mov state_lcd, #2
0C59           1413               next_pushb2:
0C59 20A012    1414            jb Button_min, done_soak
0C5C C002      1414            push AR2
0C5E 7A0A      1414            mov R2, #10
0C60 1202D7    1414            lcall ?Wait_Milli_Seconds
0C63 D002      1414            pop AR2
0C65 20A006    1414            jb Button_min, done_soak
0C68 30A0FD    1414            jnb Button_min, $
0C6B           1414    ; check if the buttion to setup the reflow was pressed 
0C6B 753503    1415               mov state_lcd, #3
0C6E           1416               done_soak:
0C6E 020CBF    1417              ljmp Forever_done 
0C71           1418           ;------------------------------------------;
0C71           1419   
0C71           1420        ;   ;-----------------STATE 2------------------;
0C71           1421           setup_soak: ; its actually set up reflow Im dumb
0C71 B40221    1422               cjne a, #2, setup_reflow
0C74 1208B3    1423               lcall setup_reflow_page
0C77           1424             ;  Wait_Milli_Seconds(#50)
0C77 120883    1425               lcall sec_counter ; prevent the timer to go over 60
0C7A 120893    1426               lcall min_counter
0C7D 209712    1427            jb HOME_BUTTON, done_setup_soak
0C80 C002      1427            push AR2
0C82 7A0A      1427            mov R2, #10
0C84 1202D7    1427            lcall ?Wait_Milli_Seconds
0C87 D002      1427            pop AR2
0C89 209706    1427            jb HOME_BUTTON, done_setup_soak
0C8C 3097FD    1427            jnb HOME_BUTTON, $
0C8F           1427    ; check if home button is pressed 
0C8F 753500    1428               mov state_lcd, #0
0C92           1429               done_setup_soak:
0C92 020CBF    1430               ljmp Forever_done 
0C95           1431           ;------------------------------------------;
0C95           1432   
0C95           1433        ;   ;----------------STATE 3-------------------;
0C95           1434           setup_reflow: ; its actually set up soak Im dumb
0C95 B40303    1435               cjne a, #3, FDP
0C98 020C9E    1436               ljmp FDP2
0C9B           1437               FDP:
0C9B 020C02    1438               ljmp home_state
0C9E           1439               FDP2:
0C9E 120A3D    1440               lcall setup_soak_page
0CA1 120883    1441               lcall sec_counter ; prevent the timer to go over 60
0CA4 120893    1442               lcall min_counter
0CA7 209712    1443            jb HOME_BUTTON, done_setup_reflow
0CAA C002      1443            push AR2
0CAC 7A0A      1443            mov R2, #10
0CAE 1202D7    1443            lcall ?Wait_Milli_Seconds
0CB1 D002      1443            pop AR2
0CB3 209706    1443            jb HOME_BUTTON, done_setup_reflow
0CB6 3097FD    1443            jnb HOME_BUTTON, $
0CB9           1443    ; check if home button is pressed 
0CB9 753500    1444               mov state_lcd, #0
0CBC           1445               done_setup_reflow:
0CBC 020CBF    1446               ljmp Forever_done 
0CBF           1447        ;   ;------------------------------------------;
0CBF           1448           Forever_done:
0CBF 22        1449    ret
0CC0           1450   
0CC0           1451   ;---------------------------------;
0CC0           1452   ; Main program. Includes hardware ;
0CC0           1453   ; initialization and 'forever'    ;
0CC0           1454   ; loop.                           ;
0CC0           1455   ;---------------------------------;
0CC0           1456   main:
0CC0           1457            ; Initialization
0CC0 75817F    1458       mov SP, #0x7F
0CC3 12046D    1459       lcall Timer0_Init
0CC6 120498    1460       lcall Timer1_Init
0CC9 120689    1461       lcall InitSerialPort
0CCC           1462   
0CCC 120530    1463       lcall Ports_Init ; Default all pins as bidirectional I/O. See Table 42.
0CCF 120326    1464       lcall LCD_4BIT
0CD2 120559    1465       lcall Double_Clk
0CD5 120549    1466            lcall InitDAC1 ; Call after 'Ports_Init'
0CD8 1204EA    1467            lcall CCU_Init
0CDB 120561    1468            lcall Init_SPI
0CDE           1469            
0CDE           1470            
0CDE D2AF      1471            setb EA ; Enable global interrupts.
0CE0           1472   
0CE0           1473            ; Initialize variables
0CE0 C200      1474            clr T2S_FSM_Start
0CE2 754E00    1475            mov T2S_FSM_state, #0
0CE5           1476       ; Configure all the ports in bidirectional mode:
0CE5           1477   
0CE5 758400    1478       mov P0M1, #00H
0CE8 758500    1479       mov P0M2, #00H
0CEB 759100    1480       mov P1M1, #00H
0CEE 759200    1481       mov P1M2, #00H ; WARNING: P1.2 and P1.3 need 1kohm pull-up resistors!
0CF1 75A400    1482       mov P2M1, #00H
0CF4 75A500    1483       mov P2M2, #00H
0CF7 75B100    1484       mov P3M1, #00H
0CFA 75B200    1485       mov P3M2, #00H
0CFD           1486       
0CFD           1487       ;mov minutes, #0
0CFD 754D00    1488            mov seconds, #0
0D00           1489   
0D00           1490      ; lcall LCD_4BIT
0D00           1491       ; For convenience a few handy macros are included in 'LCD_4bit_LPC9351.inc':
0D00           1492    ;       Set_Cursor(1, 1)
0D00           1493     ;  Display_BCD(BCD_counter)
0D00           1494   
0D00 D203      1495       setb half_seconds_flag
0D02 D20C      1496       setb my_flag   
0D04           1497   
0D04 754100    1498            mov BCD_counter, #0x00
0D07 753900    1499            mov pwm , #0
0D0A 753700    1500            mov sec , #0
0D0D 753400    1501            mov state, #0
0D10 753696    1502            mov temp, #150
0D13 753105    1503       mov time_soak, #5
0D16 7532DC    1504       mov temp_refl, #220
0D19 753005    1505       mov temp_soak, #5
0D1C 755000    1506       mov five_sec_flag,#0
0D1F           1507            ; After initialization the program stays in this 'forever' loop
0D1F           1508   
0D1F 754300    1509       mov reflow_sec, #0x00
0D22 754400    1510       mov reflow_min, #0x00
0D25 754C00    1511       mov minutes, #0x00
0D28 753500    1512       mov state_lcd, #0
0D2B C208      1513       clr TR1_flag
0D2D 753C01    1514       mov reflow_temp+0, #0x01
0D30 753D50    1515       mov reflow_temp+1, #0x50
0D33 C209      1516       clr tt_reflow_flag
0D35 754500    1517       mov soak_sec, #0x00
0D38 754600    1518       mov soak_min, #0x00
0D3B           1519   
0D3B 753E01    1520       mov soak_temp+0, #0x01
0D3E 753F50    1521       mov soak_temp+1, #0x50
0D41 C20B      1522       clr stop_flag
0D43           1523   
0D43           1524       
0D43           1525   forever:         
0D43 120C00    1526       lcall FSM_LCD
0D46           1527   
0D46 120723    1528       lcall T2S_FSM ; Speaker fsm
0D49           1529   
0D49           1530     Check_if_stop_button_is_on:
0D49           1531      ; jb P2.6, continue19 
0D49           1532            ;Wait_Milli_Seconds(#50) ; debounce
0D49           1533            ;jb P2.6, continue19
0D49           1534            ;jnb P2.6, $
0D49           1535            ;clr TR1 
0D49           1536            ;ljmp forever
0D49           1537      ;continue19:
0D49           1538   
0D49           1539    FSM_PWM:  
0D49 E534      1540       mov a, state
0D4B           1541     state0: 
0D4B B40013    1542         cjne a, #0, state1
0D4E 753900    1543         mov pwm, #0
0D51 C28E      1544         clr TR1
0D53 20B008    1545         jb p3.0, state0_done
0D56 30B0FD    1546         jnb p3.0, $ ;wait for key release
0D59 D28E      1547         setb TR1
0D5B 753401    1548         mov state, #1
0D5E           1549     state0_done:
0D5E 020D43    1550         ljmp forever
0D61           1551      
0D61           1552      state1:
0D61 B40113    1553         cjne a, #1 , state2
0D64 753964    1554         mov pwm, #100
0D67 753700    1555         mov sec, #0
0D6A E530      1556         mov a, temp_soak
0D6C C3        1557         clr c
0D6D 9536      1558         subb a, temp
0D6F           1559         ;add branches to compare temp with 150
0D6F 5003      1560         jnc state1_done
0D71 753402    1561         mov state, #2
0D74           1562     state1_done:
0D74 020D43    1563          ljmp forever
0D77           1564          
0D77           1565     state2: ;press p3.0 multiple time plz cos it is stuck
0D77 B40210    1566         cjne a, #2 , state3
0D7A 753914    1567         mov pwm, #20
0D7D E531      1568         mov a, time_soak
0D7F C3        1569         clr c
0D80 9537      1570         subb a, sec
0D82           1571         ;add branches to compare sec with  60
0D82 5003      1572         jnc state2_done
0D84 753403    1573         mov state, #3
0D87           1574     state2_done:
0D87 020D43    1575          ljmp forever          
0D8A           1576     
0D8A           1577     state3:
0D8A B40313    1578         cjne a, #3 , state4
0D8D 753950    1579         mov pwm, #80
0D90 753700    1580         mov sec, #0     
0D93 E532      1581         mov a, temp_refl
0D95 C3        1582         clr c
0D96 9536      1583         subb a, temp
0D98           1584         ;add branches to compare temp with 220
0D98 5003      1585         jnc state3_done
0D9A 753404    1586         mov state, #4
0D9D           1587     state3_done:
0D9D 020D43    1588          ljmp forever
0DA0           1589          
0DA0           1590      state4:
0DA0 B40410    1591         cjne a, #4 , state5
0DA3 753914    1592         mov pwm, #20
0DA6 E533      1593         mov a, time_refl
0DA8 C3        1594         clr c
0DA9 9537      1595         subb a, sec
0DAB           1596         ;add branches to compare sec with 45
0DAB 5003      1597         jnc state4_done
0DAD 753405    1598         mov state, #5
0DB0           1599     state4_done:
0DB0 020D43    1600          ljmp forever    
0DB3           1601          
0DB3           1602      state5:
0DB3 B40595    1603         cjne a, #5 , state0
0DB6 753900    1604         mov pwm, #0
0DB9 C3        1605         clr c
0DBA 9536      1606         subb a, temp
0DBC           1607         ;add branches to compare temp with 60
0DBC 5003      1608         jnc state5_done
0DBE 753400    1609         mov state, #0
0DC1           1610     state5_done:
0DC1 020D43    1611          ljmp forever 
0DC4           1612          
0DC4           1613   
0DC4           1614   EN
