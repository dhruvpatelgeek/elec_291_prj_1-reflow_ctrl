0000              1   ; ISR_example.asm: a) Increments/decrements a BCD variable every half second using
0000              2   ; an ISR for timer 2; b) Generates a 2kHz square wave at pin P3.7 using
0000              3   ; an ISR for timer 0; and c) in the 'main' loop it displays the variable
0000              4   ; incremented/decremented using the ISR for timer 2 on the LCD.  Also resets it to 
0000              5   ; zero if the 'CLEAR' pushbutton connected to P1.7 is pressed.
0000              6   ; Start/Constants
                  8       $LIST
0000             10   
0000             11       CLK           EQU 7373000  ; Microcontroller system crystal frequency in Hz
0000             12       TIMER0_RATE   EQU 100     ; 2048Hz squarewave (peak amplitude of CEM-1203 speaker)
0000             13       TIMER0_RELOAD EQU ((65536-(CLK/(2*TIMER0_RATE))))
0000             14       TIMER1_RATE   EQU 100     ; 100Hz, for a timer tick of 10ms
0000             15       TIMER1_RELOAD EQU ((65536-(CLK/(2*TIMER1_RATE))))
0000             16   
0000             17   
0000             18   
0000             19       CCU_RATE    EQU 11025     ; 22050Hz is the sampling rate of the wav file we are playing
0000             20       CCU_RELOAD  EQU ((65536-((CLK/(2*CCU_RATE)))))
0000             21       BAUD        EQU 115200
0000             22       BRVAL       EQU ((CLK/BAUD)-16)
0000             23   
0000             24   XTAL EQU (14746000/2) 
0000             25   
0000             26   
0000             27   OP_AMP_GAIN EQU 340 ;what is the exact gain?
0000             28   
0000             29       
0000             30   
0000             31       ; Commands supported by the SPI flash memory according to the datasheet
0000             32       WRITE_ENABLE     EQU 0x06  ; Address:0 Dummy:0 Num:0
0000             33       WRITE_DISABLE    EQU 0x04  ; Address:0 Dummy:0 Num:0
0000             34       READ_STATUS      EQU 0x05  ; Address:0 Dummy:0 Num:1 to infinite
0000             35       READ_BYTES       EQU 0x03  ; Address:3 Dummy:0 Num:1 to infinite
0000             36       READ_SILICON_ID  EQU 0xab  ; Address:0 Dummy:3 Num:1 to infinite
0000             37       FAST_READ        EQU 0x0b  ; Address:3 Dummy:1 Num:1 to infinite
0000             38       WRITE_STATUS     EQU 0x01  ; Address:0 Dummy:0 Num:1
0000             39       WRITE_BYTES      EQU 0x02  ; Address:3 Dummy:0 Num:1 to 256
0000             40       ERASE_ALL        EQU 0xc7  ; Address:0 Dummy:0 Num:0
0000             41       ERASE_BLOCK      EQU 0xd8  ; Address:3 Dummy:0 Num:0
0000             42       READ_DEVICE_ID   EQU 0x9f  ; Address:0 Dummy:2 Num:1 to infinite
0000             43   ;Vectors
0000             44       ; Reset vector
0000             45       org 0x0000
0000 020DB2      46           ljmp main
0003             47   
0003             48       ; External interrupt 0 vector (not used in this code)
0003             49       org 0x0003
0003 32          50           reti
0004             51   
0004             52       ; Timer/Counter 0 overflow interrupt vector
000B             53       org 0x000B
000B 02064B      54           ljmp Timer0_ISR
000E             55   
000E             56       ; External interrupt 1 vector (not used in this code)
0013             57       org 0x0013
0013 32          58           reti
0014             59   
0014             60       ; Timer/Counter 1 overflow interrupt vector
001B             61       org 0x001B
001B 020676      62           ljmp Timer1_ISR
001E             63   
001E             64       ; Serial port receive/transmit interrupt vector (not used in this code)
0023             65       org 0x0023 
0023 32          66           reti
0024             67   
005B             68       org 0x005b ; CCU interrupt vector.  Used in this code to replay the wave file.
005B 0206D3      69           ljmp CCU_ISR
005E             70   
005E             71   
005E             72       ;                                                        -                     
005E             73       ;                                                       -  -                    
005E             74       ;                                                      -    -                   
005E             75       ;                              leave it at this temp>>-      -                  
005E             76       ;                                                    -        -                 
005E             77       ;                                                   -          -                 
005E             78       ;                                                  -            -               
005E             79       ;                                                 -              -              
005E             80       ;                                                -                -             
005E             81       ;                                               -                  -            
005E             82       ;                                              -                    -           
005E             83       ;                                             -    reflow>>cool     -          
005E             84       ;               -----------------------------    (temperature only)  -         
005E             85       ;              -     soak (time+temp)                                 -        
005E             86       ;             -                                                        -       
005E             87       ;            -                                                          -       
005E             88       ;          -                                                             -      
005E             89       ;         -                                                               -     
005E             90       ;        -                                                                 -    
005E             91       ;      -                                                                    -    
005E             92       ;     - ramp to soak (temperature)                                           -   
005E             93       ;   -                                                                         -   
005E             94       ;   state 1 ((temp==soak)? ssr_off: ssr_on)
005E             95       ;          state 2 ((time=soak_time)?(pwm_off):(pwn_on)
005E             96       ;                                           state 3 ((temp==soak)? ssr_off: ssr_on)
005E             97       ;                                                        state 4 (cooling ssr_off)
005E             98       ;                                                                             state 5 (done)
005E             99   
005E            100       ; In the 8051 we can define direct access variables starting at location 0x30 up to location 0x7F
005E            101   ;Variables(dseg) 
0030            102      dseg AT 30H
0030            103   ;variables we need
0030            104   x: ds 4
0034            105   y: ds 4
0038            106   Result: ds 2 
003A            107   ch0: ds 2
003C            108   ch1: ds 2
003E            109   oven_temp: ds 2
0040            110   bcd: ds 5
0045            111   
0045            112       
0045            113       ;FSM varialbles
0045            114       temp_soak:       ds 1 ; temp to soak
0046            115       time_soak:       ds 1 ; time to soak
0047            116       temp_refl:       ds 1 ; temp of relfow
0048            117       time_refl:       ds 1 ; time to reflow 
0049            118       state:           ds 1 ; current state 
004A            119       state_lcd:       ds 1
004B            120       temp:            ds 1 ; current temp in degree C
004C            121       sec:             ds 1 ; current time in seconds 
004D            122       product:         ds 1; pwm-currsec
004E            123       pwm:             ds 1 ; 
004F            124   
004F            125       ;Timer variables
004F            126       Count1ms:        ds 2 ; Used to determine when half second has passed
0051            127       reflow_temp:     ds 2
0053            128       soak_temp:       ds 2
0055            129       reflow_time:     ds 2
0057            130       soak_time:       ds 2
0059            131       reflow_temp_var: ds 1
005A            132       BCD_counter:     ds 1 ; The BCD counter incrememted in the ISR and displayed in the main loop
005B            133       hour:            ds 1
005C            134       reflow_sec:      ds 1
005D            135       reflow_min:      ds 1
005E            136       soak_sec:        ds 1
005F            137       soak_min:        ds 1
0060            138       Count10ms:       ds 1 ; Used to determine when half second has passed
0061            139       Count10ms2:      ds 1
0062            140       w:               ds 3 ; 24-bit play counter.  Decremented in CCU ISR.
0065            141       minutes:         ds 1
0066            142       seconds:         ds 1
0067            143       T2S_FSM_state:   ds 1
0068            144       Count5ms:        ds 1
0069            145       five_sec_flag:   ds 1
006A            146   
006A            147   ;flags(bseg)
0000            148       BSEG
0000            149       T2S_FSM_start:     dbit 1
0001            150       seconds_flag:      dbit 1
0002            151       mf:                dbit 1
0003            152       half_seconds_flag: dbit 1 ; Set to one in the ISR every time 500 ms had passed
0004            153       AMPM_flag:         dbit 1
0005            154       alarm_AMPM_flag:   dbit 1
0006            155       on_off_flag:       dbit 1 ; 1 is on
0007            156       alarm_buzzer_flag: dbit 1
0008            157       TR1_flag:          dbit 1
0009            158       tt_reflow_flag:    dbit 1
000A            159       tt_flag_soak:      dbit 1
000B            160       stop_flag:         dbit 1
000C            161       my_flag:           dbit 1
000D            162   
000D            163       ;_ _ _ _ | _ _ _ _ _ _
000D            164       ;
000D            165       ;pwm = 40 (say)
000D            166       ;then output will be 100 
000D            167       ;_________
000D            168       ;         |
000D            169       ;         |_____________
000D            170       ; where period is 1 second 
000D            171       ; In the 8051 we have variables that are 1-bit in size.  We can use the setb, clr, jb, and jnb
000D            172       ; instructions with these variables.  This is how you define a 1-bit variable:
000D            173   
000D            174   ;Pin config(cseg)
000D            175   
005E            176       cseg
005E            177       ; These 'equ' must match the wiring between the microcontroller and the LCD!
005E            178       LCD_RS equ P0.5
005E            179       LCD_RW equ P0.6
005E            180       LCD_E  equ P0.7
005E            181       LCD_D4 equ P1.2
005E            182       LCD_D5 equ P1.3
005E            183       LCD_D6 equ P1.4
005E            184       LCD_D7 equ P1.6
005E            185   
005E            186       CLEAR         equ P3.0
005E            187       FLASH_CE      EQU P2.4
005E            188       SOUND         EQU P2.7
005E            189       
005E            190       SETUP_SOAK_Button equ  P2.1
005E            191       set_BUTTON        equ  P2.0
005E            192       Button_min        equ  P2.6
005E            193       HOME_BUTTON       equ  P2.7
005E            194   
005E            195       ;define the connections between the ADC and MCU (P89 & MCP3008)
005E            196   CE_ADC    EQU  P1.7;P2.4   ;SS
005E            197   MY_MOSI   EQU  P3.1 ;P2.2  ;MOSI
005E            198   MY_MISO   EQU  P0.3   ;MISO
005E            199   MY_SCLK   EQU  P0.2   ;SPICLK
005E            200   
005E            201   ;include files
                546   $LIST
                204   	    $LIST
0399            206   ;Strings
0399            207     ;                       1234567890123456
0399            208      ;General
0399 0D0A00     209       Newline:          db   '\r', '\n', 0
039C 20202020   210       Space:            db   '      ','\r', '\n', 0
     20200D0A
     00
03A5 20202020   211       nothing:          db '                ',0      
     20202020
     20202020
     20202020
     00
03B6 20202020   212       test2:            db '      Test2     ',0
     20205465
     73743220
     20202020
     00
03C7 20202020   213       hot:                           db '      HOT       ', 0
     2020484F
     54202020
     20202020
     00
03D8 3A00       214       dots:             db ':',0
03DA 74696D65   215       timee:            db 'time', 0
     00
03DF 3100       216       statee:           db '1', 0
03E1            217   
03E1 4243445F   218       Initial_Message:  db 'BCD_counter: xx ', 0
     636F756E
     7465723A
     20787820
     00
03F2            219      ;Home page
03F2 54656D70   220       Temp0:            db 'Temp:', 0
     3A00
03F8 4300       221       the_unit_of_temp:            db 'C', 0
03FA 54696D65   222       Time:             db 'Time xx:xx SET  ', 0
     2078783A
     78782053
     45542020
     00
040B            223      ;Second Page
040B 2020534F   224       soak_reflw:       db '  SOAK  REFLOW  ', 0
     414B2020
     5245464C
     4F572020
     00
041C            225      ;Reflow Setup
041C 54656D70   226       reflow_setup:     db 'Temp',0
     00
0421 2A524546   227       reflow_setup4:    db '*REFLOW*',0
     4C4F572A
     00
042A 54696D65   228       reflow_setup2:    db 'Time',0
     00
042F 484F4D45   229       reflow_setup3:    db 'HOME',0
     00
0434            230      ;Soak Setup
0434 54656D70   231       soak_setup0:      db 'Temp',0
     00
0439 202A534F   232       soak_setup1:      db ' *SOAK*',0
     414B2A00
0441 54696D65   233       soak_setup2:      db 'Time            ',0
     20202020
     20202020
     20202020
     00
0452 484F4D45   234       soak_setup3:      db 'HOME',0
     00
0457            235   
0457            236   
0457            237   
0457            238   
0457            239   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0457            240   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0457            241   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0457            242   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0457            243   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0457            244   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0457            245   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0457            246   
0457            247   ; Send a character using the serial port
0457            248   putchar:
0457 109902     249            jbc     TI,putchar_L1
045A 80FB       250            sjmp putchar
045C            251   putchar_L1:
045C F599       252            mov     SBUF,a
045E 22         253            ret
045F            254            
045F            255   getchar:
045F 109802     256            jbc     RI,getchar_L1
0462 80FB       257            sjmp getchar
0464            258   getchar_L1:
0464 E599       259            mov     a,SBUF
0466 22         260            ret     
0467            261       
0467            262   ;approximate delay of 1s
0467            263   Delay:
0467 7AAC       264       mov R2, #86*2
0469 79FA       265   L4: mov R1, #250
046B 78A6       266   L5: mov R0, #166
046D D8FE       267   L6: djnz R0, L6 ; 3 cycles->3*45.21123ns*166=22.51519us
046F D9FA       268       djnz R1, L5 ; 22.51519us*250=5.629ms
0471 DAF6       269       djnz R2, L4 ; 5.629ms*89=0.5s (approximately)
0473 22         270       ret
0474            271   
0474 30313233   272   HexAscii: db '0123456789ABCDEF'
     34353637
     38394142
     43444546
0484            273   
0484            274   
0484            275   SendTemp:
0484 900474     276            mov dptr, #HexAscii 
0487            277            
0487 E541       278            mov a, bcd+1
0489 C4         279            swap a
048A 540F       280            anl a, #0xf
048C 93         281            movc a, @a+dptr
048D 120457     282            lcall putchar
0490 E541       283            mov a, bcd+1
0492 540F       284            anl a, #0xf
0494 93         285            movc a, @a+dptr
0495 120457     286            lcall putchar
0498            287   
0498 742E       288            mov a, #'.'
049A 120457     289            lcall putchar
049D            290   
049D E540       291            mov a, bcd+0
049F C4         292            swap a
04A0 540F       293            anl a, #0xf
04A2 93         294            movc a, @a+dptr
04A3 120457     295            lcall putchar
04A6 E540       296            mov a, bcd+0
04A8 540F       297            anl a, #0xf
04AA 93         298            movc a, @a+dptr
04AB 120457     299            lcall putchar
04AE            300            
04AE 740D       301            mov a, #'\r'
04B0 120457     302            lcall putchar
04B3 740A       303            mov a, #'\n'
04B5 120457     304            lcall putchar   
04B8 22         305            ret    
04B9            306   
04B9            307   SendString:
04B9 E4         308       clr a
04BA 93         309       movc a, @a+dptr
04BB 6006       310       jz SendString_L1
04BD 120457     311       lcall putchar
04C0 A3         312       inc dptr
04C1 80F6       313       sjmp SendString  
04C3            314   SendString_L1:
04C3 22         315            ret
04C4            316       
04C4            317   new_line:
04C4 0D0A00     318         DB '\r' ,'\n', 0     
04C7            319   
04C7            320   
04C7            321   Display_putty:
04C7 854030     322       mov x, bcd
04CA 120484     323       lcall SendTemp
04CD            324       
04CD C0E0       325            push acc
04CF 7405       325            mov a, #5
04D1 14         325            dec a
04D2 120368     325            lcall ?Set_Cursor_1 ; Select column and row
04D5 D0E0       325            pop acc
04D7 C000       326            push ar0
04D9 A841       326            mov r0, bcd+1
04DB 12036D     326            lcall ?Display_BCD
04DE D000       326            pop ar0
04E0 C0E0       327            push acc
04E2 7407       327            mov a, #7
04E4 14         327            dec a
04E5 120368     327            lcall ?Set_Cursor_1 ; Select column and row
04E8 D0E0       327            pop acc
04EA C000       328            push ar0
04EC A840       328            mov r0, bcd+0
04EE 12036D     328            lcall ?Display_BCD
04F1 D000       328            pop ar0
04F3 C0E0       329            push acc
04F5 7408       329            mov a, #8
04F7 14         329            dec a
04F8 120368     329            lcall ?Set_Cursor_1 ; Select column and row
04FB D0E0       329            pop acc
04FD            330   
04FD C0E0       331            push acc
04FF 740A       331            mov a, #10
0501 14         331            dec a
0502 120368     331            lcall ?Set_Cursor_1 ; Select column and row
0505 D0E0       331            pop acc
0507 C083       332            push dph
0509 C082       332            push dpl
050B C0E0       332            push acc
050D 9003F8     332            mov dptr, #the_unit_of_temp
0510 12035B     332            lcall ?Send_Constant_String
0513 D0E0       332            pop acc
0515 D082       332            pop dpl
0517 D083       332            pop dph
0519 22         333            ret   
051A            334   
051A            335   Ports_Init:
051A            336       ; Configure all the ports in bidirectional mode:
051A 758400     337       mov P0M1, #00H
051D 758500     338       mov P0M2, #00H
0520 759100     339       mov P1M1, #00H
0523 759200     340       mov P1M2, #00H ; WARNING: P1.2 and P1.3 need 1 kohm pull-up resistors if used as outputs!
0526 75A400     341       mov P2M1, #00H
0529 75A500     342       mov P2M2, #00H
052C 75B100     343       mov P3M1, #00H
052F 75B200     344       mov P3M2, #00H
0532 22         345            ret
0533            346   
0533            347   ;INITIALIZE AND CONFIGURE THE SERIAL PORT OF THE P89
0533            348   InitSerialPort:
0533            349            ;DEBOUNCING??
0533            350            ; Since the reset button bounces, we need to wait a bit before
0533            351       ; sending messages, otherwise we risk displaying gibberish!
0533            352       ;mov R1, #222
0533            353       ;mov R0, #166
0533            354       ;djnz R0, $   ; 3 cycles->3*45.21123ns*166=22.51519us
0533            355       ;djnz R1, $-4 ; 22.51519us*222=4.998ms
0533            356       ; Now we can proceed with the configuration
0533            357            
0533 75BD00     358            mov     BRGCON,#0x00
0536 75BF00     359            mov     BRGR1,#high(BRVAL)
0539 75BE30     360            mov     BRGR0,#low(BRVAL)
053C 75BD03     361            mov     BRGCON,#0x03 ; Turn-on the baud rate generator
053F 759852     362            mov     SCON,#0x52 ; Serial port in mode 1, ren, txrdy, rxempty
0542 759100     363            mov     P1M1,#0x00 ; Enable pins RxD and TXD
0545 759200     364            mov     P1M2,#0x00 ; Enable pins RxD and TXD
0548 22         365            ret
0549            366            
0549            367   
0549            368   DO_SPI_G:     
0549 C0E0       369            push acc     
054B 7900       370            mov R1, #0      ; Received byte stored in R1     
054D 7A08       371            mov R2, #8      ; Loop counter (8-bits)
054F            372   DO_SPI_G_LOOP:     
054F E8         373            mov a, R0       ; Byte to write is in R0     
0550 33         374            rlc a           ; Carry flag has bit to write     
0551 F8         375            mov R0, a     
0552 92B1       376            mov MY_MOSI, c 
0554 D282       377            setb MY_SCLK    ; Transmit     
0556 A283       378            mov c, MY_MISO  ; Read received bit     
0558 E9         379            mov a, R1       ; Save received bit in R1    
0559 33         380            rlc a 
055A F9         381            mov R1, a     
055B C282       382            clr MY_SCLK     
055D DAF0       383            djnz R2, DO_SPI_G_LOOP     
055F D0E0       384            pop acc     
0561 22         385            ret 
0562            386            
0562            387   ;---------------------------------;
0562            388   ; Send a BCD number to PuTTY      ;
0562            389   ;---------------------------------;
0562            390   
0562            391   hannah:
0562            392            ;read channel 0 of the ADC and transmitting this info to the MCU
0562 C297       393            clr CE_ADC ;enable device (active low)
0564            394            ;transmit the info from channel 0
0564 7801       395            mov R0, #00000001B ;start bit:1
0566 120549     396            lcall DO_SPI_G
0569            397            
0569 7880       398            mov R0, #10000000B ;read channel 0
056B 120549     399            lcall DO_SPI_G
056E E9         400            mov a, R1          ; R1 contains bits 8 and 9 
056F 5403       401            anl a, #00000011B  ; We need only the two least significant bits
0571 F53B       402            mov ch0+1, a    ; Save result high
0573            403            
0573 7855       404            mov R0, #55H   ; It doesn't matter what we transmit... 
0575 120549     405            lcall DO_SPI_G  
0578 893A       406            mov ch0+0, R1     ; R1 contains bits 0 to 7.  Save result low. 
057A D297       407            setb CE_ADC ;disable device
057C            408            
057C C297       409            clr CE_ADC ;enable device
057E            410            ;transmit from channel 1
057E 7801       411            mov R0, #00000001B ;start bit:1
0580 120549     412            lcall DO_SPI_G
0583            413            
0583 7890       414            mov R0, #10010000B ;read channel 1
0585 120549     415            lcall DO_SPI_G
0588 E9         416            mov a, R1          ; R1 contains bits 8 and 9 
0589 5403       417            anl a, #00000011B  ; We need only the two least significant bits
058B F53D       418            mov ch1+1, a    ; Save result high
058D            419            
058D 7855       420            mov R0, #55H   ; It doesn't matter what we transmit... 
058F 120549     421            lcall DO_SPI_G  
0592 893C       422            mov ch1+0, R1     ; R1 contains bits 0 to 7.  Save result low. 
0594 D297       423            setb CE_ADC ;disable device (active low)
0596            424            
0596            425    
0596            426   
0596            427            
0596            428            ;convert the voltage from ch0(LM335) to temperature and display in putty - ch0 correspond to the cold jnc temp
0596 853A30     429            mov x+0, ch0
0599 853B31     430            mov x+1, ch0+1
059C 753200     431            mov x+2, #0
059F 753300     432            mov x+3, #0
05A2            433            
05A2 75349A     434            mov y+0, #low (410 % 0x10000) 
05A5 753501     434            mov y+1, #high(410 % 0x10000) 
05A8 753600     434            mov y+2, #low (410 / 0x10000) 
05AB 753700     434            mov y+3, #high(410 / 0x10000) 
05AE 1201D8     435            lcall mul32
05B1 7534FF     436            mov y+0, #low (1023 % 0x10000) 
05B4 753503     436            mov y+1, #high(1023 % 0x10000) 
05B7 753600     436            mov y+2, #low (1023 / 0x10000) 
05BA 753700     436            mov y+3, #high(1023 / 0x10000) 
05BD 120265     437            lcall div32
05C0 753411     438            mov y+0, #low (273 % 0x10000) 
05C3 753501     438            mov y+1, #high(273 % 0x10000) 
05C6 753600     438            mov y+2, #low (273 / 0x10000) 
05C9 753700     438            mov y+3, #high(273 / 0x10000) 
05CC 120144     439            lcall sub32 
05CF 12005E     440            lcall hex2bcd
05D2            441            ;lcall Display_putty
05D2            442            
05D2            443            ;do the same for ch1(output voltage of OP AMP) - ch1 corresponds to the hot jnc temp
05D2 853C30     444            mov x+0, ch1
05D5 853D31     445            mov x+1, ch1+1
05D8 753200     446            mov x+2, #0
05DB 753300     447            mov x+3, #0
05DE            448            
05DE 753440     449            mov y+0, #low (1000000 % 0x10000) 
05E1 753542     449            mov y+1, #high(1000000 % 0x10000) 
05E4 75360F     449            mov y+2, #low (1000000 / 0x10000) 
05E7 753700     449            mov y+3, #high(1000000 / 0x10000) 
05EA 1201D8     450            lcall mul32
05ED 753454     451            mov y+0, #low (OP_AMP_GAIN % 0x10000) 
05F0 753501     451            mov y+1, #high(OP_AMP_GAIN % 0x10000) 
05F3 753600     451            mov y+2, #low (OP_AMP_GAIN / 0x10000) 
05F6 753700     451            mov y+3, #high(OP_AMP_GAIN / 0x10000) 
05F9 120265     452            lcall div32
05FC 753429     453            mov y+0, #low (41 % 0x10000) 
05FF 753500     453            mov y+1, #high(41 % 0x10000) 
0602 753600     453            mov y+2, #low (41 / 0x10000) 
0605 753700     453            mov y+3, #high(41 / 0x10000) 
0608 120265     454            lcall div32 
060B            455   
060B 753440     456            mov y+0, #low (8000 % 0x10000) 
060E 75351F     456            mov y+1, #high(8000 % 0x10000) 
0611 753600     456            mov y+2, #low (8000 / 0x10000) 
0614 753700     456            mov y+3, #high(8000 / 0x10000) 
0617 120123     457       lcall add32
061A 753402     458            mov y+0, #low (258 % 0x10000) 
061D 753501     458            mov y+1, #high(258 % 0x10000) 
0620 753600     458            mov y+2, #low (258 / 0x10000) 
0623 753700     458            mov y+3, #high(258 / 0x10000) 
0626 120265     459       lcall div32
0629            460       
0629            461       ;load_y(24)
0629            462       ;lcall add32
0629            463       
0629            464       ;load_y(10)
0629            465       ;lcall div32
0629            466   
0629 12005E     467            lcall hex2bcd
062C            468   
062C 300C08     469       jnb my_flag, continue30
062F C20C       470       clr my_flag
0631 1204C7     471            lcall Display_putty
0634 120484     472            lcall SendTemp
0637            473       continue30:
0637            474            ;mov a, #'\r'
0637            475            ;lcall putchar
0637            476            ;mov a, #'\n'
0637            477            ;lcall putchar
0637            478            
0637            479            ;now that we have the cold and hot junction temps in variables ch0 and ch1 respectively, we can add them to get the actual temperature
0637            480            
0637            481   
0637            482      
0637 22         483   ret
0638            484   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0638            485   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0638            486   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0638            487   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0638            488   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0638            489   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0638            490   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
0638            491   
0638            492   ;------ISR-------;
0638            493       ;---------------------------------;
0638            494       ; Routine to initialize the ISR   ;
0638            495       ; for timer 0                     ;
0638            496       ;---------------------------------;
0638            497       Timer0_Init:
0638 E589       498           mov a, TMOD
063A 54F0       499           anl a, #0xf0 ; Clear the bits for timer 0
063C 4401       500           orl a, #0x01 ; Configure timer 0 as 16-timer
063E F589       501           mov TMOD, a
0640 758C6F     502           mov TH0, #high(TIMER0_RELOAD)
0643 758AFF     503           mov TL0, #low(TIMER0_RELOAD)
0646            504           ; Enable the timer and interrupts
0646 D2A9       505           setb ET0  ; Enable timer 0 interrupt
0648 D28C       506           setb TR0  ; Start timer 0
064A 22         507           ret
064B            508   
064B            509       ;---------------------------------;
064B            510       ; ISR for timer 0.  Set to execute;
064B            511       ; every 1/4096Hz to generate a    ;
064B            512       ; 2048 Hz square wave at pin P3.7 ;
064B            513       ;---------------------------------;
064B            514       Timer0_ISR:
064B 758C6F     515           mov TH0, #high(TIMER0_RELOAD)
064E 758AFF     516           mov TL0, #low(TIMER0_RELOAD)
0651 C0E0       517           push acc
0653 C0D0       518           push psw
0655            519           
0655 0561       520           inc Count10ms2
0657 E561       521           mov a, Count10ms2
0659 B43202     522           cjne a, #50, Timer0_ISR_done 
065C D20C       523           setb my_flag  ; used to refresh the page even if timer 1 is disabled 
065E            524   
065E            525           Timer0_ISR_done:
065E D0D0       526           pop psw
0660 D0E0       527           pop acc
0662 32         528           reti
0663            529   
0663            530       ;---------------------------------;
0663            531       ; Routine to initialize the ISR   ;
0663            532       ; for timer 1                     ;
0663            533       ;---------------------------------;
0663            534       Timer1_Init:
0663 E589       535           mov a, TMOD
0665 540F       536           anl a, #0x0f ; Clear the bits for timer 1
0667 4410       537           orl a, #0x10 ; Configure timer 1 as 16-timer
0669 F589       538           mov TMOD, a
066B 758D6F     539           mov TH1, #high(TIMER1_RELOAD)
066E 758BFF     540           mov TL1, #low(TIMER1_RELOAD)
0671            541           ; Enable the timer and interrupts
0671 D2AB       542           setb ET1  ; Enable timer 1 interrupt
0673 D28E       543           setb TR1  ; Start timer 1
0675 22         544           ret
0676            545   
0676            546       ;---------------------------------;
0676            547       ; ISR for timer 1                 ;
0676            548       ;---------------------------------;
0676            549       Timer1_ISR:
0676 758D6F     550           mov TH1, #high(TIMER1_RELOAD)
0679 758BFF     551           mov TL1, #low(TIMER1_RELOAD)       
067C            552           ; The two registers used in the ISR must be saved in the stack
067C C0E0       553           push acc
067E C0D0       554           push psw 
0680            555           ; Increment the 8-bit 10-mili-second counter
0680 0560       556           inc Count10ms
0682            557           ; Increment the 16-bit one mili second counter
0682            558       Inc_Done:
0682 E560       559           mov a, Count10ms
0684 954E       560           subb a, pwm ; if pwm greater than a pwm is on else off
0686 D4         561           da a
0687            562          ; mov a, product
0687 5005       563           jnc off_segment
0689 D281       564           setb p0.1
068B C3         565           clr c
068C 8005       566           sjmp pass
068E            567           off_segment:
068E C281       568           clr p0.1
0690 C3         569           clr c
0691 8000       570           sjmp pass
0693            571   
0693            572           ; Check if 1 second has passed
0693            573           pass:
0693            574   
0693            575           ; Check if half second has passed
0693 E560       576           mov a, Count10ms
0695 B4641F     577           cjne a, #100, Timer1_ISR_done ; Warning: this instruction changes the carry flag!
0698            578           ;----------------------------
0698 054C       579           inc sec ; one second has passed
069A E54C       580           mov a,sec
069C D4         581           da a
069D F54C       582           mov sec,a
069F 0569       583           inc five_sec_flag ; one second has passed
06A1 E569       584           mov a,five_sec_flag
06A3 D4         585           da a
06A4 F569       586           mov five_sec_flag,a
06A6 E54C       587           mov a,sec
06A8            588          ; mov minutes, #0
06A8 85E066     589           mov seconds, acc 
06AB            590           ;----------------------------
06AB            591           ; 500 milliseconds have passed.  Set a flag so the main program knows
06AB D203       592           setb half_seconds_flag ; Let the main program know half second had passed
06AD            593           ; Reset to zero the 10-milli-seconds counter, it is a 8-bit variable
06AD 756000     594           mov Count10ms, #0x00
06B0            595      ;     mov Count1ms, #0x00
06B0            596           ; Increment the BCD counter
06B0 E55A       597           mov a, BCD_counter
06B2 2401       598           add a, #0x01
06B4            599       Timer1_ISR_da:
06B4 D4         600           da a ; Decimal adjust instruction.  Check datasheet for more details!
06B5 F55A       601           mov BCD_counter, a
06B7            602           
06B7            603       Timer1_ISR_done:
06B7 D0D0       604           pop psw
06B9 D0E0       605           pop acc
06BB 32         606           reti
06BC            607   
06BC            608   
06BC            609   
06BC            610   
06BC            611   
06BC            612       ;------------------------------
06BC            613       ;---------------------------------;
06BC            614       ; Routine to initialize the CCU.  ;
06BC            615       ; We are using the CCU timer in a ;
06BC            616       ; manner similar to the timer 2   ;
06BC            617       ; available in other 8051s        ;
06BC            618       ;---------------------------------;
06BC            619       CCU_Init:
06BC 75CDFE     620           mov TH2, #high(CCU_RELOAD)
06BF 75CCB2     621           mov TL2, #low(CCU_RELOAD)
06C2 75CFFE     622           mov TOR2H, #high(CCU_RELOAD)
06C5 75CEB2     623           mov TOR2L, #low(CCU_RELOAD)
06C8 75F980     624           mov TCR21, #10000000b ; Latch the reload value
06CB 75C980     625           mov TICR2, #10000000b ; Enable CCU Timer Overflow Interrupt
06CE D2EC       626           setb ECCU ; Enable CCU interrupt
06D0 D2C8       627           setb TMOD20 ; Start CCU timer
06D2 22         628           ret
06D3            629   
06D3            630       ;---------------------------------;
06D3            631       ; ISR for CCU.  Used to playback  ;
06D3            632       ; the WAV file stored in the SPI  ;
06D3            633       ; flash memory.                   ;
06D3            634       ;---------------------------------;
06D3            635       CCU_ISR:
06D3 75E900     636           mov TIFR2, #0 ; Clear CCU Timer Overflow Interrupt Flag bit. Actually, it clears all the bits!
06D6            637           
06D6            638           ; The registers used in the ISR must be saved in the stack
06D6 C0E0       639           push acc
06D8 C0D0       640           push psw
06DA            641           
06DA            642           ; Check if the play counter is zero.  If so, stop playing sound.
06DA E562       643           mov a, w+0
06DC 4563       644           orl a, w+1
06DE 4564       645           orl a, w+2
06E0 6015       646           jz stop_playing
06E2            647           
06E2            648           ;;yolo this is gonna fuck with the speaker
06E2            649           ; Increment the 16-bit one mili second counter
06E2            650         ;  inc Count1ms+0    ; Increment the low 8-bits first
06E2            651         ;  mov a, Count1ms+0 ; If the low 8-bits overflow, then increment high 8-bits
06E2            652         ;  jnz Inc_Done
06E2            653         ;  inc Count1ms+1
06E2            654           ; Decrement play counter 'w'.  In this implementation 'w' is a 24-bit counter.
06E2 74FF       655           mov a, #0xff
06E4 1562       656           dec w+0
06E6 B56207     657           cjne a, w+0, keep_playing
06E9 1563       658           dec w+1
06EB B56302     659           cjne a, w+1, keep_playing
06EE 1564       660           dec w+2
06F0            661           
06F0            662       keep_playing:
06F0            663   
06F0 120727     664           lcall Send_SPI ; Read the next byte from the SPI Flash...
06F3 F5F5       665           mov AD1DAT3, a ; and send it to the DAC
06F5            666           
06F5 8006       667           sjmp CCU_ISR_Done
06F7            668   
06F7            669       stop_playing:
06F7 C2C8       670           clr TMOD20 ; Stop CCU timer
06F9 D2A4       671           setb FLASH_CE  ; Disable SPI Flash
06FB C2A7       672           clr SOUND ; Turn speaker off
06FD            673   
06FD            674       CCU_ISR_Done:        
06FD D0D0       675           pop psw
06FF D0E0       676           pop acc
0701 32         677           reti
0702            678   ;----------------;
0702            679   
0702            680   ;---------------------------------;
0702            681   ; Initial configuration of ports. ;
0702            682   ; After reset the default for the ;
0702            683   ; pins is 'Open Drain'.  This     ;
0702            684   ; routine changes them pins to    ;
0702            685   ; Quasi-bidirectional like in the ;
0702            686   ; original 8051.                  ;
0702            687   ; Notice that P1.2 and P1.3 are   ;
0702            688   ; always 'Open Drain'. If those   ;
0702            689   ; pins are to be used as output   ;
0702            690   ; they need a pull-up resistor.   ;
0702            691   ;---------------------------------;
0702            692   
0702            693   ;---------------------------------;
0702            694   ; Initialize ADC1/DAC1 as DAC1.   ;
0702            695   ; Warning, the ADC1/DAC1 can work ;
0702            696   ; only as ADC or DAC, not both.   ;
0702            697   ; The P89LPC9351 has two ADC/DAC  ;
0702            698   ; interfaces.  One can be used as ;
0702            699   ; ADC and the other can be used   ;
0702            700   ; as DAC.  Also configures the    ;
0702            701   ; pin associated with the DAC, in ;
0702            702   ; this case P0.4 as 'Open Drain'. ;
0702            703   ;---------------------------------;
0702            704   InitDAC1:
0702            705       ; Configure pin P0.4 (DAC1 output pin) as open drain
0702 438410     706            orl     P0M1,   #00010000B
0705 438510     707            orl     P0M2,   #00010000B
0708 75A128     708       mov ADMODB, #00101000B ; Select main clock/2 for ADC/DAC.  Also enable DAC1 output (Table 25 of reference manual)
070B 759704     709            mov     ADCON1, #00000100B ; Enable the converter
070E 75F580     710            mov AD1DAT3, #0x80     ; Start value is 3.3V/2 (zero reference for AC WAV file)
0711 22         711            ret
0712            712   
0712            713   ;---------------------------------;
0712            714   ; Change the internal RC osc. clk ;
0712            715   ; from 7.373MHz to 14.746MHz.     ;
0712            716   ;---------------------------------;
0712            717   Double_Clk:
0712            718       ;mov dptr, #CLKCON
0712            719       ;movx a, @dptr
0712            720       ;orl a, #00001000B ; double the clock speed to 14.746MHz
0712            721       ;movx @dptr,a
0712 22         722            ret
0713            723   
0713            724   ;---------------------------------;
0713            725   ; Initialize the SPI interface    ;
0713            726   ; and the pins associated to SPI. ;
0713            727   ;---------------------------------;
0713            728   Init_SPI:
0713 D283       729       setb MY_MISO    ; Make MISO an input pin     
0715 C282       730            clr MY_SCLK     ; For mode (0,0) SCLK is zero  
0717            731            ; Configure MOSI (P2.2), CS* (P2.4), and SPICLK (P2.5) as push-pull outputs (see table 42, page 51)
0717 53A4CB     732            anl P2M1, #low(not(00110100B))
071A 43A534     733            orl P2M2, #00110100B
071D            734            ; Configure MISO (P2.3) as input (see table 42, page 51)
071D 43A408     735            orl P2M1, #00001000B
0720 53A5F7     736            anl P2M2, #low(not(00001000B)) 
0723            737            ; Configure SPI
0723 75E2D0     738            mov SPCTL, #11010000B ; Ignore /SS, Enable SPI, DORD=0, Master=1, CPOL=0, CPHA=0, clk/4
0726 22         739            ret
0727            740   
0727            741   ;---------------------------------;
0727            742   ; Sends AND receives a byte via   ;
0727            743   ; SPI.                            ;
0727            744   ;---------------------------------;
0727            745   Send_SPI:
0727 F5E3       746            mov SPDAT, a
0729            747   Send_SPI_1:
0729 E5E1       748            mov a, SPSTAT 
072B 30E7FB     749            jnb acc.7, Send_SPI_1 ; Check SPI Transfer Completion Flag
072E F5E1       750            mov SPSTAT, a ; Clear SPI Transfer Completion Flag
0730 E5E3       751            mov a, SPDAT ; return received byte via accumulator
0732 22         752            ret
0733            753   
0733            754   ;---------------------------------;
0733            755   ; SPI flash 'write enable'        ;
0733            756   ; instruction.                    ;
0733            757   ;---------------------------------;
0733            758   Enable_Write:
0733 C2A4       759            clr FLASH_CE
0735 7406       760            mov a, #WRITE_ENABLE
0737 120727     761            lcall Send_SPI
073A D2A4       762            setb FLASH_CE
073C 22         763            ret
073D            764   
073D            765   ;---------------------------------;
073D            766   ; This function checks the 'write ;
073D            767   ; in progress' bit of the SPI     ;
073D            768   ; flash memory.                   ;
073D            769   ;---------------------------------;
073D            770   Check_WIP:
073D C2A4       771            clr FLASH_CE
073F 7405       772            mov a, #READ_STATUS
0741 120727     773            lcall Send_SPI
0744 7455       774            mov a, #0x55
0746 120727     775            lcall Send_SPI
0749 D2A4       776            setb FLASH_CE
074B 20E0EF     777            jb acc.0, Check_WIP ;  Check the Write in Progress bit
074E 22         778            ret
074F            779            
074F            780   ; Display a binary number in the LCD (must be less than 99).  Number to display passed in accumulator.
074F            781   LCD_number:
074F C0E0       782            push acc
0751 75F00A     783            mov b, #10
0754 84         784            div ab
0755 4430       785            orl a, #'0'
0757 12031C     786            lcall ?WriteData
075A E5F0       787            mov a, b
075C 4430       788            orl a, #'0'
075E 12031C     789            lcall ?WriteData
0761 D0E0       790            pop acc
0763 22         791            ret
0764            792   
0764            793   ; Sounds we need in the SPI flash: 0; 1; 2; 3; 4; 5; 6; 7; 8; 9; 10; 11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 30; 40; 50; minutes; seconds;
0764            794   ; Approximate index of sounds in file 'stop_watch.wav'
0764            795   ; This was generated using: computer_sender -Asw_index.asm -S2000 stop_watch.wav
0764            796   sound_index:
0764 00002D     797       db 0x00, 0x00, 0x2d ; 0 
0767 003107     798       db 0x00, 0x31, 0x07 ; 1 
076A 007007     799       db 0x00, 0x70, 0x07 ; 2 
076D 00ADB9     800       db 0x00, 0xad, 0xb9 ; 3 
0770 00F266     801       db 0x00, 0xf2, 0x66 ; 4 
0773 0135D5     802       db 0x01, 0x35, 0xd5 ; 5 
0776 017D33     803       db 0x01, 0x7d, 0x33 ; 6 
0779 01C761     804       db 0x01, 0xc7, 0x61 ; 7 
077C 021279     805       db 0x02, 0x12, 0x79 ; 8 
077F 0249C1     806       db 0x02, 0x49, 0xc1 ; 9 
0782 028F7A     807       db 0x02, 0x8f, 0x7a ; 10 
0785 02D063     808       db 0x02, 0xd0, 0x63 ; 11 
0788 031B87     809       db 0x03, 0x1b, 0x87 ; 12 
078B 03630E     810       db 0x03, 0x63, 0x0e ; 13 
078E 03B95F     811       db 0x03, 0xb9, 0x5f ; 14 
0791 04113A     812       db 0x04, 0x11, 0x3a ; 15 
0794 0466C4     813       db 0x04, 0x66, 0xc4 ; 16 
0797 04C012     814       db 0x04, 0xc0, 0x12 ; 17 
079A 052698     815       db 0x05, 0x26, 0x98 ; 18 
079D 0574E9     816       db 0x05, 0x74, 0xe9 ; 19 
07A0 05D28E     817       db 0x05, 0xd2, 0x8e ; 20 
07A3 061D83     818       db 0x06, 0x1d, 0x83 ; 21 -> 30 
07A6 066342     819       db 0x06, 0x63, 0x42 ; 22 -> 40 
07A9 06AAB9     820       db 0x06, 0xaa, 0xb9 ; 23 -> 50 
07AC 06F3D6     821       db 0x06, 0xf3, 0xd6 ; 24 -> Minutes 
07AF 073F02     822       db 0x07, 0x3f, 0x02 ; 25 -> Seconds 
07B2            823   
07B2            824   ; Size of each sound in 'sound_index'
07B2            825   ; Generated using: computer_sender -Asw_index.asm -S2000 stop_watch.wav
07B2            826   Size_Length:
07B2 0030DA     827       db 0x00, 0x30, 0xda ; 0 
07B5 003F00     828       db 0x00, 0x3f, 0x00 ; 1 
07B8 003DB2     829       db 0x00, 0x3d, 0xb2 ; 2 
07BB 0044AD     830       db 0x00, 0x44, 0xad ; 3 
07BE 00436F     831       db 0x00, 0x43, 0x6f ; 4 
07C1 00475E     832       db 0x00, 0x47, 0x5e ; 5 
07C4 004A2E     833       db 0x00, 0x4a, 0x2e ; 6 
07C7 004B18     834       db 0x00, 0x4b, 0x18 ; 7 
07CA 003748     835       db 0x00, 0x37, 0x48 ; 8 
07CD 0045B9     836       db 0x00, 0x45, 0xb9 ; 9 
07D0 0040E9     837       db 0x00, 0x40, 0xe9 ; 10 
07D3 004B24     838       db 0x00, 0x4b, 0x24 ; 11 
07D6 004787     839       db 0x00, 0x47, 0x87 ; 12 
07D9 005651     840       db 0x00, 0x56, 0x51 ; 13 
07DC 0057DB     841       db 0x00, 0x57, 0xdb ; 14 
07DF 00558A     842       db 0x00, 0x55, 0x8a ; 15 
07E2 00594E     843       db 0x00, 0x59, 0x4e ; 16 
07E5 006686     844       db 0x00, 0x66, 0x86 ; 17 
07E8 004E51     845       db 0x00, 0x4e, 0x51 ; 18 
07EB 005DA5     846       db 0x00, 0x5d, 0xa5 ; 19 
07EE 004AF5     847       db 0x00, 0x4a, 0xf5 ; 20 
07F1 0045BF     848       db 0x00, 0x45, 0xbf ; 21 -> 30
07F4 004777     849       db 0x00, 0x47, 0x77 ; 22 -> 40
07F7 00491D     850       db 0x00, 0x49, 0x1d ; 23 -> 50
07FA 004B2C     851       db 0x00, 0x4b, 0x2c ; 24 -> minutes
07FD 005C87     852       db 0x00, 0x5c, 0x87 ; 25 -> seconds
0800            853   
0800            854   ; The sound and its length from the two tables above is passed in the accumulator.
0800            855   Play_Sound_Using_Index:
0800 D2A7       856            setb SOUND ; Turn speaker on
0802 C2C8       857            clr TMOD20 ; Stop the CCU from playing previous request
0804 D2A4       858            setb FLASH_CE
0806            859            
0806            860            ; There are three bytes per row in our tables, so multiply index by three
0806 75F003     861            mov b, #3
0809 A4         862            mul ab
080A F8         863            mov R0, a ; Make a copy of the index*3
080B            864            
080B C2A4       865            clr FLASH_CE ; Enable SPI Flash
080D 7403       866            mov a, #READ_BYTES
080F 120727     867            lcall Send_SPI
0812            868            ; Set the initial position in memory of where to start playing
0812 900764     869            mov dptr, #sound_index
0815 E8         870            mov a, R0
0816 93         871            movc a, @a+dptr
0817 120727     872            lcall Send_SPI
081A A3         873            inc dptr
081B E8         874            mov a, R0
081C 93         875            movc a, @a+dptr
081D 120727     876            lcall Send_SPI
0820 A3         877            inc dptr
0821 E8         878            mov a, R0
0822 93         879            movc a, @a+dptr
0823 120727     880            lcall Send_SPI
0826            881            ; Now set how many bytes to play
0826 9007B2     882            mov dptr, #Size_Length
0829 E8         883            mov a, R0
082A 93         884            movc a, @a+dptr
082B F564       885            mov w+2, a
082D A3         886            inc dptr
082E E8         887            mov a, R0
082F 93         888            movc a, @a+dptr
0830 F563       889            mov w+1, a
0832 A3         890            inc dptr
0833 E8         891            mov a, R0
0834 93         892            movc a, @a+dptr
0835 F562       893            mov w+0, a
0837            894            
0837 7400       895            mov a, #0x00 ; Request first byte to send to DAC
0839 120727     896            lcall Send_SPI
083C            897            
083C D2C8       898            setb TMOD20 ; Start playback by enabling CCU timer
083E            899   
083E 22         900            ret
083F            901   
083F            902   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
083F            903   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
083F            904   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
083F            905   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
083F            906   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
083F            907   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
083F            908   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
083F            909   
083F            910   ;;;;;;; ; Send a character using the serial port
083F            911   ;;;;;;;putchar:
083F            912   ;;;;;;;        jnb TI, putchar 
083F            913   ;;;;;;;        ; TI serial interrupt flag is set and when last bit (stop bit) 
083F            914   ;;;;;;;        ; of receiving data byte is received, RI flag get set. IE register
083F            915   ;;;;;;;        ; is used to enable/disable interrupt sources.
083F            916   ;;;;;;;        clr TI
083F            917   ;;;;;;;        mov SBUF, a
083F            918   ;;;;;;;        ret
083F            919   ;;;;;;;
083F            920   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
083F            921   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
083F            922   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
083F            923   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
083F            924   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
083F            925   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
083F            926   ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
083F            927   
083F            928   ;---------------------------------------------------------------------------------;
083F            929   ; This is the FSM that plays minutes and seconds after the STOP button is pressed ;
083F            930   ; The state diagram of this FSM is available as 'Stop_Watch_FSM.pdf'              ;
083F            931   ;---------------------------------------------------------------------------------;
083F            932   T2S_FSM:
083F E567       933            mov a, T2S_FSM_state
0841            934   
0841            935   T2S_FSM_State0: ; Checks for the start signal (T2S_FSM_Start==1)
0841 B40013     936            cjne a, #0, T2S_FSM_State1
0844 30000F     937            jnb T2S_FSM_Start, T2S_FSM_State0_Done
0847            938            ; Check if minutes is larger than 19
0847 C3         939            clr c
0848 E565       940            mov a, minutes
084A 9414       941            subb a, #20
084C 5005       942            jnc minutes_gt_19
084E 756701     943            mov T2S_FSM_state, #1
0851 8003       944            sjmp T2S_FSM_State0_Done
0853            945   minutes_gt_19:
0853 756703     946            mov T2S_FSM_state, #3
0856            947   T2S_FSM_State0_Done:
0856 22         948            ret
0857            949            
0857            950   T2S_FSM_State1: ; Plays minutes when minutes is less than 20
0857 B40109     951            cjne a, #1, T2S_FSM_State2
085A E565       952            mov a, minutes
085C 120800     953            lcall Play_Sound_Using_Index
085F 756702     954            mov T2S_FSM_State, #2
0862 22         955            ret 
0863            956   
0863            957   T2S_FSM_State2: ; Stay in this state until sound finishes playing
0863 B40207     958            cjne a, #2, T2S_FSM_State3
0866 20C803     959            jb TMOD20, T2S_FSM_State2_Done 
0869 756706     960            mov T2S_FSM_State, #6
086C            961   T2S_FSM_State2_Done:
086C 22         962            ret
086D            963   
086D            964   T2S_FSM_State3: ; Plays the tens when minutes is larger than 19, for example for 42 minutes, it plays 'forty'
086D B4030F     965            cjne a, #3, T2S_FSM_State4
0870 E565       966            mov a, minutes
0872 75F00A     967            mov b, #10
0875 84         968            div ab
0876 2412       969            add a, #18
0878 120800     970            lcall Play_Sound_Using_Index
087B 756704     971            mov T2S_FSM_State, #4
087E 22         972            ret
087F            973   
087F            974   T2S_FSM_State4: ; Stay in this state until sound finishes playing
087F B40407     975            cjne a, #4, T2S_FSM_State5
0882 20C803     976            jb TMOD20, T2S_FSM_State4_Done 
0885 756705     977            mov T2S_FSM_State, #5
0888            978   T2S_FSM_State4_Done:
0888 22         979       ret
0889            980   
0889            981   T2S_FSM_State5: ; Plays the units when minutes is larger than 19, for example for 42 minutes, it plays 'two'
0889 B40511     982            cjne a, #5, T2S_FSM_State6
088C E565       983            mov a, minutes
088E 75F00A     984            mov b, #10
0891 84         985            div ab
0892 E5F0       986            mov a, b
0894 6003       987            jz T2S_FSM_State5_Done ; Prevents from playing something like 'forty zero'
0896 120800     988            lcall Play_Sound_Using_Index
0899            989   T2S_FSM_State5_Done:
0899 756702     990            mov T2S_FSM_State, #2
089C 22         991            ret
089D            992   
089D            993   T2S_FSM_State6: ; Plays the word 'minutes'
089D B40609     994            cjne a, #6, T2S_FSM_State7
08A0 7418       995            mov a, #24 ; Index 24 has the word 'minutes'
08A2 120800     996            lcall Play_Sound_Using_Index
08A5 756707     997            mov T2S_FSM_State, #7
08A8 22         998            ret
08A9            999   
08A9           1000   T2S_FSM_State7: ; Stay in this state until sound finishes playing
08A9 B40713    1001            cjne a, #7, T2S_FSM_State8
08AC 20C80F    1002            jb TMOD20, T2S_FSM_State7_Done 
08AF           1003            ; Done playing previous sound, check if seconds is larger than 19
08AF C3        1004            clr c
08B0 E566      1005            mov a, seconds
08B2 9414      1006            subb a, #20
08B4 5005      1007            jnc seconds_gt_19
08B6 756708    1008            mov T2S_FSM_state, #8
08B9 809B      1009            sjmp T2S_FSM_State0_Done
08BB           1010   seconds_gt_19:
08BB 75670A    1011            mov T2S_FSM_state, #10
08BE           1012   T2S_FSM_State7_Done:
08BE 22        1013       ret
08BF           1014   
08BF           1015   T2S_FSM_State8: ; Play the seconds when seconds is less than 20.
08BF B40809    1016            cjne a, #8, T2S_FSM_State9
08C2 E566      1017            mov a, seconds
08C4 120800    1018            lcall Play_Sound_Using_Index
08C7 756709    1019            mov T2S_FSM_state, #9
08CA 22        1020            ret
08CB           1021   
08CB           1022   T2S_FSM_State9: ; Stay in this state until sound finishes playing
08CB B40907    1023            cjne a, #9, T2S_FSM_State10
08CE 20C803    1024            jb TMOD20, T2S_FSM_State9_Done 
08D1 75670D    1025            mov T2S_FSM_State, #13
08D4           1026   T2S_FSM_State9_Done:
08D4 22        1027            ret
08D5           1028   
08D5           1029   T2S_FSM_State10:  ; Plays the tens when seconds is larger than 19, for example for 35 seconds, it plays 'thirty'
08D5 B40A0F    1030            cjne a, #10, T2S_FSM_State11
08D8 E566      1031            mov a, seconds
08DA 75F00A    1032            mov b, #10
08DD 84        1033            div ab
08DE 2412      1034            add a, #18
08E0 120800    1035            lcall Play_Sound_Using_Index
08E3 75670B    1036            mov T2S_FSM_state, #11
08E6 22        1037            ret
08E7           1038   
08E7           1039   T2S_FSM_State11: ; Stay in this state until sound finishes playing
08E7 B40B07    1040            cjne a, #11, T2S_FSM_State12
08EA 20C803    1041            jb TMOD20, T2S_FSM_State11_Done 
08ED 75670C    1042            mov T2S_FSM_State, #12
08F0           1043   T2S_FSM_State11_Done:
08F0 22        1044            ret
08F1           1045   
08F1           1046   T2S_FSM_State12: ; Plays the units when seconds is larger than 19, for example for 35 seconds, it plays 'five'
08F1 B40C11    1047            cjne a, #12, T2S_FSM_State13
08F4 E566      1048            mov a, seconds
08F6 75F00A    1049            mov b, #10
08F9 84        1050            div ab
08FA E5F0      1051            mov a, b
08FC 6003      1052            jz T2S_FSM_State12_Done ; Prevents from saying something like 'thirty zero'
08FE 120800    1053            lcall Play_Sound_Using_Index
0901           1054   T2S_FSM_State12_Done:
0901 756709    1055            mov T2S_FSM_State, #9
0904 22        1056            ret
0905           1057   
0905           1058   T2S_FSM_State13: ; Plays the word 'seconds'
0905 B40D09    1059            cjne a, #13, T2S_FSM_State14
0908 7419      1060            mov a, #25 ; Index 25 has the word 'seconds'
090A 120800    1061            lcall Play_Sound_Using_Index
090D 75670E    1062            mov T2S_FSM_State, #14
0910 22        1063            ret
0911           1064   
0911           1065   T2S_FSM_State14: ; Stay in this state until sound finishes playing
0911 B40E09    1066            cjne a, #14, T2S_FSM_Error
0914 20C805    1067            jb TMOD20, T2S_FSM_State14_Done 
0917 C200      1068            clr T2S_FSM_Start 
0919 756700    1069            mov T2S_FSM_State, #0
091C           1070   T2S_FSM_State14_Done:
091C 22        1071            ret
091D           1072   
091D           1073   T2S_FSM_Error: ; If we got to this point, there is an error in the finite state machine.  Restart it.
091D 756700    1074            mov T2S_FSM_state, #0
0920 C200      1075            clr T2S_FSM_Start
0922 22        1076            ret
0923           1077           
0923           1078   ;WaitHalfSec:
0923           1079       ;        mov R2, #178
0923           1080       ;        Lr3: mov R1, #250
0923           1081       ;        Lr2: mov R0, #166
0923           1082       ;        Lr1: djnz R0, Lr1 ; 3 cycles->3*45.21123ns*166=22.51519us
0923           1083       ;        djnz R1, Lr2 ; 22.51519us*250=5.629ms
0923           1084       ;        djnz R2, Lr3 ; 5.629ms*89=0.5s (approximately)
0923           1085       ;        ret
0923           1086       ;    
0923           1087       ;blink:
0923           1088       ;        mov SP, #7FH
0923           1089       ;        mov P3M1, #0   ; Configure P3 in bidirectional mode
0923           1090       ;    M0:
0923           1091       ;        cpl P3.7
0923           1092       ;        Set_Cursor(1, 1)
0923           1093       ;        Send_Constant_String(#nothing)
0923           1094       ;        Set_Cursor(2, 1)
0923           1095       ;        Send_Constant_String(#nothing)
0923           1096       ;        Set_Cursor(1, 1)
0923           1097       ;        Send_Constant_String(#hot)
0923           1098       ;        Set_Cursor(2, 1)
0923           1099       ;        Send_Constant_String(#hot)
0923           1100       ;
0923           1101       ;        lcall WaitHalfSec
0923           1102       ;
0923           1103       ;        ret
0923           1104       ;
0923           1105       ;convert:
0923           1106       ;    mov x+0, Result
0923           1107       ;    mov x+1, Result+1 
0923           1108       ;    mov x+2, #0
0923           1109       ;    mov x+3, #0
0923           1110       ;    ret
0923           1111       ;    
0923           1112       ;
0923           1113       Display_temp:
0923           1114       ;    Load_y(410)
0923           1115       ;    lcall mul32
0923           1116       ;    Load_y(1023)
0923           1117       ;    lcall div32
0923           1118       ;    Load_y(273)
0923           1119       ;    lcall sub32
0923           1120       ;    lcall hex2bcd
0923           1121       ;    lcall InitSerialPort
0923 C0E0      1122            push acc
0925 7401      1122            mov a, #1
0927 14        1122            dec a
0928 120368    1122            lcall ?Set_Cursor_1 ; Select column and row
092B D0E0      1122            pop acc
092D C083      1123            push dph
092F C082      1123            push dpl
0931 C0E0      1123            push acc
0933 9003F2    1123            mov dptr, #Temp0
0936 12035B    1123            lcall ?Send_Constant_String
0939 D0E0      1123            pop acc
093B D082      1123            pop dpl
093D D083      1123            pop dph
093F           1124   
093F           1125       ;    lcall SendString
093F           1126       ;    Set_Cursor(1, 5)    
093F           1127       ;    Send_BCD(bcd+1) ; send fisrt 2 digits to putty
093F           1128       ;    Display_BCD(bcd+1); send fisrt 2 digits to lcd
093F           1129       ;    Set_Cursor(1, 7) 
093F           1130       ;    Send_BCD(bcd) ; send last 2 digits to putty
093F           1131       ;    Display_BCD(bcd+0) ; send last 2 digits to lcd
093F           1132       ;    Set_Cursor(1, 5)
093F           1133       ;    Send_Constant_String(#dots)
093F           1134       ;    lcall SendString
093F           1135       ;    mov DPTR, #Newline
093F           1136       ;    lcall SendString
093F 22        1137           ret
0940           1138       ;config_adc:
0940           1139       ;        clr CE_ADC 
0940           1140       ;        mov R0, #00000001B; Start bit:1 
0940           1141       ;        lcall DO_SPI_G
0940           1142       ;
0940           1143       ;        mov R0, #10000000B; Single ended, read channel 0 
0940           1144       ;        lcall DO_SPI_G 
0940           1145       ;        mov a, R1          ; R1 contains bits 8 and 9 
0940           1146       ;        anl a, #00000011B  ; We need only the two least significant bits 
0940           1147       ;        mov Result+1, a    ; Save result high.
0940           1148       ;
0940           1149       ;        mov R0, #55H; It doesn't matter what we transmit... 
0940           1150       ;        lcall DO_SPI_G 
0940           1151       ;        mov Result, R1     ; R1 contains bits 0 to 7.  Save result low. 
0940           1152       ;        setb CE_ADC 
0940           1153       ;        lcall convert  
0940           1154       ;        mov a, bcd ; move temp to accumulator 
0940           1155       ;        ret
0940           1156   Reset_timer:
0940           1157   
0940 C28E      1158       clr TR1                 ; Stop timer 2
0942 E4        1159       clr a
0943 756000    1160            mov Count10ms, #0x00
0946           1161            ; Now clear the BCD counter and minutes
0946 F55A      1162            mov BCD_counter, a
0948 D28E      1163            setb TR1                ; Start timer 2
094A           1164   
094A 22        1165       ret
094B           1166   Display_time:
094B C0E0      1167            push acc
094D 7401      1167            mov a, #1
094F 14        1167            dec a
0950 120366    1167            lcall ?Set_Cursor_2 ; Select column and row
0953 D0E0      1167            pop acc
0955 C083      1168            push dph
0957 C082      1168            push dpl
0959 C0E0      1168            push acc
095B 9003FA    1168            mov dptr, #Time
095E 12035B    1168            lcall ?Send_Constant_String
0961 D0E0      1168            pop acc
0963 D082      1168            pop dpl
0965 D083      1168            pop dph
0967 C203      1169       clr half_seconds_flag ; We clear this flag in the main loop, but it is set in the ISR for timer 2
0969           1170       ;clr my_flag
0969 C0E0      1171            push acc
096B 7409      1171            mov a, #9
096D 14        1171            dec a
096E 120366    1171            lcall ?Set_Cursor_2 ; Select column and row
0971 D0E0      1171            pop acc     ; the place in the LCD where we want the BCD counter value
0973 C000      1172            push ar0
0975 A85A      1172            mov r0, BCD_counter
0977 12036D    1172            lcall ?Display_BCD
097A D000      1172            pop ar0 ; This macro is also in 'LCD_4bit.inc'
097C C0E0      1173            push acc
097E 7406      1173            mov a, #6
0980 14        1173            dec a
0981 120366    1173            lcall ?Set_Cursor_2 ; Select column and row
0984 D0E0      1173            pop acc     ; the place in the LCD where we want the BCD counter value
0986 C000      1174            push ar0
0988 A865      1174            mov r0, minutes
098A 12036D    1174            lcall ?Display_BCD
098D D000      1174            pop ar0 ; This macro is also in 'LCD_4bit.inc'
098F           1175   
098F 22        1176       ret
0990           1177   ;;Timer couter 
0990           1178       sec_counter: 
0990 E55A      1179           mov a,BCD_counter
0992 B4600A    1180           cjne a, #0x60, Continue1 ; check if the couter reached 60s
0995 E565      1181           mov a, minutes
0997 2401      1182           add a, #0x01 ; add one to the minutes
0999 D4        1183           da a ; Decimal adjust instruction.  Check datasheet for more details!
099A F565      1184           mov minutes, a
099C 120940    1185           lcall Reset_timer
099F           1186                Continue1:
099F 22        1187           ret
09A0           1188       min_counter:
09A0 E565      1189                    mov a,minutes
09A2 B4600A    1190                    cjne a, #0x60, Continue2
09A5 C28E      1191                    clr TR1                 ; Stop timer 2
09A7 E4        1192                    clr a                   
09A8 756000    1193                    mov Count10ms, #0x00      ; Now clear the BCD counter
09AB F565      1194                    mov minutes, a              ; Reset minutes
09AD D28E      1195           setb TR1                ; Start timer 2
09AF           1196   
09AF           1197                    Continue2:
09AF 22        1198           ret
09B0           1199   home_page:
09B0           1200   
09B0 20A718    1201         jb P2.7, continue20
09B3 C002      1202            push AR2
09B5 7A32      1202            mov R2, #50
09B7 1202D7    1202            lcall ?Wait_Milli_Seconds
09BA D002      1202            pop AR2 ; debounce
09BC 20A70C    1203      jb P2.7, continue20
09BF 30A7FD    1204      jnb p2.7, $
09C2           1205      ;clr TR1 
09C2 755A00    1206       mov BCD_counter, #0x00
09C5 756500    1207       mov minutes, #0x0   
09C8 12094B    1208       lcall Display_time
09CB           1209   
09CB           1210      continue20:
09CB           1211       ;--------Timer----------;
09CB           1212   
09CB 300309    1213       jnb half_seconds_flag, Temp_sensor
09CE 120990    1214       lcall sec_counter
09D1 1209A0    1215       lcall min_counter
09D4 12094B    1216       lcall Display_time
09D7           1217       ;-----------------------;
09D7           1218   
09D7           1219       ;-----TEMP SENSOR-------;
09D7           1220       Temp_sensor:
09D7           1221    ;    lcall config_adc
09D7 120923    1222       lcall Display_temp
09DA           1223    ;    lcall  WaitHalfSec 
09DA           1224    ;    ;-----------------------;
09DA           1225   
09DA           1226   
09DA           1227   
09DA           1228   
09DA 22        1229       ret
09DB           1230   ;
09DB           1231   setup_reflow_page:
09DB 20A011    1232            jb set_BUTTON, continue9
09DE C002      1232            push AR2
09E0 7A0A      1232            mov R2, #10
09E2 1202D7    1232            lcall ?Wait_Milli_Seconds
09E5 D002      1232            pop AR2
09E7 20A005    1232            jb set_BUTTON, continue9
09EA 30A0FD    1232            jnb set_BUTTON, $
09ED           1232   
09ED B209      1233       cpl tt_reflow_flag
09EF           1234       continue9:
09EF           1235   
09EF 200906    1236       jb tt_reflow_flag, jump1
09F2           1237       ;jnb tt_reflow_flag, jump1
09F2 120AB8    1238       lcall INC_DEC_Reflow_time
09F5 0209FB    1239       ljmp display_reflow_page
09F8           1240       jump1:
09F8 120B01    1241       lcall INC_DEC_Reflow_temp
09FB           1242   
09FB           1243   
09FB           1244       display_reflow_page:
09FB C0E0      1245            push acc
09FD 7405      1245            mov a, #5
09FF 14        1245            dec a
0A00 120368    1245            lcall ?Set_Cursor_1 ; Select column and row
0A03 D0E0      1245            pop acc
0A05 C000      1246            push ar0
0A07 A851      1246            mov r0, reflow_temp+0
0A09 12036D    1246            lcall ?Display_BCD
0A0C D000      1246            pop ar0
0A0E C0E0      1247            push acc
0A10 7407      1247            mov a, #7
0A12 14        1247            dec a
0A13 120368    1247            lcall ?Set_Cursor_1 ; Select column and row
0A16 D0E0      1247            pop acc
0A18 C000      1248            push ar0
0A1A A852      1248            mov r0, reflow_temp+1
0A1C 12036D    1248            lcall ?Display_BCD
0A1F D000      1248            pop ar0
0A21           1249          
0A21           1250       
0A21 C0E0      1251            push acc
0A23 7401      1251            mov a, #1
0A25 14        1251            dec a
0A26 120368    1251            lcall ?Set_Cursor_1 ; Select column and row
0A29 D0E0      1251            pop acc
0A2B C083      1252            push dph
0A2D C082      1252            push dpl
0A2F C0E0      1252            push acc
0A31 90041C    1252            mov dptr, #reflow_setup
0A34 12035B    1252            lcall ?Send_Constant_String
0A37 D0E0      1252            pop acc
0A39 D082      1252            pop dpl
0A3B D083      1252            pop dph
0A3D C0E0      1253            push acc
0A3F 7409      1253            mov a, #9
0A41 14        1253            dec a
0A42 120368    1253            lcall ?Set_Cursor_1 ; Select column and row
0A45 D0E0      1253            pop acc
0A47 C083      1254            push dph
0A49 C082      1254            push dpl
0A4B C0E0      1254            push acc
0A4D 900421    1254            mov dptr, #reflow_setup4
0A50 12035B    1254            lcall ?Send_Constant_String
0A53 D0E0      1254            pop acc
0A55 D082      1254            pop dpl
0A57 D083      1254            pop dph
0A59           1255   
0A59 C0E0      1256            push acc
0A5B 7401      1256            mov a, #1
0A5D 14        1256            dec a
0A5E 120366    1256            lcall ?Set_Cursor_2 ; Select column and row
0A61 D0E0      1256            pop acc
0A63 C083      1257            push dph
0A65 C082      1257            push dpl
0A67 C0E0      1257            push acc
0A69 90042A    1257            mov dptr, #reflow_setup2
0A6C 12035B    1257            lcall ?Send_Constant_String
0A6F D0E0      1257            pop acc
0A71 D082      1257            pop dpl
0A73 D083      1257            pop dph
0A75           1258       ;Set_Cursor(2, 8)
0A75           1259       ;Send_Constant_String(#dots)
0A75 C0E0      1260            push acc
0A77 740C      1260            mov a, #12
0A79 14        1260            dec a
0A7A 120366    1260            lcall ?Set_Cursor_2 ; Select column and row
0A7D D0E0      1260            pop acc
0A7F C083      1261            push dph
0A81 C082      1261            push dpl
0A83 C0E0      1261            push acc
0A85 90042F    1261            mov dptr, #reflow_setup3
0A88 12035B    1261            lcall ?Send_Constant_String
0A8B D0E0      1261            pop acc
0A8D D082      1261            pop dpl
0A8F D083      1261            pop dph
0A91 C0E0      1262            push acc
0A93 7409      1262            mov a, #9
0A95 14        1262            dec a
0A96 120366    1262            lcall ?Set_Cursor_2 ; Select column and row
0A99 D0E0      1262            pop acc
0A9B C000      1263            push ar0
0A9D A856      1263            mov r0, reflow_time+1
0A9F 12036D    1263            lcall ?Display_BCD
0AA2 D000      1263            pop ar0
0AA4 C0E0      1264            push acc
0AA6 7407      1264            mov a, #7
0AA8 14        1264            dec a
0AA9 120366    1264            lcall ?Set_Cursor_2 ; Select column and row
0AAC D0E0      1264            pop acc
0AAE C000      1265            push ar0
0AB0 A855      1265            mov r0, reflow_time
0AB2 12036D    1265            lcall ?Display_BCD
0AB5 D000      1265            pop ar0
0AB7           1266   
0AB7 22        1267       ret
0AB8           1268       INC_DEC_Reflow_time:
0AB8           1269   
0AB8 20A121    1270            jb SETUP_SOAK_Button, check_decrement
0ABB C002      1270            push AR2
0ABD 7A0A      1270            mov R2, #10
0ABF 1202D7    1270            lcall ?Wait_Milli_Seconds
0AC2 D002      1270            pop AR2
0AC4 20A115    1270            jb SETUP_SOAK_Button, check_decrement
0AC7 30A1FD    1270            jnb SETUP_SOAK_Button, $
0ACA           1270    ; setup soak is also used to increment 
0ACA           1271   
0ACA E556      1272             mov a, reflow_time+1
0ACC 2401      1273               add a, #0x01
0ACE D4        1274               da a ; Decimal adjust instruction.  Check datasheet for more details!
0ACF F556      1275               mov reflow_time+1, a
0AD1 E556      1276               mov a, reflow_time+1
0AD3 7007      1277               jnz INC_reflow_time_done2
0AD5 E555      1278               mov a, reflow_time+0
0AD7 2401      1279               add a, #0x01
0AD9 D4        1280               da a ; Decimal adjust instruction.  Check datasheet for more details!
0ADA F555      1281               mov reflow_time+0, a
0ADC           1282              ; mov a, reflow_temp+1
0ADC           1283               INC_reflow_time_done2:
0ADC           1284   
0ADC           1285           check_decrement:
0ADC           1286           
0ADC 20A621    1287            jb Button_min, INC_reflow_time_done
0ADF C002      1287            push AR2
0AE1 7A0A      1287            mov R2, #10
0AE3 1202D7    1287            lcall ?Wait_Milli_Seconds
0AE6 D002      1287            pop AR2
0AE8           1287   
0AE8 20A615    1287            jb Button_min, INC_reflow_time_done
0AEB 30A6FD    1287            jnb Button_min, $
0AEE           1287   
0AEE E556      1288               mov a, reflow_time+1
0AF0 2499      1289               add a, #0x99
0AF2 D4        1290               da a ; Decimal adjust instruction.  Check datasheet for more details!
0AF3 F556      1291               mov reflow_time+1, a
0AF5 E556      1292               mov a, reflow_time+1
0AF7 7007      1293               jnz INC_reflow_time_done
0AF9 E555      1294               mov a, reflow_time+0
0AFB 2499      1295               add a, #0x99
0AFD D4        1296               da a ; Decimal adjust instruction.  Check datasheet for more details!
0AFE F555      1297               mov reflow_time+0, a
0B00           1298             ;  mov a, reflow_temp+1
0B00           1299               INC_reflow_time_done:
0B00 22        1300           ret
0B01           1301       INC_DEC_Reflow_temp:
0B01           1302           ;PushButton(SETUP_SOAK_Button,check_decrement2) ; setup soak is also used to increment 
0B01           1303   
0B01 20A121    1304            jb SETUP_SOAK_Button, check_decrement2
0B04 C002      1304            push AR2
0B06 7A0A      1304            mov R2, #10
0B08 1202D7    1304            lcall ?Wait_Milli_Seconds
0B0B D002      1304            pop AR2
0B0D 20A115    1304            jb SETUP_SOAK_Button, check_decrement2
0B10 30A1FD    1304            jnb SETUP_SOAK_Button, $
0B13           1304   
0B13           1305             ;  jb SETUP_SOAK_Button, check_decrement2  
0B13           1306             ;      Wait_Milli_Seconds(#50)         
0B13           1307             ;  jb SETUP_SOAK_Button, check_decrement2  
0B13           1308             ;  loop_hold_inc:
0B13           1309   
0B13           1310             ;  jnb SETUP_SOAK_Button, jump2
0B13           1311             ;  ;Wait_Milli_Seconds(#50)
0B13           1312             ;  jnb SETUP_SOAK_Button, jump2
0B13           1313             ;  ljmp hold_done
0B13           1314             ;  jump2:
0B13           1315             ;  Set_Cursor(1, 5)
0B13           1316             ;  Display_BCD(reflow_temp+0)
0B13           1317             ;  Set_Cursor(1, 7)
0B13           1318             ;  Display_BCD(reflow_temp+1)
0B13           1319             ;  Wait_Milli_Seconds(#100)    
0B13 E552      1320               mov a, reflow_temp+1
0B15 2401      1321               add a, #0x01
0B17 D4        1322               da a ; Decimal adjust instruction.  Check datasheet for more details!
0B18 F552      1323               mov reflow_temp+1, a
0B1A E552      1324               mov a, reflow_temp+1
0B1C 7007      1325               jnz INC_reflow_temp_done2
0B1E E551      1326               mov a, reflow_temp+0
0B20 2401      1327               add a, #0x01
0B22 D4        1328               da a ; Decimal adjust instruction.  Check datasheet for more details!
0B23 F551      1329               mov reflow_temp+0, a
0B25           1330              ; mov a, reflow_temp+1
0B25           1331               INC_reflow_temp_done2:
0B25           1332               
0B25           1333             ;  ljmp loop_hold_inc
0B25           1334           hold_done:
0B25           1335           
0B25           1336   
0B25           1337   
0B25           1338           check_decrement2:
0B25           1339   
0B25 20A621    1340            jb Button_min, DEC_reflow_temp_done2
0B28 C002      1340            push AR2
0B2A 7A0A      1340            mov R2, #10
0B2C 1202D7    1340            lcall ?Wait_Milli_Seconds
0B2F D002      1340            pop AR2
0B31 20A615    1340            jb Button_min, DEC_reflow_temp_done2
0B34 30A6FD    1340            jnb Button_min, $
0B37           1340   
0B37           1341            ;   jb Button_min, DEC_reflow_temp_done2  
0B37           1342            ;       Wait_Milli_Seconds(#50)         
0B37           1343            ;   jb Button_min, DEC_reflow_temp_done2  
0B37           1344            ;   loop_hold_dec:
0B37           1345   
0B37           1346            ;   jnb Button_min, jump3
0B37           1347            ;   ljmp DEC_reflow_temp_done2
0B37           1348            ;   jump3:
0B37           1349            ;   Set_Cursor(1, 5)
0B37           1350            ;   Display_BCD(reflow_temp+0)
0B37           1351            ;   Set_Cursor(1, 7)
0B37           1352            ;   Display_BCD(reflow_temp+1)
0B37           1353            ;   Wait_Milli_Seconds(#100)    
0B37 E552      1354               mov a, reflow_temp+1
0B39 2499      1355               add a, #0x99
0B3B D4        1356               da a ; Decimal adjust instruction.  Check datasheet for more details!
0B3C F552      1357               mov reflow_temp+1, a
0B3E E552      1358               mov a, reflow_temp+1
0B40 7007      1359               jnz INC_reflow_temp_done
0B42 E551      1360               mov a, reflow_temp+0
0B44 2499      1361               add a, #0x99
0B46 D4        1362               da a ; Decimal adjust instruction.  Check datasheet for more details!
0B47 F551      1363               mov reflow_temp+0, a
0B49           1364             ;  mov a, reflow_temp+1
0B49           1365               INC_reflow_temp_done:
0B49           1366               
0B49           1367             ;  ljmp loop_hold_dec
0B49           1368   
0B49           1369           DEC_reflow_temp_done2:
0B49           1370       
0B49           1371   
0B49 22        1372       ret
0B4A           1373   setup_soak_page:
0B4A 20A011    1374            jb set_BUTTON, continue11
0B4D C002      1374            push AR2
0B4F 7A0A      1374            mov R2, #10
0B51 1202D7    1374            lcall ?Wait_Milli_Seconds
0B54 D002      1374            pop AR2
0B56 20A005    1374            jb set_BUTTON, continue11
0B59 30A0FD    1374            jnb set_BUTTON, $
0B5C           1374   
0B5C B20A      1375       cpl tt_flag_soak
0B5E           1376       continue11:
0B5E           1377   
0B5E 200A06    1378       jb tt_flag_soak, jump4
0B61 120C27    1379       lcall INC_DEC_soak_time
0B64 020B6A    1380       ljmp display_soak_page
0B67           1381       jump4:
0B67 120C70    1382       lcall INC_DEC_soak_temp
0B6A           1383   
0B6A           1384   
0B6A           1385       display_soak_page:
0B6A C0E0      1386            push acc
0B6C 7405      1386            mov a, #5
0B6E 14        1386            dec a
0B6F 120368    1386            lcall ?Set_Cursor_1 ; Select column and row
0B72 D0E0      1386            pop acc
0B74 C000      1387            push ar0
0B76 A853      1387            mov r0, soak_temp+0
0B78 12036D    1387            lcall ?Display_BCD
0B7B D000      1387            pop ar0
0B7D C0E0      1388            push acc
0B7F 7407      1388            mov a, #7
0B81 14        1388            dec a
0B82 120368    1388            lcall ?Set_Cursor_1 ; Select column and row
0B85 D0E0      1388            pop acc
0B87 C000      1389            push ar0
0B89 A854      1389            mov r0, soak_temp+1
0B8B 12036D    1389            lcall ?Display_BCD
0B8E D000      1389            pop ar0
0B90           1390          
0B90           1391       
0B90 C0E0      1392            push acc
0B92 7401      1392            mov a, #1
0B94 14        1392            dec a
0B95 120368    1392            lcall ?Set_Cursor_1 ; Select column and row
0B98 D0E0      1392            pop acc
0B9A C083      1393            push dph
0B9C C082      1393            push dpl
0B9E C0E0      1393            push acc
0BA0 900434    1393            mov dptr, #soak_setup0
0BA3 12035B    1393            lcall ?Send_Constant_String
0BA6 D0E0      1393            pop acc
0BA8 D082      1393            pop dpl
0BAA D083      1393            pop dph
0BAC C0E0      1394            push acc
0BAE 7409      1394            mov a, #9
0BB0 14        1394            dec a
0BB1 120368    1394            lcall ?Set_Cursor_1 ; Select column and row
0BB4 D0E0      1394            pop acc
0BB6           1394   
0BB6 C083      1395            push dph
0BB8 C082      1395            push dpl
0BBA C0E0      1395            push acc
0BBC 900439    1395            mov dptr, #soak_setup1
0BBF 12035B    1395            lcall ?Send_Constant_String
0BC2 D0E0      1395            pop acc
0BC4 D082      1395            pop dpl
0BC6 D083      1395            pop dph
0BC8           1396   
0BC8 C0E0      1397            push acc
0BCA 7401      1397            mov a, #1
0BCC 14        1397            dec a
0BCD 120366    1397            lcall ?Set_Cursor_2 ; Select column and row
0BD0 D0E0      1397            pop acc
0BD2           1397   
0BD2 C083      1398            push dph
0BD4 C082      1398            push dpl
0BD6 C0E0      1398            push acc
0BD8 900441    1398            mov dptr, #soak_setup2
0BDB 12035B    1398            lcall ?Send_Constant_String
0BDE D0E0      1398            pop acc
0BE0 D082      1398            pop dpl
0BE2 D083      1398            pop dph
0BE4           1399       ;Set_Cursor(2, 8)
0BE4           1400      ; Send_Constant_String(#dots)
0BE4 C0E0      1401            push acc
0BE6 740C      1401            mov a, #12
0BE8 14        1401            dec a
0BE9 120366    1401            lcall ?Set_Cursor_2 ; Select column and row
0BEC D0E0      1401            pop acc
0BEE C083      1402            push dph
0BF0 C082      1402            push dpl
0BF2 C0E0      1402            push acc
0BF4 900452    1402            mov dptr, #soak_setup3
0BF7 12035B    1402            lcall ?Send_Constant_String
0BFA D0E0      1402            pop acc
0BFC D082      1402            pop dpl
0BFE D083      1402            pop dph
0C00 C0E0      1403            push acc
0C02 7409      1403            mov a, #9
0C04 14        1403            dec a
0C05 120366    1403            lcall ?Set_Cursor_2 ; Select column and row
0C08 D0E0      1403            pop acc
0C0A           1403   
0C0A C000      1404            push ar0
0C0C A858      1404            mov r0, soak_time+1
0C0E 12036D    1404            lcall ?Display_BCD
0C11 D000      1404            pop ar0
0C13 C0E0      1405            push acc
0C15 7407      1405            mov a, #7
0C17 14        1405            dec a
0C18 120366    1405            lcall ?Set_Cursor_2 ; Select column and row
0C1B D0E0      1405            pop acc
0C1D C000      1406            push ar0
0C1F A857      1406            mov r0, soak_time
0C21 12036D    1406            lcall ?Display_BCD
0C24 D000      1406            pop ar0
0C26 22        1407   ret
0C27           1408       INC_DEC_soak_time:
0C27           1409       
0C27 20A121    1410            jb SETUP_SOAK_Button, check_decrement_soak
0C2A C002      1410            push AR2
0C2C 7A0A      1410            mov R2, #10
0C2E 1202D7    1410            lcall ?Wait_Milli_Seconds
0C31 D002      1410            pop AR2
0C33 20A115    1410            jb SETUP_SOAK_Button, check_decrement_soak
0C36 30A1FD    1410            jnb SETUP_SOAK_Button, $
0C39           1410    ; setup soak is also used to increment 
0C39           1411   
0C39 E558      1412               mov a, soak_time+1
0C3B 2401      1413               add a, #0x01
0C3D D4        1414               da a ; Decimal adjust instruction.  Check datasheet for more details!
0C3E F558      1415               mov soak_time+1, a
0C40 E558      1416               mov a, soak_time+1
0C42 7007      1417               jnz INC_soak_time_done2
0C44 E557      1418               mov a, soak_time+0
0C46 2401      1419               add a, #0x01
0C48 D4        1420               da a ; Decimal adjust instruction.  Check datasheet for more details!
0C49 F557      1421               mov soak_time+0, a
0C4B           1422              ; mov a, soak_temp+1
0C4B           1423               INC_soak_time_done2:
0C4B           1424   
0C4B           1425           check_decrement_soak:
0C4B 20A621    1426            jb Button_min, continue13
0C4E C002      1426            push AR2
0C50 7A0A      1426            mov R2, #10
0C52 1202D7    1426            lcall ?Wait_Milli_Seconds
0C55 D002      1426            pop AR2
0C57 20A615    1426            jb Button_min, continue13
0C5A 30A6FD    1426            jnb Button_min, $
0C5D           1426   
0C5D E558      1427               mov a, soak_time+1
0C5F 2499      1428               add a, #0x99
0C61 D4        1429               da a ; Decimal adjust instruction.  Check datasheet for more details!
0C62 F558      1430               mov soak_time+1, a
0C64 E558      1431               mov a, soak_time+1
0C66 7007      1432               jnz DEC_soak_time_done
0C68 E557      1433               mov a, soak_time+0
0C6A 2499      1434               add a, #0x99
0C6C D4        1435               da a ; Decimal adjust instruction.  Check datasheet for more details!
0C6D F557      1436               mov soak_time+0, a
0C6F           1437             ;  mov a, soak_temp+1
0C6F           1438               DEC_soak_time_done:
0C6F           1439           continue13:
0C6F           1440           
0C6F 22        1441           ret
0C70           1442       INC_DEC_soak_temp:
0C70           1443           
0C70 20A121    1444            jb SETUP_SOAK_Button, check_decrement2_soak
0C73 C002      1444            push AR2
0C75 7A0A      1444            mov R2, #10
0C77 1202D7    1444            lcall ?Wait_Milli_Seconds
0C7A D002      1444            pop AR2
0C7C 20A115    1444            jb SETUP_SOAK_Button, check_decrement2_soak
0C7F 30A1FD    1444            jnb SETUP_SOAK_Button, $
0C82           1444   
0C82           1445           ;    jb SETUP_SOAK_Button, check_decrement2_soak  
0C82           1446           ;        Wait_Milli_Seconds(#50)         
0C82           1447           ;    jb SETUP_SOAK_Button, check_decrement2_soak  
0C82           1448           ;    loop_hold_inc_soak:
0C82           1449         ;
0C82           1450           ;    jnb SETUP_SOAK_Button, jump6
0C82           1451           ;    Wait_Milli_Seconds(#100)
0C82           1452           ;    jnb SETUP_SOAK_Button, jump6
0C82           1453           ;    ljmp hold_done_soak
0C82           1454           ;    jump6:
0C82           1455           ;    Set_Cursor(1, 5)
0C82           1456           ;    Display_BCD(soak_temp+0)
0C82           1457           ;    Set_Cursor(1, 7)
0C82           1458           ;    Display_BCD(soak_temp+1)
0C82           1459           ;    Wait_Milli_Seconds(#200)    
0C82 E554      1460               mov a, soak_temp+1
0C84 2401      1461               add a, #0x01
0C86 D4        1462               da a ; Decimal adjust instruction.  Check datasheet for more details!
0C87 F554      1463               mov soak_temp+1, a
0C89 E554      1464               mov a, soak_temp+1
0C8B 7007      1465               jnz INC_soak_temp_done2
0C8D E553      1466               mov a, soak_temp+0
0C8F 2401      1467               add a, #0x01
0C91 D4        1468               da a ; Decimal adjust instruction.  Check datasheet for more details!
0C92 F553      1469               mov soak_temp+0, a
0C94           1470              ; mov a, soak_temp+1
0C94           1471               INC_soak_temp_done2:
0C94           1472               
0C94           1473             ;  ljmp loop_hold_inc_soak
0C94           1474           hold_done_soak:
0C94           1475           
0C94           1476   
0C94           1477   
0C94           1478           check_decrement2_soak:
0C94           1479   
0C94 20A621    1480            jb Button_min, DEC_soak_temp_done2
0C97 C002      1480            push AR2
0C99 7A0A      1480            mov R2, #10
0C9B 1202D7    1480            lcall ?Wait_Milli_Seconds
0C9E D002      1480            pop AR2
0CA0 20A615    1480            jb Button_min, DEC_soak_temp_done2
0CA3 30A6FD    1480            jnb Button_min, $
0CA6           1480   
0CA6           1481              ; 
0CA6           1482              ; jb Button_min, DEC_soak_temp_done2  
0CA6           1483              ;     Wait_Milli_Seconds(#50)         
0CA6           1484              ; jb Button_min, DEC_soak_temp_done2  
0CA6           1485              ; loop_hold_dec_soak:
0CA6           1486                ;
0CA6           1487              ; jnb Button_min, jump7
0CA6           1488              ; Wait_Milli_Seconds(#100)
0CA6           1489              ; jnb Button_min, jump7
0CA6           1490              ; ljmp DEC_soak_temp_done2
0CA6           1491              ; jump7:
0CA6           1492              ; Set_Cursor(1, 5)
0CA6           1493              ; Display_BCD(soak_temp+0)
0CA6           1494              ; Set_Cursor(1, 7)
0CA6           1495              ; Display_BCD(soak_temp+1)
0CA6           1496              ; Wait_Milli_Seconds(#100)    
0CA6 E554      1497               mov a, soak_temp+1
0CA8 2499      1498               add a, #0x99
0CAA D4        1499               da a ; Decimal adjust instruction.  Check datasheet for more details!
0CAB F554      1500               mov soak_temp+1, a
0CAD E554      1501               mov a, soak_temp+1
0CAF 7007      1502               jnz INC_soak_temp_done
0CB1 E553      1503               mov a, soak_temp+0
0CB3 2499      1504               add a, #0x99
0CB5 D4        1505               da a ; Decimal adjust instruction.  Check datasheet for more details!
0CB6 F553      1506               mov soak_temp+0, a
0CB8           1507             ;  mov a, soak_temp+1
0CB8           1508               INC_soak_temp_done:
0CB8           1509               
0CB8           1510              ; ljmp loop_hold_dec_soak
0CB8           1511   
0CB8           1512           DEC_soak_temp_done2:
0CB8 22        1513           ret
0CB9           1514   second_page:
0CB9 C0E0      1515            push acc
0CBB 7401      1515            mov a, #1
0CBD 14        1515            dec a
0CBE 120368    1515            lcall ?Set_Cursor_1 ; Select column and row
0CC1 D0E0      1515            pop acc
0CC3 C083      1516            push dph
0CC5 C082      1516            push dpl
0CC7 C0E0      1516            push acc
0CC9 90040B    1516            mov dptr, #soak_reflw
0CCC 12035B    1516            lcall ?Send_Constant_String
0CCF D0E0      1516            pop acc
0CD1 D082      1516            pop dpl
0CD3 D083      1516            pop dph
0CD5 C0E0      1517            push acc
0CD7 7401      1517            mov a, #1
0CD9 14        1517            dec a
0CDA 120366    1517            lcall ?Set_Cursor_2 ; Select column and row
0CDD D0E0      1517            pop acc
0CDF C083      1518            push dph
0CE1 C082      1518            push dpl
0CE3 C0E0      1518            push acc
0CE5 9003A5    1518            mov dptr, #nothing
0CE8 12035B    1518            lcall ?Send_Constant_String
0CEB D0E0      1518            pop acc
0CED D082      1518            pop dpl
0CEF D083      1518            pop dph
0CF1 22        1519       ret
0CF2           1520   
0CF2           1521   FSM_LCD:
0CF2 E54A      1522           mov a, state_lcd
0CF4           1523   
0CF4           1524   
0CF4           1525           ;----------------STATE 0------------------;
0CF4           1526            home_state:
0CF4 B4001E    1527               cjne a, #0, soak_reflow_state
0CF7 20A015    1528            jb set_BUTTON, done_home2
0CFA C002      1528            push AR2
0CFC 7A0A      1528            mov R2, #10
0CFE 1202D7    1528            lcall ?Wait_Milli_Seconds
0D01 D002      1528            pop AR2
0D03 20A009    1528            jb set_BUTTON, done_home2
0D06 30A0FD    1528            jnb set_BUTTON, $
0D09           1528    
0D09           1529               ;setb set_flag  
0D09 754A01    1530               mov state_lcd, #1
0D0C 020D12    1531               ljmp done_home
0D0F           1532               done_home2:
0D0F           1533               ;clr set_flag
0D0F 1209B0    1534               lcall home_page
0D12           1535               done_home:
0D12 020DB1    1536               ljmp Forever_done           
0D15           1537           ;------------------------------------------;
0D15           1538           
0D15           1539        ;   ;----------------STATE 1-------------------;
0D15           1540           soak_reflow_state:
0D15 B4014B    1541               cjne a, #1, setup_soak
0D18 120CB9    1542               lcall second_page
0D1B           1543             ;  Wait_Milli_Seconds(#50)
0D1B 120990    1544               lcall sec_counter ; prevent the timer to go over 60
0D1E 1209A0    1545               lcall min_counter
0D21 20A712    1546            jb HOME_BUTTON, next_pushb
0D24 C002      1546            push AR2
0D26 7A0A      1546            mov R2, #10
0D28 1202D7    1546            lcall ?Wait_Milli_Seconds
0D2B D002      1546            pop AR2
0D2D 20A706    1546            jb HOME_BUTTON, next_pushb
0D30 30A7FD    1546            jnb HOME_BUTTON, $
0D33           1546    ; check if home button is pressed 
0D33 754A00    1547               mov state_lcd, #0
0D36           1548               next_pushb:
0D36 20A112    1549            jb SETUP_SOAK_Button, next_pushb2
0D39 C002      1549            push AR2
0D3B 7A0A      1549            mov R2, #10
0D3D 1202D7    1549            lcall ?Wait_Milli_Seconds
0D40 D002      1549            pop AR2
0D42 20A106    1549            jb SETUP_SOAK_Button, next_pushb2
0D45 30A1FD    1549            jnb SETUP_SOAK_Button, $
0D48           1549    ; check if the the button to setup soak is pressed
0D48 754A02    1550               mov state_lcd, #2
0D4B           1551               next_pushb2:
0D4B 20A612    1552            jb Button_min, done_soak
0D4E C002      1552            push AR2
0D50 7A0A      1552            mov R2, #10
0D52 1202D7    1552            lcall ?Wait_Milli_Seconds
0D55 D002      1552            pop AR2
0D57 20A606    1552            jb Button_min, done_soak
0D5A 30A6FD    1552            jnb Button_min, $
0D5D           1552    ; check if the buttion to setup the reflow was pressed 
0D5D 754A03    1553               mov state_lcd, #3
0D60           1554               done_soak:
0D60 020DB1    1555              ljmp Forever_done 
0D63           1556           ;------------------------------------------;
0D63           1557   ;
0D63           1558        ;   ;-----------------STATE 2------------------;
0D63           1559           setup_soak: ; its actually set up reflow Im dumb
0D63 B40221    1560               cjne a, #2, setup_reflow
0D66 1209DB    1561               lcall setup_reflow_page
0D69           1562             ;  Wait_Milli_Seconds(#50)
0D69 120990    1563               lcall sec_counter ; prevent the timer to go over 60
0D6C 1209A0    1564               lcall min_counter
0D6F 20A712    1565            jb HOME_BUTTON, done_setup_soak
0D72 C002      1565            push AR2
0D74 7A0A      1565            mov R2, #10
0D76 1202D7    1565            lcall ?Wait_Milli_Seconds
0D79 D002      1565            pop AR2
0D7B 20A706    1565            jb HOME_BUTTON, done_setup_soak
0D7E 30A7FD    1565            jnb HOME_BUTTON, $
0D81           1565    ; check if home button is pressed 
0D81 754A00    1566               mov state_lcd, #0
0D84           1567               done_setup_soak:
0D84 020DB1    1568               ljmp Forever_done 
0D87           1569           ;------------------------------------------;
0D87           1570   ;
0D87           1571        ;   ;----------------STATE 3-------------------;
0D87           1572           setup_reflow: ; its actually set up soak Im dumb
0D87 B40303    1573               cjne a, #3, FDP
0D8A 020D90    1574               ljmp FDP2
0D8D           1575               FDP:
0D8D 020CF4    1576               ljmp home_state
0D90           1577               FDP2:
0D90 120B4A    1578               lcall setup_soak_page
0D93 120990    1579               lcall sec_counter ; prevent the timer to go over 60
0D96 1209A0    1580               lcall min_counter
0D99 20A712    1581            jb HOME_BUTTON, done_setup_reflow
0D9C C002      1581            push AR2
0D9E 7A0A      1581            mov R2, #10
0DA0 1202D7    1581            lcall ?Wait_Milli_Seconds
0DA3 D002      1581            pop AR2
0DA5 20A706    1581            jb HOME_BUTTON, done_setup_reflow
0DA8 30A7FD    1581            jnb HOME_BUTTON, $
0DAB           1581    ; check if home button is pressed 
0DAB 754A00    1582               mov state_lcd, #0
0DAE           1583               done_setup_reflow:
0DAE 020DB1    1584               ljmp Forever_done 
0DB1           1585        ;   ;------------------------------------------;
0DB1           1586           Forever_done:
0DB1 22        1587   ret
0DB2           1588   
0DB2           1589   ;------------------------------
0DB2           1590   ;---------------------------------;
0DB2           1591   ; Main program. Includes hardware ;
0DB2           1592   ; initialization and 'forever'    ;
0DB2           1593   ; loop.                           ;
0DB2           1594   ;---------------------------------;
0DB2           1595   main:
0DB2           1596            ; Initialization
0DB2 75817F    1597       mov SP, #0x7F
0DB5           1598   
0DB5 120638    1599       lcall Timer0_Init
0DB8 120663    1600       lcall Timer1_Init
0DBB           1601   
0DBB 12051A    1602       lcall Ports_Init ; Default all pins as bidirectional I/O. See Table 42.
0DBE 120326    1603       lcall LCD_4BIT
0DC1 120712    1604       lcall Double_Clk
0DC4 120702    1605            lcall InitDAC1 ; Call after 'Ports_Init'
0DC7 1206BC    1606            lcall CCU_Init
0DCA 120713    1607            lcall Init_SPI
0DCD           1608            
0DCD           1609            
0DCD D2AF      1610            setb EA ; Enable global interrupts.
0DCF           1611   
0DCF           1612            ; Initialize variables
0DCF C200      1613            clr T2S_FSM_Start
0DD1 756700    1614            mov T2S_FSM_state, #0
0DD4           1615       ; Configure all the ports in bidirectional mode:
0DD4           1616   
0DD4 758400    1617       mov P0M1, #00H
0DD7 758500    1618       mov P0M2, #00H
0DDA 759100    1619       mov P1M1, #00H
0DDD 759200    1620       mov P1M2, #00H ; WARNING: P1.2 and P1.3 need 1kohm pull-up resistors!
0DE0 75A400    1621       mov P2M1, #00H
0DE3 75A500    1622       mov P2M2, #00H
0DE6 75B100    1623       mov P3M1, #00H
0DE9 75B200    1624       mov P3M2, #00H
0DEC           1625       
0DEC           1626       ;mov minutes, #0
0DEC 756600    1627            mov seconds, #0
0DEF           1628   
0DEF           1629      ; lcall LCD_4BIT
0DEF           1630       ; For convenience a few handy macros are included in 'LCD_4bit_LPC9351.inc':
0DEF           1631   ;        Set_Cursor(1, 1)
0DEF           1632     ;  Display_BCD(BCD_counter)
0DEF           1633   
0DEF D203      1634       setb half_seconds_flag
0DF1 C20C      1635       clr my_flag   
0DF3           1636   
0DF3 755A00    1637            mov BCD_counter, #0x00
0DF6 754E00    1638            mov pwm , #0
0DF9 754C00    1639            mov sec , #0
0DFC 754900    1640            mov state, #0
0DFF 754B96    1641            mov temp, #150
0E02 754605    1642       mov time_soak, #5
0E05 7547DC    1643       mov temp_refl, #220
0E08 754505    1644       mov temp_soak, #5
0E0B 756900    1645       mov five_sec_flag,#0
0E0E           1646            ; After initialization the program stays in this 'forever' loop
0E0E           1647   
0E0E 755C00    1648       mov reflow_sec, #0x00
0E11 755D00    1649       mov reflow_min, #0x00
0E14 756500    1650       mov minutes, #0x00
0E17 754A00    1651       mov state_lcd, #0
0E1A C208      1652       clr TR1_flag
0E1C 755101    1653       mov reflow_temp+0, #0x01
0E1F 755250    1654       mov reflow_temp+1, #0x50
0E22 C209      1655       clr tt_reflow_flag
0E24 755700    1656       mov soak_time, #0x00
0E27 755850    1657       mov soak_time+1, #0x50
0E2A 755500    1658       mov reflow_time, #0x00
0E2D 755650    1659       mov reflow_time+1, #0x50
0E30 755301    1660       mov soak_temp, #0x01
0E33 755101    1661       mov reflow_temp+0, #0x01
0E36 755250    1662       mov reflow_temp+1, #0x50
0E39 C209      1663       clr tt_reflow_flag
0E3B 755700    1664       mov soak_time, #0x00
0E3E 755850    1665       mov soak_time+1, #0x50
0E41 755500    1666       mov reflow_time, #0x00
0E44 755650    1667       mov reflow_time+1, #0x50
0E47 755301    1668       mov soak_temp, #0x01
0E4A 755101    1669       mov reflow_temp+0, #0x01
0E4D 755250    1670       mov reflow_temp+1, #0x50
0E50 C209      1671       clr tt_reflow_flag
0E52 755700    1672       mov soak_time, #0x00
0E55 755850    1673       mov soak_time+1, #0x50
0E58 755500    1674       mov reflow_time, #0x00
0E5B 755650    1675       mov reflow_time+1, #0x50
0E5E 755301    1676       mov soak_temp, #0x01
0E61 755101    1677       mov reflow_temp+0, #0x01
0E64 755250    1678       mov reflow_temp+1, #0x50
0E67 C209      1679       clr tt_reflow_flag
0E69 755700    1680       mov soak_time, #0x00
0E6C 755850    1681       mov soak_time+1, #0x50
0E6F 755500    1682       mov reflow_time, #0x00
0E72 755650    1683       mov reflow_time+1, #0x50
0E75 755301    1684       mov soak_temp, #0x01
0E78 755101    1685       mov reflow_temp+0, #0x01
0E7B 755250    1686       mov reflow_temp+1, #0x50
0E7E C209      1687       clr tt_reflow_flag
0E80 755700    1688       mov soak_time, #0x00
0E83 755850    1689       mov soak_time+1, #0x50
0E86 755500    1690       mov reflow_time, #0x00
0E89 755650    1691       mov reflow_time+1, #0x50
0E8C 755301    1692       mov soak_temp, #0x01
0E8F 755101    1693       mov reflow_temp+0, #0x01
0E92 755250    1694       mov reflow_temp+1, #0x50
0E95 C209      1695       clr tt_reflow_flag
0E97 755700    1696       mov soak_time, #0x00
0E9A 755850    1697       mov soak_time+1, #0x50
0E9D 755500    1698       mov reflow_time, #0x00
0EA0 755650    1699       mov reflow_time+1, #0x50
0EA3 755301    1700       mov soak_temp, #0x01
0EA6 755101    1701       mov reflow_temp+0, #0x01
0EA9 755250    1702       mov reflow_temp+1, #0x50
0EAC C209      1703       clr tt_reflow_flag
0EAE 755700    1704       mov soak_time, #0x00
0EB1 755850    1705       mov soak_time+1, #0x50
0EB4 755500    1706       mov reflow_time, #0x00
0EB7 755650    1707       mov reflow_time+1, #0x50
0EBA 755301    1708       mov soak_temp, #0x01
0EBD 755450    1709       mov soak_temp+1, #0x50
0EC0 C20B      1710       clr stop_flag
0EC2 12051A    1711       lcall Ports_Init
0EC5 120533    1712       lcall InitSerialPort
0EC8 75A400    1713       mov P2M1, #0
0ECB 75A500    1714       mov P2M2, #0
0ECE           1715   
0ECE           1716       
0ECE           1717   forever:         
0ECE 120CF2    1718       lcall FSM_LCD
0ED1           1719   
0ED1 12083F    1720       lcall T2S_FSM
0ED4           1721            ; One second has passed, refresh the LCD with new time
0ED4           1722   ;        Set_Cursor(1, 1)
0ED4           1723   ;    Send_Constant_String(#timee)
0ED4           1724   ;    Set_Cursor(1, 5)
0ED4           1725   ;    Display_BCD(sec)
0ED4           1726   ;    Set_Cursor(2, 1)
0ED4           1727   ;    Send_Constant_String(#statee)
0ED4           1728    ;   Set_Cursor(2, 5)
0ED4           1729     ;  Display_BCD(BCD_counter)
0ED4           1730   
0ED4           1731       
0ED4           1732           
0ED4 20A614    1733       jb P2.6, continue19
0ED7 C002      1734            push AR2
0ED9 7A32      1734            mov R2, #50
0EDB 1202D7    1734            lcall ?Wait_Milli_Seconds
0EDE D002      1734            pop AR2 ; debounce
0EE0 20A608    1735            jb P2.6, continue19
0EE3 30A6FD    1736            jnb P2.6, $
0EE6 C28E      1737            clr TR1 
0EE8 020ECE    1738            ljmp forever
0EEB           1739      continue19:
0EEB           1740   
0EEB           1741   
0EEB           1742   
0EEB           1743     ;  mov a, five_sec_flag
0EEB           1744     ;  cjne a,#5, pass_quack
0EEB           1745     ;  quack_like_a_duck:
0EEB           1746     ;  clr TR1 ; Stop timer 1.
0EEB           1747     ;  mov a,#0
0EEB           1748     ;  mov five_sec_flag,a
0EEB           1749     ;  clr TR1 ; Stop timer 1.
0EEB           1750   ;        setb T2S_FSM_Start ; This plays the current minutes:seconds by making the state machine get out of state zero.
0EEB           1751     ;  pass_hash:
0EEB           1752     ;  pass_quack:ssss
0EEB           1753     ;  setb TR1 ; en timer 1.
0EEB           1754   
0EEB 120562    1755       lcall hannah
0EEE           1756      
0EEE           1757   
0EEE E549      1758       mov a, state
0EF0           1759     state0: 
0EF0 B40013    1760         cjne a, #0, state1
0EF3 754E00    1761         mov pwm, #0
0EF6 C28E      1762         clr TR1
0EF8 20B008    1763         jb p3.0, state0_done
0EFB 30B0FD    1764         jnb p3.0, $ ;wait for key release
0EFE D28E      1765         setb TR1
0F00 754901    1766         mov state, #1
0F03           1767     state0_done:
0F03 020ECE    1768         ljmp forever
0F06           1769      
0F06           1770      state1:
0F06 B4011A    1771         cjne a, #1 , state2
0F09 754E64    1772         mov pwm, #100
0F0C 754C00    1773         mov sec, #0
0F0F           1774   
0F0F C3        1775         clr c
0F10 E554      1776         mov a, soak_temp+1
0F12 9541      1777         subb a, bcd+1
0F14           1778         ;add branches to compare temp with 150
0F14 500A      1779         jnc state1_done
0F16           1780   
0F16 C3        1781         clr c
0F17 E553      1782         mov a, soak_temp+0
0F19 9540      1783         subb a, bcd+0
0F1B 5003      1784         jnc state1_done
0F1D           1785       
0F1D 754902    1786         mov state, #2
0F20           1787     state1_done:
0F20 020ECE    1788           ljmp forever
0F23           1789          
0F23           1790     state2: ;press p3.0 multiple time plz cos it is stuck
0F23 B40210    1791         cjne a, #2 , state3
0F26 754E14    1792         mov pwm, #20
0F29           1793         
0F29           1794   
0F29 C3        1795         clr c
0F2A E557      1796         mov a, soak_time+0
0F2C 954C      1797         subb a, sec
0F2E 5003      1798         jnc state2_done
0F30 754903    1799         mov state, #3
0F33           1800     state2_done:
0F33 020ECE    1801          ljmp forever          
0F36           1802     
0F36           1803     state3:
0F36 B4031C    1804         cjne a, #3 , state4
0F39 754E00    1805         mov pwm, #0
0F3C 754C00    1806         mov sec, #0     
0F3F           1807         
0F3F C3        1808         clr c
0F40 E552      1809         mov a, reflow_temp+1
0F42 9541      1810         subb a, bcd+1
0F44 500C      1811         jnc state3_done
0F46           1812   
0F46 C3        1813         clr c
0F47 E551      1814         mov a, reflow_temp+0
0F49 9540      1815         subb a, bcd+0
0F4B 5005      1816         jnc state3_done
0F4D           1817   
0F4D           1818         ;add branches to compare temp with 220
0F4D 5003      1819         jnc state3_done
0F4F 754904    1820         mov state, #4
0F52           1821     state3_done:
0F52 020ECE    1822          ljmp forever
0F55           1823          
0F55           1824      state4:
0F55 B40410    1825         cjne a, #4 , state5
0F58 754E28    1826         mov pwm, #40
0F5B           1827   
0F5B E548      1828         mov a, time_refl+0
0F5D C3        1829         clr c
0F5E 954C      1830         subb a, sec
0F60           1831         ;add branches to compare sec with 45
0F60 5003      1832         jnc state4_done
0F62 754905    1833         mov state, #5
0F65           1834     state4_done:
0F65 020ECE    1835          ljmp forever    
0F68           1836          
0F68           1837      state5:
0F68 B40585    1838         cjne a, #5 , state0
0F6B 754E64    1839         mov pwm, #100
0F6E C3        1840         clr c
0F6F 954B      1841         subb a, temp
0F71           1842         ;add branches to compare temp with 60
0F71 5003      1843         jnc state5_done
0F73 754900    1844         mov state, #0
0F76           1845     state5_done:
0F76 020ECE    1846          ljmp forever 
0F79           1847          
0F79           1848   
0F79           1849   EN
